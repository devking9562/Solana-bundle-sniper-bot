var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str2) {
  if (typeof str2 !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str2}`);
  }
  return new TextEncoder().encode(str2);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// src/base/base.ts
import { AccountLayout, TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID2 } from "@solana/spl-token";
import {
  Keypair as Keypair2,
  PublicKey as PublicKey9,
  SystemProgram as SystemProgram3
} from "@solana/web3.js";

// src/entity/amount.ts
import _Big2 from "big.js";
import BN5 from "bn.js";

// src/common/convert-json.ts
import { PublicKey as PublicKey3 } from "@solana/web3.js";
import { BN } from "bn.js";

// src/common/pubkey.ts
import { PublicKey as PublicKey2, SystemProgram } from "@solana/web3.js";

// src/common/logger.ts
import { PublicKey } from "@solana/web3.js";

// src/version.ts
var version = "1.1.0-beta.6";

// src/common/logger.ts
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
var _moduleLogLevel = {};
var _globalLogger;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
  }
  return "";
}
var _normalizeError = _checkNormalize();
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
  return LogLevel2;
})(LogLevel || {});
var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["RPC_ERROR"] = "RPC_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  return ErrorCode2;
})(ErrorCode || {});
var HEX = "0123456789abcdef";
function perfectDisplay(value, deeping = false) {
  let _value = value;
  try {
    if (value instanceof Uint8Array) {
      let hex = "";
      for (let i = 0; i < value.length; i++) {
        hex += HEX[value[i] >> 4];
        hex += HEX[value[i] & 15];
      }
      _value = `Uint8Array(0x${hex})`;
    } else if (value instanceof PublicKey) {
      _value = `PublicKey(${value.toBase58()})`;
    } else if (value instanceof Object && !deeping) {
      const obj = {};
      Object.entries(value).forEach(([k, v]) => {
        obj[k] = perfectDisplay(v, true);
      });
      _value = JSON.stringify(obj);
    } else if (!deeping) {
      _value = JSON.stringify(value);
    }
  } catch (error) {
    _value = JSON.stringify(value.toString());
  }
  return _value;
}
var _Logger = class _Logger {
  constructor(moduleName) {
    this.version = version;
    this.moduleName = moduleName;
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    const _logLevel = _moduleLogLevel[this.moduleName] || LogLevels["default"];
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log(...args);
  }
  debug(...args) {
    this._log(_Logger.levels.DEBUG, ["[DEBUG]", ...args]);
  }
  info(...args) {
    this._log(_Logger.levels.INFO, ["[INFO]", ...args]);
  }
  warn(...args) {
    this._log(_Logger.levels.WARNING, ["[WARN]", ...args]);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = _Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.entries(params).forEach(([key, value]) => {
      messageDetails.push(`${key}=${perfectDisplay(value)})`);
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`module=${this.moduleName}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.entries(params).forEach(([key, value]) => {
      error[key] = value;
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError(
        "cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class",
        _Logger.errors.UNSUPPORTED_OPERATION,
        { name: target.name, operation: "new" }
      );
    } else if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new _Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(moduleName, logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      _Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _moduleLogLevel[moduleName] = level;
  }
  static from(version2) {
    return new _Logger(version2);
  }
};
_Logger.errors = ErrorCode;
_Logger.levels = LogLevel;
var Logger = _Logger;

// src/common/pubkey.ts
import { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY } from "@solana/web3.js";
var logger = Logger.from("common/pubkey");
var SYSTEM_PROGRAM_ID = SystemProgram.programId;
var MEMO_PROGRAM_ID = new PublicKey2("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
var RENT_PROGRAM_ID = new PublicKey2("SysvarRent111111111111111111111111111111111");
var METADATA_PROGRAM_ID = new PublicKey2("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
var INSTRUCTION_PROGRAM_ID = new PublicKey2("Sysvar1nstructions1111111111111111111111111");
function validateAndParsePublicKey(publicKey2) {
  if (publicKey2 instanceof PublicKey2) {
    return publicKey2;
  }
  if (typeof publicKey2 === "string") {
    try {
      const key = new PublicKey2(publicKey2);
      return key;
    } catch (e) {
      return logger.throwArgumentError("invalid public key", "publicKey", publicKey2);
    }
  }
  return logger.throwArgumentError("invalid public key", "publicKey", publicKey2);
}
function findProgramAddress(seeds, programId) {
  const [publicKey2, nonce] = PublicKey2.findProgramAddressSync(seeds, programId);
  return { publicKey: publicKey2, nonce };
}
function AccountMeta(publicKey2, isSigner) {
  return {
    pubkey: publicKey2,
    isWritable: true,
    isSigner
  };
}
function AccountMetaReadonly(publicKey2, isSigner) {
  return {
    pubkey: publicKey2,
    isWritable: false,
    isSigner
  };
}

// src/common/convert-json.ts
function notInnerObject(v) {
  return typeof v === "object" && v !== null && ![TokenAmount, PublicKey3, Fraction, BN, Currency, CurrencyAmount, Price, Percent].some(
    (o) => typeof o === "object" && v instanceof o
  );
}
function jsonInfo2PoolKeys(jsonInfo) {
  return typeof jsonInfo === "string" ? validateAndParsePublicKey(jsonInfo) : Array.isArray(jsonInfo) ? jsonInfo.map((k) => jsonInfo2PoolKeys(k)) : notInnerObject(jsonInfo) ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, jsonInfo2PoolKeys(v)])) : jsonInfo;
}
function poolKeys2JsonInfo(jsonInfo) {
  return jsonInfo instanceof PublicKey3 ? jsonInfo.toBase58() : Array.isArray(jsonInfo) ? jsonInfo.map((k) => poolKeys2JsonInfo(k)) : notInnerObject(jsonInfo) ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, poolKeys2JsonInfo(v)])) : jsonInfo;
}

// src/common/inspect.ts
import { PublicKey as PublicKey4 } from "@solana/web3.js";
import BN2 from "bn.js";
function inspectPublicKey() {
  PublicKey4.prototype.inspect = function() {
    return `<PublicKey: ${this.toString()}>`;
  };
}
function inspectBN() {
  BN2.prototype.inspect = function() {
    return `<${this.red ? "BN-R" : "BN"}: ${this.toString()}>`;
  };
}
function inspectAll() {
  inspectPublicKey();
  inspectBN();
}

// src/common/lodash.ts
function chunkArray(arr, chunkSize = 1, cache = []) {
  const tmp = [...arr];
  if (chunkSize <= 0) return cache;
  while (tmp.length) cache.push(tmp.splice(0, chunkSize));
  return cache;
}
function intersection(arr, ...args) {
  return arr.filter((item) => args.every((arr2) => arr2.includes(item)));
}
function xor(arr, ...args) {
  return arr.filter((item) => args.every((arr2) => !arr2.includes(item)));
}
function uniq(arr) {
  return [...new Set(arr)];
}

// src/common/web3.ts
import {
  AddressLookupTableAccount,
  Keypair,
  PublicKey as PublicKey5,
  Transaction,
  TransactionMessage
} from "@solana/web3.js";

// src/base/instrument.ts
import { ComputeBudgetProgram } from "@solana/web3.js";
function addComputeBudget(config) {
  const ins = [];
  const insTypes = [];
  if (config.microLamports) {
    ins.push(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: config.microLamports }));
    insTypes.push(9 /* setComputeUnitPrice */);
  }
  if (config.units) {
    ins.push(ComputeBudgetProgram.setComputeUnitLimit({ units: config.units }));
    insTypes.push(10 /* setComputeUnitLimit */);
  }
  return {
    address: {},
    innerTransaction: {
      instructions: ins,
      signers: [],
      instructionTypes: insTypes
    }
  };
}

// src/common/web3.ts
var logger2 = Logger.from("common/web3");
function getMultipleAccountsInfo(connection, publicKeys, config) {
  return __async(this, null, function* () {
    const { batchRequest, commitment } = __spreadValues(__spreadValues({}, {
      batchRequest: false
    }), config);
    const chunkedKeys = chunkArray(publicKeys, 100);
    let results = new Array(chunkedKeys.length).fill([]);
    if (batchRequest) {
      const batch = chunkedKeys.map((keys) => {
        const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, "base64");
        return {
          methodName: "getMultipleAccounts",
          args
        };
      });
      const _batch = chunkArray(batch, 10);
      const unsafeResponse = yield (yield Promise.all(
        _batch.map(
          (i) => __async(this, null, function* () {
            return (
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore
              yield connection._rpcBatchRequest(i)
            );
          })
        )
      )).flat();
      results = unsafeResponse.map((unsafeRes) => {
        if (unsafeRes.error) {
          return logger2.throwError("failed to get info for multiple accounts", Logger.errors.RPC_ERROR, {
            message: unsafeRes.error.message
          });
        }
        return unsafeRes.result.value.map((accountInfo) => {
          if (accountInfo) {
            const { data, executable, lamports, owner, rentEpoch } = accountInfo;
            if (data.length !== 2 && data[1] !== "base64") {
              return logger2.throwError("info must be base64 encoded", Logger.errors.RPC_ERROR);
            }
            return {
              data: Buffer.from(data[0], "base64"),
              executable,
              lamports,
              owner: new PublicKey5(owner),
              rentEpoch
            };
          } else {
            return null;
          }
        });
      });
    } else {
      try {
        results = yield Promise.all(
          chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment))
        );
      } catch (error) {
        if (error instanceof Error) {
          return logger2.throwError("failed to get info for multiple accounts", Logger.errors.RPC_ERROR, {
            message: error.message
          });
        }
      }
    }
    return results.flat();
  });
}
function getMultipleAccountsInfoWithCustomFlags(connection, publicKeysWithCustomFlag, config) {
  return __async(this, null, function* () {
    const multipleAccountsInfo = yield getMultipleAccountsInfo(
      connection,
      publicKeysWithCustomFlag.map((o) => o.pubkey),
      config
    );
    return publicKeysWithCustomFlag.map((o, idx) => __spreadProps(__spreadValues({}, o), { accountInfo: multipleAccountsInfo[idx] }));
  });
}
function forecastTransactionSize(instructions, signers) {
  if (instructions.length < 1) {
    return logger2.throwArgumentError("no instructions provided", "instructions", instructions);
  }
  if (signers.length < 1) {
    return logger2.throwArgumentError("no signers provided", "signers", signers);
  }
  const transaction = new Transaction({
    recentBlockhash: "11111111111111111111111111111111",
    feePayer: signers[0]
  });
  transaction.add(...instructions);
  try {
    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString("base64").length < MAX_BASE64_SIZE;
  } catch (error) {
    return false;
  }
}
function simulateMultipleInstruction(connection, instructions, keyword, batchRequest = true) {
  return __async(this, null, function* () {
    const feePayer = new PublicKey5("RaydiumSimuLateTransaction11111111111111111");
    const transactions = [];
    let transaction = new Transaction();
    transaction.feePayer = feePayer;
    for (const instruction of instructions) {
      if (!forecastTransactionSize([...transaction.instructions, instruction], [feePayer])) {
        transactions.push(transaction);
        transaction = new Transaction();
        transaction.feePayer = feePayer;
      }
      transaction.add(instruction);
    }
    if (transaction.instructions.length > 0) {
      transactions.push(transaction);
    }
    let results = [];
    try {
      results = yield simulateTransaction(connection, transactions, batchRequest);
      if (results.find((i) => i.err !== null)) throw Error("rpc simulateTransaction error");
    } catch (error) {
      if (error instanceof Error) {
        return logger2.throwError("failed to simulate for instructions", Logger.errors.RPC_ERROR, {
          message: error.message
        });
      }
    }
    const logs = [];
    for (const result of results) {
      logger2.debug("simulate result:", result);
      if (result.logs) {
        const filteredLog = result.logs.filter((log) => log && log.includes(keyword));
        logger2.debug("filteredLog:", logs);
        logger2.assertArgument(filteredLog.length !== 0, "simulate log not match keyword", "keyword", keyword);
        logs.push(...filteredLog);
      }
    }
    return logs;
  });
}
function parseSimulateLogToJson(log, keyword) {
  const results = log.match(/{["\w:,]+}/g);
  if (!results || results.length !== 1) {
    return logger2.throwArgumentError("simulate log fail to match json", "keyword", keyword);
  }
  return results[0];
}
function parseSimulateValue(log, key) {
  const reg = new RegExp(`"${key}":(\\d+)`, "g");
  const results = reg.exec(log);
  if (!results || results.length !== 2) {
    return logger2.throwArgumentError("simulate log fail to match key", "key", key);
  }
  return results[1];
}
function simulateTransaction(connection, transactions, batchRequest) {
  return __async(this, null, function* () {
    let results = [];
    if (batchRequest) {
      const getLatestBlockhash = yield connection.getLatestBlockhash();
      const encodedTransactions = [];
      for (const transaction of transactions) {
        transaction.recentBlockhash = getLatestBlockhash.blockhash;
        transaction.lastValidBlockHeight = getLatestBlockhash.lastValidBlockHeight;
        const message = transaction._compile();
        const signData = message.serialize();
        const wireTransaction = transaction._serialize(signData);
        const encodedTransaction = wireTransaction.toString("base64");
        encodedTransactions.push(encodedTransaction);
      }
      const batch = encodedTransactions.map((keys) => {
        const args = connection._buildArgs([keys], void 0, "base64");
        return {
          methodName: "simulateTransaction",
          args
        };
      });
      const reqData = [];
      const itemReqIndex = 20;
      for (let i = 0; i < Math.ceil(batch.length / itemReqIndex); i++) {
        reqData.push(batch.slice(i * itemReqIndex, (i + 1) * itemReqIndex));
      }
      results = yield (yield Promise.all(
        reqData.map((i) => __async(this, null, function* () {
          const d = yield connection._rpcBatchRequest(i);
          return d.map((ii) => ii.result.value);
        }))
      )).flat();
    } else {
      try {
        results = yield Promise.all(
          transactions.map((transaction) => __async(this, null, function* () {
            return yield (yield connection.simulateTransaction(transaction)).value;
          }))
        );
      } catch (error) {
        if (error instanceof Error) {
          return logger2.throwError("failed to get info for multiple accounts", Logger.errors.RPC_ERROR, {
            message: error.message
          });
        }
      }
    }
    return results;
  });
}
function splitTxAndSigners(_0) {
  return __async(this, arguments, function* ({
    connection,
    makeTxVersion,
    innerTransaction,
    lookupTableCache,
    computeBudgetConfig,
    payer
  }) {
    const lookupTableAddressAccount = lookupTableCache != null ? lookupTableCache : {};
    const allLTA = [
      ...new Set(innerTransaction.map((i) => {
        var _a;
        return ((_a = i.lookupTableAddress) != null ? _a : []).map((ii) => ii.toString());
      }).flat())
    ];
    const needCacheLTA = [];
    for (const item of allLTA) {
      if (lookupTableAddressAccount[item] === void 0) needCacheLTA.push(new PublicKey5(item));
    }
    const newCacheLTA = yield getMultipleLookupTableInfo({ connection, address: needCacheLTA });
    for (const [key, value] of Object.entries(newCacheLTA)) lookupTableAddressAccount[key] = value;
    const addComputeBudgetInnerTx = computeBudgetConfig ? addComputeBudget(computeBudgetConfig).innerTransaction : void 0;
    const transactions = [];
    let itemIns = [];
    for (const itemInnerTx of innerTransaction) {
      if (itemInnerTx.instructions.length === 0) continue;
      const _itemIns = [...itemIns, itemInnerTx];
      const _addComputeBudgetInnerTx = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ..._itemIns] : _itemIns;
      if (itemIns.length < 12 && (checkTx({ makeTxVersion, innerIns: _addComputeBudgetInnerTx, payer, lookupTableAddressAccount }) || checkTx({ makeTxVersion, innerIns: _itemIns, payer, lookupTableAddressAccount }))) {
        itemIns.push(itemInnerTx);
      } else {
        if (itemIns.length === 0) throw Error(" item ins too big ");
        let lookupTableAddress = void 0;
        if (makeTxVersion === 0 /* V0 */) {
          lookupTableAddress = {};
          for (const item of [
            ...new Set(
              itemIns.map((i) => {
                var _a;
                return (_a = i.lookupTableAddress) != null ? _a : [];
              }).flat().map((i) => i.toString())
            )
          ]) {
            if (lookupTableAddressAccount[item] !== void 0) lookupTableAddress[item] = lookupTableAddressAccount[item];
          }
        }
        if (checkTx({
          makeTxVersion,
          innerIns: addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns,
          payer,
          lookupTableAddressAccount
        })) {
          const _i = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns;
          transactions.push({
            instructionTypes: _i.map((i) => i.instructionTypes).flat(),
            instructions: _i.map((i) => i.instructions).flat(),
            signers: itemIns.map((i) => i.signers).flat(),
            lookupTableAddress
          });
        } else {
          transactions.push({
            instructionTypes: itemIns.map((i) => i.instructionTypes).flat(),
            instructions: itemIns.map((i) => i.instructions).flat(),
            signers: itemIns.map((i) => i.signers).flat(),
            lookupTableAddress
          });
        }
        itemIns = [itemInnerTx];
      }
    }
    if (itemIns.length > 0) {
      let lookupTableAddress = void 0;
      if (makeTxVersion === 0 /* V0 */) {
        lookupTableAddress = {};
        for (const item of [
          ...new Set(
            itemIns.map((i) => {
              var _a;
              return (_a = i.lookupTableAddress) != null ? _a : [];
            }).flat().map((i) => i.toString())
          )
        ]) {
          if (lookupTableAddressAccount[item] !== void 0) lookupTableAddress[item] = lookupTableAddressAccount[item];
        }
      }
      if (checkTx({
        makeTxVersion,
        innerIns: addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns,
        payer,
        lookupTableAddressAccount
      })) {
        const _i = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns;
        transactions.push({
          instructionTypes: _i.map((i) => i.instructionTypes).flat(),
          instructions: _i.map((i) => i.instructions).flat(),
          signers: itemIns.map((i) => i.signers).flat(),
          lookupTableAddress
        });
      } else {
        transactions.push({
          instructionTypes: itemIns.map((i) => i.instructionTypes).flat(),
          instructions: itemIns.map((i) => i.instructions).flat(),
          signers: itemIns.map((i) => i.signers).flat(),
          lookupTableAddress
        });
      }
    }
    return transactions;
  });
}
function checkTx({
  makeTxVersion,
  innerIns,
  payer,
  lookupTableAddressAccount
}) {
  const instructions = innerIns.map((i) => i.instructions).flat();
  const signers = [
    ...new Set(
      innerIns.map((i) => i.signers).flat().map((i) => i.publicKey.toString())
    )
  ].map((i) => new PublicKey5(i));
  const needLTA = innerIns.map((i) => {
    var _a;
    return (_a = i.lookupTableAddress) != null ? _a : [];
  }).flat().map((i) => i.toString());
  const lTaCache = {};
  const _lookupTableAddressAccount = lookupTableAddressAccount != null ? lookupTableAddressAccount : {};
  for (const item of needLTA) {
    if (_lookupTableAddressAccount[item] !== void 0) {
      lTaCache[item] = _lookupTableAddressAccount[item];
    }
  }
  return makeTxVersion === 0 /* V0 */ ? _checkV0Tx({ instructions, payer, lookupTableAddressAccount: lTaCache }) : _checkLegacyTx({ instructions, payer, signers });
}
var MAX_BASE64_SIZE = 1644;
function _checkLegacyTx({
  instructions,
  payer,
  signers
}) {
  return forecastTransactionSize(instructions, [payer, ...signers]);
}
function _checkV0Tx({
  instructions,
  payer,
  lookupTableAddressAccount
}) {
  const transactionMessage = new TransactionMessage({
    payerKey: payer,
    recentBlockhash: Keypair.generate().publicKey.toString(),
    instructions
  });
  const messageV0 = transactionMessage.compileToV0Message(Object.values(lookupTableAddressAccount != null ? lookupTableAddressAccount : {}));
  try {
    return Buffer.from(messageV0.serialize()).toString("base64").length < MAX_BASE64_SIZE;
  } catch (error) {
    return false;
  }
}
function getMultipleLookupTableInfo(_0) {
  return __async(this, arguments, function* ({
    connection,
    address
  }) {
    const dataInfos = yield getMultipleAccountsInfo(
      connection,
      [...new Set(address.map((i) => i.toString()))].map((i) => new PublicKey5(i))
    );
    const outDict = {};
    for (let i = 0; i < address.length; i++) {
      const info = dataInfos[i];
      const key = address[i];
      if (!info) continue;
      outDict[key.toString()] = new AddressLookupTableAccount({
        key,
        state: AddressLookupTableAccount.deserialize(info.data)
      });
    }
    return outDict;
  });
}

// src/entity/bignumber.ts
import BN4 from "bn.js";

// src/entity/constant.ts
import BN3 from "bn.js";
var Rounding = /* @__PURE__ */ ((Rounding3) => {
  Rounding3[Rounding3["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding3[Rounding3["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding3[Rounding3["ROUND_UP"] = 2] = "ROUND_UP";
  return Rounding3;
})(Rounding || {});
var ZERO = new BN3(0);
var ONE = new BN3(1);
var TWO = new BN3(2);
var THREE = new BN3(3);
var FIVE = new BN3(5);
var TEN = new BN3(10);
var _100 = new BN3(100);
var _1000 = new BN3(1e3);
var _10000 = new BN3(1e4);

// src/entity/bignumber.ts
var logger3 = Logger.from("entity/bignumber");
var MAX_SAFE = 9007199254740991;
function parseBigNumberish(value) {
  if (value instanceof BN4) {
    return value;
  }
  if (typeof value === "string") {
    if (value.match(/^-?[0-9]+$/)) {
      return new BN4(value);
    }
    return logger3.throwArgumentError("invalid BigNumberish string", "value", value);
  }
  if (typeof value === "number") {
    if (value % 1) {
      return logger3.throwArgumentError("BigNumberish number underflow", "value", value);
    }
    if (value >= MAX_SAFE || value <= -MAX_SAFE) {
      return logger3.throwArgumentError("BigNumberish number overflow", "value", value);
    }
    return new BN4(String(value));
  }
  if (typeof value === "bigint") {
    return new BN4(value.toString());
  }
  return logger3.throwArgumentError("invalid BigNumberish value", "value", value);
}
function tenExponentiate(shift) {
  return TEN.pow(parseBigNumberish(shift));
}
function divCeil(a, b) {
  const dm = a.divmod(b);
  if (dm.mod.isZero()) return dm.div;
  return dm.div.isNeg() ? dm.div.isubn(1) : dm.div.iaddn(1);
}

// src/token/sol.ts
var SOL = {
  symbol: "SOL",
  name: "Solana",
  decimals: 9
};
var WSOL = {
  symbol: "WSOL",
  name: "Wrapped SOL",
  mint: "So11111111111111111111111111111111111111112",
  decimals: 9,
  extensions: {
    coingeckoId: "solana"
  }
};

// src/token/devnet.ts
var DEVNET_SPL_TOKENS = {
  WSOL: __spreadValues({}, WSOL)
};
var DEVNET_LP_TOKENS = {};

// src/token/mainnet.ts
var MAINNET_SPL_TOKENS = {
  WSOL: __spreadValues({}, WSOL),
  BTC: {
    symbol: "BTC",
    name: "Bitcoin",
    mint: "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",
    decimals: 6,
    extensions: {
      coingeckoId: "bitcoin"
    }
  },
  ETH: {
    symbol: "ETH",
    name: "Ethereum",
    mint: "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",
    decimals: 6,
    extensions: {
      coingeckoId: "ethereum"
    }
  },
  USDT: {
    symbol: "USDT",
    name: "Tether",
    mint: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
    decimals: 6,
    extensions: {
      coingeckoId: "tether"
    }
  },
  WUSDT: {
    symbol: "WUSDT",
    name: "Wrapped USDT",
    mint: "BQcdHdAQW1hczDbBi9hiegXAR7A98Q9jx3X3iBBBDiq4",
    decimals: 6,
    extensions: {
      coingeckoId: "tether"
    }
  },
  USDC: {
    symbol: "USDC",
    name: "USD Coin",
    mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    decimals: 6,
    extensions: {
      coingeckoId: "usd-coin"
    }
  },
  WUSDC: {
    symbol: "WUSDC",
    name: "Wrapped USDC",
    mint: "BXXkv6z8ykpG1yuvUDPgh732wzVHB69RnB9YgSYh3itW",
    decimals: 6,
    extensions: {
      coingeckoId: "usd-coin"
    }
  },
  YFI: {
    symbol: "YFI",
    name: "YFI",
    mint: "3JSf5tPeuscJGtaCp5giEiDhv51gQ4v3zWg8DGgyLfAB",
    decimals: 6,
    extensions: {
      coingeckoId: "yearn-finance"
    }
  },
  LINK: {
    symbol: "LINK",
    name: "Chainlink",
    mint: "CWE8jPTUYhdCTZYWPTe1o5DFqfdjzWKc9WKz6rSjQUdG",
    decimals: 6,
    extensions: {
      coingeckoId: "chainlink"
    }
  },
  XRP: {
    symbol: "XRP",
    name: "XRP",
    mint: "Ga2AXHpfAF6mv2ekZwcsJFqu7wB4NV331qNH7fW9Nst8",
    decimals: 6,
    extensions: {
      coingeckoId: "ripple"
    }
  },
  SUSHI: {
    symbol: "SUSHI",
    name: "SUSHI",
    mint: "AR1Mtgh7zAtxuxGd2XPovXPVjcSdY3i4rQYisNadjfKy",
    decimals: 6,
    extensions: {
      coingeckoId: "sushi"
    }
  },
  ALEPH: {
    symbol: "ALEPH",
    name: "ALEPH",
    mint: "CsZ5LZkDS7h9TDKjrbL7VAwQZ9nsRu8vJLhRYfmGaN8K",
    decimals: 6,
    extensions: {
      coingeckoId: "aleph"
    }
  },
  SXP: {
    symbol: "SXP",
    name: "SXP",
    mint: "SF3oTvfWzEP3DTwGSvUXRrGTvr75pdZNnBLAH9bzMuX",
    decimals: 6,
    extensions: {
      coingeckoId: "swipe"
    }
  },
  HGET: {
    symbol: "HGET",
    name: "HGET",
    mint: "BtZQfWqDGbk9Wf2rXEiWyQBdBY1etnUUn6zEphvVS7yN",
    decimals: 6,
    extensions: {
      coingeckoId: "hedget"
    }
  },
  CREAM: {
    symbol: "CREAM",
    name: "CREAM",
    mint: "5Fu5UUgbjpUvdBveb3a1JTNirL8rXtiYeSMWvKjtUNQv",
    decimals: 6,
    extensions: {
      coingeckoId: "cream-2"
    }
  },
  UNI: {
    symbol: "UNI",
    name: "UNI",
    mint: "DEhAasscXF4kEGxFgJ3bq4PpVGp5wyUxMRvn6TzGVHaw",
    decimals: 6,
    extensions: {
      coingeckoId: "uniswap"
    }
  },
  SRM: {
    symbol: "SRM",
    name: "Serum",
    mint: "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt",
    decimals: 6,
    extensions: {
      coingeckoId: "serum"
    }
  },
  FTT: {
    symbol: "FTT",
    name: "FTX Token",
    mint: "AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",
    decimals: 6,
    extensions: {
      coingeckoId: "ftx-token"
    }
  },
  MSRM: {
    symbol: "MSRM",
    name: "MegaSerum",
    mint: "MSRMcoVyrFxnSgo5uXwone5SKcGhT1KEJMFEkMEWf9L",
    decimals: 0,
    extensions: {
      coingeckoId: "megaserum"
    }
  },
  TOMO: {
    symbol: "TOMO",
    name: "TOMO",
    mint: "GXMvfY2jpQctDqZ9RoU3oWPhufKiCcFEfchvYumtX7jd",
    decimals: 6,
    extensions: {
      coingeckoId: "tomochain"
    }
  },
  KARMA: {
    symbol: "KARMA",
    name: "KARMA",
    mint: "EcqExpGNFBve2i1cMJUTR4bPXj4ZoqmDD2rTkeCcaTFX",
    decimals: 4,
    extensions: {
      coingeckoId: "karma-dao"
    }
  },
  LUA: {
    symbol: "LUA",
    name: "LUA",
    mint: "EqWCKXfs3x47uVosDpTRgFniThL9Y8iCztJaapxbEaVX",
    decimals: 6,
    extensions: {
      coingeckoId: "lua-token"
    }
  },
  MATH: {
    symbol: "MATH",
    name: "MATH",
    mint: "GeDS162t9yGJuLEHPWXXGrb1zwkzinCgRwnT8vHYjKza",
    decimals: 6,
    extensions: {
      coingeckoId: "math"
    }
  },
  KEEP: {
    symbol: "KEEP",
    name: "KEEP",
    mint: "GUohe4DJUA5FKPWo3joiPgsB7yzer7LpDmt1Vhzy3Zht",
    decimals: 6,
    extensions: {
      coingeckoId: "keep-network"
    }
  },
  SWAG: {
    symbol: "SWAG",
    name: "SWAG",
    mint: "9F9fNTT6qwjsu4X4yWYKZpsbw5qT7o6yR2i57JF2jagy",
    decimals: 6,
    extensions: {
      coingeckoId: "swag-finance"
    }
  },
  FIDA: {
    symbol: "FIDA",
    name: "Bonfida",
    mint: "EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp",
    decimals: 6,
    extensions: {
      coingeckoId: "bonfida"
    }
  },
  KIN: {
    symbol: "KIN",
    name: "Kin",
    mint: "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6",
    decimals: 5,
    extensions: {
      coingeckoId: "kin"
    }
  },
  MAPS: {
    symbol: "MAPS",
    name: "MAPS",
    mint: "MAPS41MDahZ9QdKXhVa4dWB9RuyfV4XqhyAZ8XcYepb",
    decimals: 6,
    extensions: {
      coingeckoId: "maps"
    }
  },
  OXY: {
    symbol: "OXY",
    name: "Oxygen",
    mint: "z3dn17yLaGMKffVogeFHQ9zWVcXgqgf3PQnDsNs2g6M",
    decimals: 6,
    extensions: {
      coingeckoId: "oxygen"
    }
  },
  RAY: {
    symbol: "RAY",
    name: "Raydium",
    mint: "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R",
    decimals: 6,
    extensions: {
      coingeckoId: "raydium"
    }
  },
  xCOPE: {
    symbol: "xCOPE",
    name: "xCOPE",
    mint: "3K6rftdAaQYMPunrtNRHgnK2UAtjm2JwyT2oCiTDouYE",
    decimals: 0,
    extensions: {
      coingeckoId: "cope"
    }
  },
  COPE: {
    symbol: "COPE",
    name: "Cope",
    mint: "8HGyAAB1yoM1ttS7pXjHMa3dukTFGQggnFFH3hJZgzQh",
    decimals: 6,
    extensions: {
      coingeckoId: "cope"
    }
  },
  STEP: {
    symbol: "STEP",
    name: "Step Finance",
    mint: "StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT",
    decimals: 9,
    extensions: {
      coingeckoId: "step-finance"
    }
  },
  MEDIA: {
    symbol: "MEDIA",
    name: "Media Network",
    mint: "ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs",
    decimals: 6,
    extensions: {
      coingeckoId: "media-network"
    }
  },
  ROPE: {
    symbol: "ROPE",
    name: "Rope Token",
    mint: "8PMHT4swUMtBzgHnh5U564N5sjPSiUz2cjEQzFnnP1Fo",
    decimals: 9,
    extensions: {
      coingeckoId: "rope-token"
    }
  },
  MER: {
    symbol: "MER",
    name: "Mercurial",
    mint: "MERt85fc5boKw3BW1eYdxonEuJNvXbiMbs6hvheau5K",
    decimals: 6,
    extensions: {
      coingeckoId: "mercurial"
    }
  },
  TULIP: {
    symbol: "TULIP",
    name: "Tulip Protocol",
    mint: "TuLipcqtGVXP9XR62wM8WWCm6a9vhLs7T1uoWBk6FDs",
    decimals: 6,
    extensions: {
      coingeckoId: "solfarm"
    }
  },
  SNY: {
    symbol: "SNY",
    name: "SNY",
    mint: "4dmKkXNHdgYsXqBHCuMikNQWwVomZURhYvkkX5c4pQ7y",
    decimals: 6,
    extensions: {
      coingeckoId: "synthetify-token"
    }
  },
  SLRS: {
    symbol: "SLRS",
    name: "SLRS",
    mint: "SLRSSpSLUTP7okbCUBYStWCo1vUgyt775faPqz8HUMr",
    decimals: 6,
    extensions: {
      coingeckoId: "solrise-finance"
    }
  },
  WOO: {
    symbol: "WOO",
    name: "WOO Network",
    mint: "E5rk3nmgLUuKUiS94gg4bpWwWwyjCMtddsAXkTFLtHEy",
    decimals: 6,
    extensions: {
      coingeckoId: "woo-network"
    }
  },
  BOP: {
    symbol: "BOP",
    name: "Boring Protocol",
    mint: "BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3",
    decimals: 8,
    extensions: {
      coingeckoId: "boring-protocol"
    }
  },
  SAMO: {
    symbol: "SAMO",
    name: "Samoyedcoin",
    mint: "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
    decimals: 9,
    extensions: {
      coingeckoId: "samoyedcoin"
    }
  },
  renBTC: {
    symbol: "renBTC",
    name: "renBTC",
    mint: "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
    decimals: 8,
    extensions: {
      coingeckoId: "renbtc"
    }
  },
  renDOGE: {
    symbol: "renDOGE",
    name: "renDOGE",
    mint: "ArUkYE2XDKzqy77PRRGjo4wREWwqk6RXTfM9NeqzPvjU",
    decimals: 8,
    extensions: {
      coingeckoId: "rendoge"
    }
  },
  LIKE: {
    symbol: "LIKE",
    name: "Only1",
    mint: "3bRTivrVsitbmCTGtqwp7hxXPsybkjn4XLNtPsHqa3zR",
    decimals: 9,
    extensions: {
      coingeckoId: "only1"
    }
  },
  DXL: {
    symbol: "DXL",
    name: "Dexlab",
    mint: "GsNzxJfFn6zQdJGeYsupJWzUAm57Ba7335mfhWvFiE9Z",
    decimals: 6,
    extensions: {
      coingeckoId: "dexlab"
    }
  },
  mSOL: {
    symbol: "mSOL",
    name: "Marinade staked SOL",
    mint: "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
    decimals: 9,
    extensions: {
      coingeckoId: "msol"
    }
  },
  PAI: {
    symbol: "PAI",
    name: "Parrot USD",
    mint: "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
    decimals: 6,
    extensions: {
      coingeckoId: "parrot-usd"
    }
  },
  PORT: {
    symbol: "PORT",
    name: "Port Finance",
    mint: "PoRTjZMPXb9T7dyU7tpLEZRQj7e6ssfAE62j2oQuc6y",
    decimals: 6,
    extensions: {
      coingeckoId: "port-finance"
    }
  },
  MNGO: {
    symbol: "MNGO",
    name: "Mango",
    mint: "MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac",
    decimals: 6,
    extensions: {
      coingeckoId: "mango-markets"
    }
  },
  CRP: {
    symbol: "CRP",
    name: "CropperFinance",
    mint: "DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz",
    decimals: 9,
    extensions: {
      coingeckoId: "cropperfinance"
    }
  },
  ATLAS: {
    symbol: "ATLAS",
    name: "Star Atlas",
    mint: "ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx",
    decimals: 8,
    extensions: {
      coingeckoId: "star-atlas"
    }
  },
  POLIS: {
    symbol: "POLIS",
    name: "Star Atlas DAO",
    mint: "poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk",
    decimals: 8,
    extensions: {
      coingeckoId: "star-atlas-dao"
    }
  },
  GRAPE: {
    symbol: "GRAPE",
    name: "Grape Protocol",
    mint: "8upjSpvjcdpuzhfR1zriwg5NXkwDruejqNE9WNbPRtyA",
    decimals: 6,
    extensions: {
      coingeckoId: "grape-2"
    }
  },
  GENE: {
    symbol: "GENE",
    name: "Genopets",
    mint: "GENEtH5amGSi8kHAtQoezp1XEXwZJ8vcuePYnXdKrMYz",
    decimals: 9,
    extensions: {
      coingeckoId: "genopets"
    }
  },
  DFL: {
    symbol: "DFL",
    name: "DeFi Land",
    mint: "DFL1zNkaGPWm1BqAVqRjCZvHmwTFrEaJtbzJWgseoNJh",
    decimals: 9,
    extensions: {
      coingeckoId: "defi-land"
    }
  },
  CHEEMS: {
    symbol: "CHEEMS",
    name: "Cheems",
    mint: "3FoUAsGDbvTD6YZ4wVKJgTB76onJUKz7GPEBNiR5b8wc",
    decimals: 4,
    extensions: {
      coingeckoId: "cheems"
    }
  },
  stSOL: {
    symbol: "stSOL",
    name: "Lido Staked SOL",
    mint: "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj",
    decimals: 9,
    extensions: {
      coingeckoId: "lido-staked-sol"
    }
  },
  LARIX: {
    symbol: "LARIX",
    name: "Larix",
    mint: "Lrxqnh6ZHKbGy3dcrCED43nsoLkM1LTzU2jRfWe8qUC",
    decimals: 6,
    extensions: {
      coingeckoId: "larix"
    }
  },
  RIN: {
    symbol: "RIN",
    name: "Aldrin",
    mint: "E5ndSkaB17Dm7CsD22dvcjfrYSDLCxFcMd6z8ddCk5wp",
    decimals: 9,
    extensions: {
      coingeckoId: "aldrin"
    }
  },
  APEX: {
    symbol: "APEX",
    name: "ApeXit Finance",
    mint: "51tMb3zBKDiQhNwGqpgwbavaGH54mk8fXFzxTc1xnasg",
    decimals: 9,
    extensions: {
      coingeckoId: "apexit-finance"
    }
  },
  MNDE: {
    symbol: "MNDE",
    name: "Marinade",
    mint: "MNDEFzGvMt87ueuHvVU9VcTqsAP5b3fTGPsHuuPA5ey",
    decimals: 9,
    extensions: {
      coingeckoId: "marinade"
    }
  },
  LIQ: {
    symbol: "LIQ",
    name: "LIQ Protocol",
    mint: "4wjPQJ6PrkC4dHhYghwJzGBVP78DkBzA2U3kHoFNBuhj",
    decimals: 6,
    extensions: {
      coingeckoId: "liq-protocol"
    }
  },
  WAG: {
    symbol: "WAG",
    name: "Waggle Network",
    mint: "5tN42n9vMi6ubp67Uy4NnmM5DMZYN8aS8GeB3bEDHr6E",
    decimals: 9,
    extensions: {
      coingeckoId: "waggle-network"
    }
  },
  wLDO: {
    symbol: "wLDO",
    name: "wLDO",
    mint: "HZRCwxP2Vq9PCpPXooayhJ2bxTpo5xfpQrwB1svh332p",
    decimals: 8,
    extensions: {}
  },
  SLIM: {
    symbol: "SLIM",
    name: "Solanium",
    mint: "xxxxa1sKNGwFtw2kFn8XauW9xq8hBZ5kVtcSesTT9fW",
    decimals: 6,
    extensions: {
      coingeckoId: "solanium"
    }
  },
  PRT: {
    symbol: "PRT",
    name: "Parrot Protocol",
    mint: "PRT88RkA4Kg5z7pKnezeNH4mafTvtQdfFgpQTGRjz44",
    decimals: 6,
    extensions: {
      coingeckoId: "parrot-protocol"
    }
  },
  SBR: {
    symbol: "SBR",
    name: "SBR",
    mint: "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
    decimals: 6,
    extensions: {}
  },
  FAB: {
    symbol: "FAB",
    name: "Fabric",
    mint: "EdAhkbj5nF9sRM7XN7ewuW8C9XEUMs8P7cnoQ57SYE96",
    decimals: 9,
    extensions: {
      coingeckoId: "fabric"
    }
  },
  ABR: {
    symbol: "ABR",
    name: "Allbridge",
    mint: "a11bdAAuV8iB2fu7X6AxAvDTo1QZ8FXB3kk5eecdasp",
    decimals: 9,
    extensions: {
      coingeckoId: "allbridge"
    }
  },
  IVN: {
    symbol: "IVN",
    name: "Investin",
    mint: "iVNcrNE9BRZBC9Aqf753iZiZfbszeAVUoikgT9yvr2a",
    decimals: 6,
    extensions: {
      coingeckoId: "investin"
    }
  },
  CYS: {
    symbol: "CYS",
    name: "Cyclos",
    mint: "BRLsMczKuaR5w9vSubF4j8HwEGGprVAyyVgS4EX7DKEg",
    decimals: 6,
    extensions: {
      coingeckoId: "cyclos"
    }
  },
  FRKT: {
    symbol: "FRKT",
    name: "FRAKT Token",
    mint: "ErGB9xa24Szxbk1M28u2Tx8rKPqzL6BroNkkzk5rG4zj",
    decimals: 8,
    extensions: {
      coingeckoId: "frakt-token"
    }
  },
  AURY: {
    symbol: "AURY",
    name: "Aurory",
    mint: "AURYydfxJib1ZkTir1Jn1J9ECYUtjb6rKQVmtYaixWPP",
    decimals: 9,
    extensions: {
      coingeckoId: "aurory"
    }
  },
  SYP: {
    symbol: "SYP",
    name: "Sypool",
    mint: "FnKE9n6aGjQoNWRBZXy4RW6LZVao7qwBonUbiD7edUmZ",
    decimals: 9,
    extensions: {
      coingeckoId: "sypool"
    }
  },
  WOOF: {
    symbol: "WOOF",
    name: "WOOF",
    mint: "9nEqaUcb16sQ3Tn1psbkWqyhPdLmfHWjKGymREjsAgTE",
    decimals: 6,
    extensions: {
      coingeckoId: "woof-token"
    }
  },
  ORCA: {
    symbol: "ORCA",
    name: "Orca",
    mint: "orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE",
    decimals: 6,
    extensions: {
      coingeckoId: "orca"
    }
  },
  SLND: {
    symbol: "SLND",
    name: "Solend",
    mint: "SLNDpmoWTVADgEdndyvWzroNL7zSi1dF9PC3xHGtPwp",
    decimals: 6,
    extensions: {
      coingeckoId: "solend"
    }
  },
  weWETH: {
    symbol: "weWETH",
    name: "weWETH",
    mint: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
    decimals: 8,
    extensions: {}
  },
  weUNI: {
    symbol: "weUNI",
    name: "weUNI",
    mint: "8FU95xFJhUUkyyCLU13HSzDLs7oC4QZdXQHL6SCeab36",
    decimals: 8,
    extensions: {}
  },
  weSUSHI: {
    symbol: "weSUSHI",
    name: "weSUSHI",
    mint: "ChVzxWRmrTeSgwd3Ui3UumcN8KX7VK3WaD4KGeSKpypj",
    decimals: 8,
    extensions: {}
  },
  GOFX: {
    symbol: "GOFX",
    name: "GooseFX",
    mint: "GFX1ZjR2P15tmrSwow6FjyDYcEkoFb4p4gJCpLBjaxHD",
    decimals: 9,
    extensions: {
      coingeckoId: "goosefx"
    }
  },
  IN: {
    symbol: "IN",
    name: "Invictus",
    mint: "inL8PMVd6iiW3RCBJnr5AsrRN6nqr4BTrcNuQWQSkvY",
    decimals: 9,
    extensions: {
      coingeckoId: "invictus"
    }
  },
  weDYDX: {
    symbol: "weDYDX",
    name: "weDYDX",
    mint: "4Hx6Bj56eGyw8EJrrheM6LBQAvVYRikYCWsALeTrwyRU",
    decimals: 8,
    extensions: {}
  },
  STARS: {
    symbol: "STARS",
    name: "StarLaunch",
    mint: "HCgybxq5Upy8Mccihrp7EsmwwFqYZtrHrsmsKwtGXLgW",
    decimals: 6,
    extensions: {
      coingeckoId: "starlaunch"
    }
  },
  weAXS: {
    symbol: "weAXS",
    name: "weAXS",
    mint: "HysWcbHiYY9888pHbaqhwLYZQeZrcQMXKQWRqS7zcPK5",
    decimals: 8,
    extensions: {}
  },
  weSHIB: {
    symbol: "weSHIB",
    name: "weSHIB",
    mint: "CiKu4eHsVrc1eueVQeHn7qhXTcVu95gSQmBpX4utjL9z",
    decimals: 8,
    extensions: {}
  },
  OXS: {
    symbol: "OXS",
    name: "Oxbull Solana",
    mint: "4TGxgCSJQx2GQk9oHZ8dC5m3JNXTYZHjXumKAW3vLnNx",
    decimals: 9,
    extensions: {
      coingeckoId: "oxbull-solana"
    }
  },
  CWAR: {
    symbol: "CWAR",
    name: "Cryowar",
    mint: "HfYFjMKNZygfMC8LsQ8LtpPsPxEJoXJx4M6tqi75Hajo",
    decimals: 9,
    extensions: {
      coingeckoId: "cryowar-token"
    }
  },
  UPS: {
    symbol: "UPS",
    name: "UPFI Network",
    mint: "EwJN2GqUGXXzYmoAciwuABtorHczTA5LqbukKXV1viH7",
    decimals: 6,
    extensions: {
      coingeckoId: "upfi-network"
    }
  },
  weSAND: {
    symbol: "weSAND",
    name: "weSAND",
    mint: "49c7WuCZkQgc3M4qH8WuEUNXfgwupZf1xqWkDQ7gjRGt",
    decimals: 8,
    extensions: {}
  },
  weMANA: {
    symbol: "weMANA",
    name: "weMANA",
    mint: "7dgHoN8wBZCc5wbnQ2C47TDnBMAxG4Q5L3KjP67z8kNi",
    decimals: 8,
    extensions: {}
  },
  CAVE: {
    symbol: "CAVE",
    name: "Crypto Cavemen",
    mint: "4SZjjNABoqhbd4hnapbvoEPEqT8mnNkfbEoAwALf1V8t",
    decimals: 6,
    extensions: {
      coingeckoId: "cave"
    }
  },
  JSOL: {
    symbol: "JSOL",
    name: "JPool",
    mint: "7Q2afV64in6N6SeZsAAB81TJzwDoD6zpqmHkzi9Dcavn",
    decimals: 9,
    extensions: {
      coingeckoId: "jpool"
    }
  },
  APT: {
    symbol: "APT",
    name: "Apricot",
    mint: "APTtJyaRX5yGTsJU522N4VYWg3vCvSb65eam5GrPT5Rt",
    decimals: 6,
    extensions: {
      coingeckoId: "apricot"
    }
  },
  SONAR: {
    symbol: "SONAR",
    name: "SonarWatch",
    mint: "sonarX4VtVkQemriJeLm6CKeW3GDMyiBnnAEMw1MRAE",
    decimals: 9,
    extensions: {
      coingeckoId: "sonarwatch"
    }
  },
  SHILL: {
    symbol: "SHILL",
    name: "SHILL Token",
    mint: "6cVgJUqo4nmvQpbgrDZwyfd6RwWw5bfnCamS3M9N1fd",
    decimals: 6,
    extensions: {
      coingeckoId: "shill-token"
    }
  },
  TTT: {
    symbol: "TTT",
    name: "TabTrader",
    mint: "FNFKRV3V8DtA3gVJN6UshMiLGYA8izxFwkNWmJbFjmRj",
    decimals: 6,
    extensions: {
      coingeckoId: "tabtrader"
    }
  },
  BOKU: {
    symbol: "BOKU",
    name: "Boryoku Dragonz",
    mint: "CN7qFa5iYkHz99PTctvT4xXUHnxwjQ5MHxCuTJtPN5uS",
    decimals: 9,
    extensions: {
      coingeckoId: "boku"
    }
  },
  MIMO: {
    symbol: "MIMO",
    name: "Million Monke",
    mint: "9TE7ebz1dsFo1uQ2T4oYAKSm39Y6fWuHrd6Uk6XaiD16",
    decimals: 9,
    extensions: {
      coingeckoId: "million-monke"
    }
  },
  wbWBNB: {
    symbol: "wbWBNB",
    name: "wbWBNB",
    mint: "9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa",
    decimals: 8,
    extensions: {}
  },
  wePEOPLE: {
    symbol: "wePEOPLE",
    name: "wePEOPLE",
    mint: "CobcsUrt3p91FwvULYKorQejgsm5HoQdv5T8RUZ6PnLA",
    decimals: 8,
    extensions: {}
  },
  XTAG: {
    symbol: "XTAG",
    name: "xHashtag",
    mint: "5gs8nf4wojB5EXgDUWNLwXpknzgV2YWDhveAeBZpVLbp",
    decimals: 6,
    extensions: {
      coingeckoId: "xhashtag"
    }
  },
  KKO: {
    symbol: "KKO",
    name: "Kineko",
    mint: "kiNeKo77w1WBEzFFCXrTDRWGRWGP8yHvKC9rX6dqjQh",
    decimals: 9,
    extensions: {
      coingeckoId: "kineko"
    }
  },
  VI: {
    symbol: "VI",
    name: "Vybit",
    mint: "7zBWymxbZt7PVHQzfi3i85frc1YRiQc23K7bh3gos8ZC",
    decimals: 9,
    extensions: {
      coingeckoId: "vybit"
    }
  },
  SOLC: {
    symbol: "SOLC",
    name: "Solcubator",
    mint: "Bx1fDtvTN6NvE4kjdPHQXtmGSg582bZx9fGy4DQNMmAT",
    decimals: 9,
    extensions: {
      coingeckoId: "solcubator"
    }
  },
  STR: {
    symbol: "STR",
    name: "Solster",
    mint: "9zoqdwEBKWEi9G5Ze8BSkdmppxGgVv1Kw4LuigDiNr9m",
    decimals: 9,
    extensions: {
      coingeckoId: "solster"
    }
  },
  SPWN: {
    symbol: "SPWN",
    name: "Bitspawn",
    mint: "5U9QqCPhqXAJcEv9uyzFJd5zhN93vuPk1aNNkXnUfPnt",
    decimals: 9,
    extensions: {
      coingeckoId: "bitspawn"
    }
  },
  ISOLA: {
    symbol: "ISOLA",
    name: "Intersola",
    mint: "333iHoRM2Awhf9uVZtSyTfU8AekdGrgQePZsKMFPgKmS",
    decimals: 6,
    extensions: {
      coingeckoId: "intersola"
    }
  },
  RUN: {
    symbol: "RUN",
    name: "Run",
    mint: "6F9XriABHfWhit6zmMUYAQBSy6XK5VF1cHXuW5LDpRtC",
    decimals: 9,
    extensions: {
      coingeckoId: "run"
    }
  },
  REAL: {
    symbol: "REAL",
    name: "Realy Metaverse",
    mint: "AD27ov5fVU2XzwsbvnFvb1JpCBaCB5dRXrczV9CqSVGb",
    decimals: 9,
    extensions: {
      coingeckoId: "realy-metaverse"
    }
  },
  CRWNY: {
    symbol: "CRWNY",
    name: "CRWNY",
    mint: "CRWNYkqdgvhGGae9CKfNka58j6QQkaD5bLhKXvUYqnc1",
    decimals: 6,
    extensions: {}
  },
  BLOCK: {
    symbol: "BLOCK",
    name: "Blockasset",
    mint: "NFTUkR4u7wKxy9QLaX2TGvd9oZSWoMo4jqSJqdMb7Nk",
    decimals: 6,
    extensions: {
      coingeckoId: "blockasset"
    }
  },
  SOLAR: {
    symbol: "SOLAR",
    name: "Solar",
    mint: "2wmKXX1xsxLfrvjEPrt2UHiqj8Gbzwxvffr9qmNjsw8g",
    decimals: 9,
    extensions: {
      coingeckoId: "solar"
    }
  },
  BASIS: {
    symbol: "BASIS",
    name: "basis.markets",
    mint: "Basis9oJw9j8cw53oMV7iqsgo6ihi9ALw4QR31rcjUJa",
    decimals: 6,
    extensions: {
      coingeckoId: "basis-markets"
    }
  },
  SOLX: {
    symbol: "SOLX",
    name: "Soldex",
    mint: "CH74tuRLTYcxG7qNJCsV9rghfLXJCQJbsu7i52a8F1Gn",
    decimals: 9,
    extensions: {
      coingeckoId: "soldex"
    }
  },
  CHICKS: {
    symbol: "CHICKS",
    name: "SolChicks Token",
    mint: "cxxShYRVcepDudXhe7U62QHvw8uBJoKFifmzggGKVC2",
    decimals: 9,
    extensions: {
      coingeckoId: "solchicks-token"
    }
  },
  GST: {
    symbol: "GST",
    name: "GST",
    mint: "AFbX8oGjGpmVFywbVouvhQSRmiW2aR1mohfahi4Y2AdB",
    decimals: 9,
    extensions: {
      coingeckoId: "gst"
    }
  },
  MBS: {
    symbol: "MBS",
    name: "MonkeyBall",
    mint: "Fm9rHUTF5v3hwMLbStjZXqNBBoZyGriQaFM6sTFz3K8A",
    decimals: 6,
    extensions: {
      coingeckoId: "monkeyball"
    }
  },
  PRISM: {
    symbol: "PRISM",
    name: "Prism",
    mint: "PRSMNsEPqhGVCH1TtWiJqPjJyh2cKrLostPZTNy1o5x",
    decimals: 6,
    extensions: {
      coingeckoId: "prism"
    }
  },
  MEAN: {
    symbol: "MEAN",
    name: "Meanfi",
    mint: "MEANeD3XDdUmNMsRGjASkSWdC8prLYsoRJ61pPeHctD",
    decimals: 6,
    extensions: {
      coingeckoId: "meanfi"
    }
  },
  TINY: {
    symbol: "TINY",
    name: "Tiny Colony",
    mint: "HKfs24UEDQpHS5hUyKYkHd9q7GY5UQ679q2bokeL2whu",
    decimals: 6,
    extensions: {
      coingeckoId: "tiny-colony"
    }
  },
  SHDW: {
    symbol: "SHDW",
    name: "GenesysGo Shadow",
    mint: "SHDWyBxihqiCj6YekG2GUr7wqKLeLAMK1gHZck9pL6y",
    decimals: 9,
    extensions: {
      coingeckoId: "genesysgo-shadow"
    }
  },
  SCY: {
    symbol: "SCY",
    name: "Synchrony",
    mint: "SCYfrGCw8aDiqdgcpdGjV6jp4UVVQLuphxTDLNWu36f",
    decimals: 9,
    extensions: {
      coingeckoId: "synchrony"
    }
  },
  SLC: {
    symbol: "SLC",
    name: "Solice",
    mint: "METAmTMXwdb8gYzyCPfXXFmZZw4rUsXX58PNsDg7zjL",
    decimals: 6,
    extensions: {
      coingeckoId: "solice"
    }
  }
};
var MAINNET_LP_TOKENS = {
  FIDA_RAY_V4: {
    symbol: "FIDA-RAY",
    name: "FIDA-RAY V4 LP",
    mint: "DsBuznXRTmzvEdb36Dx3aVLVo1XmH7r1PRZUFugLPTFv",
    base: MAINNET_SPL_TOKENS.FIDA,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.FIDA.decimals,
    version: 4
  },
  OXY_RAY_V4: {
    symbol: "OXY-RAY",
    name: "OXY-RAY V4 LP",
    mint: "FwaX9W7iThTZH5MFeasxdLpxTVxRcM7ZHieTCnYog8Yb",
    base: MAINNET_SPL_TOKENS.OXY,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.OXY.decimals,
    version: 4
  },
  MAPS_RAY_V4: {
    symbol: "MAPS-RAY",
    name: "MAPS-RAY V4 LP",
    mint: "CcKK8srfVdTSsFGV3VLBb2YDbzF4T4NM2C3UEjC39RLP",
    base: MAINNET_SPL_TOKENS.MAPS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MAPS.decimals,
    version: 4
  },
  KIN_RAY_V4: {
    symbol: "KIN-RAY",
    name: "KIN-RAY V4 LP",
    mint: "CHT8sft3h3gpLYbCcZ9o27mT5s3Z6VifBVbUiDvprHPW",
    base: MAINNET_SPL_TOKENS.KIN,
    quote: MAINNET_SPL_TOKENS.RAY,
    // mistake, a special one
    decimals: 6,
    version: 4
  },
  RAY_USDT_V4: {
    symbol: "RAY-USDT",
    name: "RAY-USDT V4 LP",
    mint: "C3sT1R3nsw4AVdepvLTLKr5Gvszr7jufyBWUCvy4TUvT",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  SOL_USDC_V4: {
    symbol: "SOL-USDC",
    name: "SOL-USDC V4 LP",
    mint: "8HoQnePLqPj4M7PUDzfw8e3Ymdwgc7NLGnaTUapubyvu",
    base: MAINNET_SPL_TOKENS.WSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WSOL.decimals,
    version: 4
  },
  YFI_USDC_V4: {
    symbol: "YFI-USDC",
    name: "YFI-USDC V4 LP",
    mint: "865j7iMmRRycSYUXzJ33ZcvLiX9JHvaLidasCyUyKaRE",
    base: MAINNET_SPL_TOKENS.YFI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.YFI.decimals,
    version: 4
  },
  SRM_USDC_V4: {
    symbol: "SRM-USDC",
    name: "SRM-USDC V4 LP",
    mint: "9XnZd82j34KxNLgQfz29jGbYdxsYznTWRpvZE3SRE7JG",
    base: MAINNET_SPL_TOKENS.SRM,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SRM.decimals,
    version: 4
  },
  FTT_USDC_V4: {
    symbol: "FTT-USDC",
    name: "FTT-USDC V4 LP",
    mint: "75dCoKfUHLUuZ4qEh46ovsxfgWhB4icc3SintzWRedT9",
    base: MAINNET_SPL_TOKENS.FTT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.FTT.decimals,
    version: 4
  },
  BTC_USDC_V4: {
    symbol: "BTC-USDC",
    name: "BTC-USDC V4 LP",
    mint: "2hMdRdVWZqetQsaHG8kQjdZinEMBz75vsoWTCob1ijXu",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SUSHI_USDC_V4: {
    symbol: "SUSHI-USDC",
    name: "SUSHI-USDC V4 LP",
    mint: "2QVjeR9d2PbSf8em8NE8zWd8RYHjFtucDUdDgdbDD2h2",
    base: MAINNET_SPL_TOKENS.SUSHI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
    version: 4
  },
  TOMO_USDC_V4: {
    symbol: "TOMO-USDC",
    name: "TOMO-USDC V4 LP",
    mint: "CHyUpQFeW456zcr5XEh4RZiibH8Dzocs6Wbgz9aWpXnQ",
    base: MAINNET_SPL_TOKENS.TOMO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
    version: 4
  },
  LINK_USDC_V4: {
    symbol: "LINK-USDC",
    name: "LINK-USDC V4 LP",
    mint: "BqjoYjqKrXtfBKXeaWeAT5sYCy7wsAYf3XjgDWsHSBRs",
    base: MAINNET_SPL_TOKENS.LINK,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LINK.decimals,
    version: 4
  },
  ETH_USDC_V4: {
    symbol: "ETH-USDC",
    name: "ETH-USDC V4 LP",
    mint: "13PoKid6cZop4sj2GfoBeujnGfthUbTERdE5tpLCDLEY",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  xCOPE_USDC_V4: {
    symbol: "xCOPE-USDC",
    name: "xCOPE-USDC V4 LP",
    mint: "2Vyyeuyd15Gp8aH6uKE72c4hxc8TVSLibxDP9vzspQWG",
    base: MAINNET_SPL_TOKENS.xCOPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.xCOPE.decimals,
    version: 4
  },
  SOL_USDT_V4: {
    symbol: "SOL-USDT",
    name: "SOL-USDT V4 LP",
    mint: "Epm4KfTj4DMrvqn6Bwg2Tr2N8vhQuNbuK8bESFp4k33K",
    base: MAINNET_SPL_TOKENS.WSOL,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.WSOL.decimals,
    version: 4
  },
  YFI_USDT_V4: {
    symbol: "YFI-USDT",
    name: "YFI-USDT V4 LP",
    mint: "FA1i7fej1pAbQbnY8NbyYUsTrWcasTyipKreDgy1Mgku",
    base: MAINNET_SPL_TOKENS.YFI,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.YFI.decimals,
    version: 4
  },
  SRM_USDT_V4: {
    symbol: "SRM-USDT",
    name: "SRM-USDT V4 LP",
    mint: "HYSAu42BFejBS77jZAZdNAWa3iVcbSRJSzp3wtqCbWwv",
    base: MAINNET_SPL_TOKENS.SRM,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.SRM.decimals,
    version: 4
  },
  FTT_USDT_V4: {
    symbol: "FTT-USDT",
    name: "FTT-USDT V4 LP",
    mint: "2cTCiUnect5Lap2sk19xLby7aajNDYseFhC9Pigou11z",
    base: MAINNET_SPL_TOKENS.FTT,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.FTT.decimals,
    version: 4
  },
  BTC_USDT_V4: {
    symbol: "BTC-USDT",
    name: "BTC-USDT V4 LP",
    mint: "DgGuvR9GSHimopo3Gc7gfkbKamLKrdyzWkq5yqA6LqYS",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SUSHI_USDT_V4: {
    symbol: "SUSHI-USDT",
    name: "SUSHI-USDT V4 LP",
    mint: "Ba26poEYDy6P2o95AJUsewXgZ8DM9BCsmnU9hmC9i4Ki",
    base: MAINNET_SPL_TOKENS.SUSHI,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
    version: 4
  },
  TOMO_USDT_V4: {
    symbol: "TOMO-USDT",
    name: "TOMO-USDT V4 LP",
    mint: "D3iGro1vn6PWJXo9QAPj3dfta6dKkHHnmiiym2EfsAmi",
    base: MAINNET_SPL_TOKENS.TOMO,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
    version: 4
  },
  LINK_USDT_V4: {
    symbol: "LINK-USDT",
    name: "LINK-USDT V4 LP",
    mint: "Dr12Sgt9gkY8WU5tRkgZf1TkVWJbvjYuPAhR3aDCwiiX",
    base: MAINNET_SPL_TOKENS.LINK,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.LINK.decimals,
    version: 4
  },
  ETH_USDT_V4: {
    symbol: "ETH-USDT",
    name: "ETH-USDT V4 LP",
    mint: "nPrB78ETY8661fUgohpuVusNCZnedYCgghzRJzxWnVb",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  YFI_SRM_V4: {
    symbol: "YFI-SRM",
    name: "YFI-SRM V4 LP",
    mint: "EGJht91R7dKpCj8wzALkjmNdUUUcQgodqWCYweyKcRcV",
    base: MAINNET_SPL_TOKENS.YFI,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.YFI.decimals,
    version: 4
  },
  FTT_SRM_V4: {
    symbol: "FTT-SRM",
    name: "FTT-SRM V4 LP",
    mint: "AsDuPg9MgPtt3jfoyctUCUgsvwqAN6RZPftqoeiPDefM",
    base: MAINNET_SPL_TOKENS.FTT,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.FTT.decimals,
    version: 4
  },
  BTC_SRM_V4: {
    symbol: "BTC-SRM",
    name: "BTC-SRM V4 LP",
    mint: "AGHQxXb3GSzeiLTcLtXMS2D5GGDZxsB2fZYZxSB5weqB",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SUSHI_SRM_V4: {
    symbol: "SUSHI-SRM",
    name: "SUSHI-SRM V4 LP",
    mint: "3HYhUnUdV67j1vn8fu7ExuVGy5dJozHEyWvqEstDbWwE",
    base: MAINNET_SPL_TOKENS.SUSHI,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
    version: 4
  },
  TOMO_SRM_V4: {
    symbol: "TOMO-SRM",
    name: "TOMO-SRM V4 LP",
    mint: "GgH9RnKrQpaMQeqmdbMvs5oo1A24hERQ9wuY2pSkeG7x",
    base: MAINNET_SPL_TOKENS.TOMO,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
    version: 4
  },
  LINK_SRM_V4: {
    symbol: "LINK-SRM",
    name: "LINK-SRM V4 LP",
    mint: "GXN6yJv12o18skTmJXaeFXZVY1iqR18CHsmCT8VVCmDD",
    base: MAINNET_SPL_TOKENS.LINK,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.LINK.decimals,
    version: 4
  },
  ETH_SRM_V4: {
    symbol: "ETH-SRM",
    name: "ETH-SRM V4 LP",
    mint: "9VoY3VERETuc2FoadMSYYizF26mJinY514ZpEzkHMtwG",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  SRM_SOL_V4: {
    symbol: "SRM-SOL",
    name: "SRM-SOL V4 LP",
    mint: "AKJHspCwDhABucCxNLXUSfEzb7Ny62RqFtC9uNjJi4fq",
    base: MAINNET_SPL_TOKENS.SRM,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.SRM.decimals,
    version: 4
  },
  STEP_USDC_V4: {
    symbol: "STEP-USDC",
    name: "STEP-USDC V4 LP",
    mint: "3k8BDobgihmk72jVmXYLE168bxxQUhqqyESW4dQVktqC",
    base: MAINNET_SPL_TOKENS.STEP,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.STEP.decimals,
    version: 4
  },
  MEDIA_USDC_V4: {
    symbol: "MEDIA-USDC",
    name: "MEDIA-USDC V4 LP",
    mint: "A5zanvgtioZGiJMdEyaKN4XQmJsp1p7uVxaq2696REvQ",
    base: MAINNET_SPL_TOKENS.MEDIA,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MEDIA.decimals,
    version: 4
  },
  ROPE_USDC_V4: {
    symbol: "ROPE-USDC",
    name: "ROPE-USDC V4 LP",
    mint: "Cq4HyW5xia37tKejPF2XfZeXQoPYW6KfbPvxvw5eRoUE",
    base: MAINNET_SPL_TOKENS.ROPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ROPE.decimals,
    version: 4
  },
  MER_USDC_V4: {
    symbol: "MER-USDC",
    name: "MER-USDC V4 LP",
    mint: "3H9NxvaZoxMZZDZcbBDdWMKbrfNj7PCF5sbRwDr7SdDW",
    base: MAINNET_SPL_TOKENS.MER,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MER.decimals,
    version: 4
  },
  COPE_USDC_V4: {
    symbol: "COPE-USDC",
    name: "COPE-USDC V4 LP",
    mint: "Cz1kUvHw98imKkrqqu95GQB9h1frY8RikxPojMwWKGXf",
    base: MAINNET_SPL_TOKENS.COPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.COPE.decimals,
    version: 4
  },
  ALEPH_USDC_V4: {
    symbol: "ALEPH-USDC",
    name: "ALEPH-USDC V4 LP",
    mint: "iUDasAP2nXm5wvTukAHEKSdSXn8vQkRtaiShs9ceGB7",
    base: MAINNET_SPL_TOKENS.ALEPH,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ALEPH.decimals,
    version: 4
  },
  TULIP_USDC_V4: {
    symbol: "TULIP-USDC",
    name: "TULIP-USDC V4 LP",
    mint: "2doeZGLJyACtaG9DCUyqMLtswesfje1hjNA11hMdj6YU",
    base: MAINNET_SPL_TOKENS.TULIP,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TULIP.decimals,
    version: 4
  },
  WOO_USDC_V4: {
    symbol: "WOO-USDC",
    name: "WOO-USDC V4 LP",
    mint: "7cu42ao8Jgrd5A3y3bNQsCxq5poyGZNmTydkGfJYQfzh",
    base: MAINNET_SPL_TOKENS.WOO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WOO.decimals,
    version: 4
  },
  SNY_USDC_V4: {
    symbol: "SNY-USDC",
    name: "SNY-USDC V4 LP",
    mint: "G8qcfeFqxwbCqpxv5LpLWxUCd1PyMB5nWb5e5YyxLMKg",
    base: MAINNET_SPL_TOKENS.SNY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SNY.decimals,
    version: 4
  },
  BOP_RAY_V4: {
    symbol: "BOP-RAY",
    name: "BOP-RAY V4 LP",
    mint: "9nQPYJvysyfnXhQ6nkK5V7sZG26hmDgusfdNQijRk5LD",
    base: MAINNET_SPL_TOKENS.BOP,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.BOP.decimals,
    version: 4
  },
  SLRS_USDC_V4: {
    symbol: "SLRS-USDC",
    name: "SLRS-USDC V4 LP",
    mint: "2Xxbm1hdv5wPeen5ponDSMT3VqhGMTQ7mH9stNXm9shU",
    base: MAINNET_SPL_TOKENS.SLRS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SLRS.decimals,
    version: 4
  },
  SAMO_RAY_V4: {
    symbol: "SAMO-RAY",
    name: "SAMO-RAY V4 LP",
    mint: "HwzkXyX8B45LsaHXwY8su92NoRBS5GQC32HzjQRDqPnr",
    base: MAINNET_SPL_TOKENS.SAMO,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SAMO.decimals,
    version: 4
  },
  renBTC_USDC_V4: {
    symbol: "renBTC-USDC",
    name: "renBTC-USDC V4 LP",
    mint: "CTEpsih91ZLo5gunvryLpJ3pzMjmt5jbS6AnSQrzYw7V",
    base: MAINNET_SPL_TOKENS.renBTC,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.renBTC.decimals,
    version: 4
  },
  renDOGE_USDC_V4: {
    symbol: "renDOGE-USDC",
    name: "renDOGE-USDC V4 LP",
    mint: "Hb8KnZNKvRxu7pgMRWJgoMSMcepfvNiBFFDDrdf9o3wA",
    base: MAINNET_SPL_TOKENS.renDOGE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.renDOGE.decimals,
    version: 4
  },
  RAY_USDC_V4: {
    symbol: "RAY-USDC",
    name: "RAY-USDC V4 LP",
    mint: "FbC6K13MzHvN42bXrtGaWsvZY9fxrackRSZcBGfjPc7m",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  RAY_SRM_V4: {
    symbol: "RAY-SRM",
    name: "RAY-SRM V4 LP",
    mint: "7P5Thr9Egi2rvMmEuQkLn8x8e8Qro7u2U7yLD2tU2Hbe",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  RAY_ETH_V4: {
    symbol: "RAY-ETH",
    name: "RAY-ETH V4 LP",
    mint: "mjQH33MqZv5aKAbKHi8dG3g3qXeRQqq1GFcXceZkNSr",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.ETH,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  RAY_SOL_V4: {
    symbol: "RAY-SOL",
    name: "RAY-SOL V4 LP",
    mint: "89ZKE4aoyfLBe2RuV6jM3JGNhaV18Nxh8eNtjRcndBip",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  DXL_USDC_V4: {
    symbol: "DXL-USDC",
    name: "DXL-USDC V4 LP",
    mint: "4HFaSvfgskipvrzT1exoVKsUZ174JyExEsA8bDfsAdY5",
    base: MAINNET_SPL_TOKENS.DXL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.DXL.decimals,
    version: 4
  },
  LIKE_USDC_V4: {
    symbol: "LIKE-USDC",
    name: "LIKE-USDC V4 LP",
    mint: "cjZmbt8sJgaoyWYUttomAu5LJYU44ZrcKTbzTSEPDVw",
    base: MAINNET_SPL_TOKENS.LIKE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LIKE.decimals,
    version: 4
  },
  mSOL_USDC_V4: {
    symbol: "mSOL-USDC",
    name: "mSOL-USDC V4 LP",
    mint: "4xTpJ4p76bAeggXoYywpCCNKfJspbuRzZ79R7pRhbqSf",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  mSOL_SOL_V4: {
    symbol: "mSOL-SOL",
    name: "mSOL-SOL V4 LP",
    mint: "5ijRoAHVgd5T5CNtK5KDRUBZ7Bffb69nktMj5n6ks6m4",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  MER_PAI_V4: {
    symbol: "MER-PAI",
    name: "MER-PAI V4 LP",
    mint: "DU5RT2D9EviaSmX6Ta8MZwMm85HwSEqGMRdqUiuCGfmD",
    base: MAINNET_SPL_TOKENS.MER,
    quote: MAINNET_SPL_TOKENS.PAI,
    decimals: MAINNET_SPL_TOKENS.MER.decimals,
    version: 4
  },
  PORT_USDC_V4: {
    symbol: "PORT-USDC",
    name: "PORT-USDC V4 LP",
    mint: "9tmNtbUCrLS15qC4tEfr5NNeqcqpZ4uiGgi2vS5CLQBS",
    base: MAINNET_SPL_TOKENS.PORT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.PORT.decimals,
    version: 4
  },
  MNGO_USDC_V4: {
    symbol: "MNGO-USDC",
    name: "MNGO-USDC V4 LP",
    mint: "DkiqCQ792n743xjWQVCbBUaVtkdiuvQeYndM53ReWnCC",
    base: MAINNET_SPL_TOKENS.MNGO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MNGO.decimals,
    version: 4
  },
  ATLAS_USDC_V4: {
    symbol: "ATLAS-USDC",
    name: "ATLAS-USDC V4 LP",
    mint: "9shGU9f1EsxAbiR567MYZ78WUiS6ZNCYbHe53WUULQ7n",
    base: MAINNET_SPL_TOKENS.ATLAS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ATLAS.decimals,
    version: 4
  },
  POLIS_USDC_V4: {
    symbol: "POLIS-USDC",
    name: "POLIS-USDC V4 LP",
    mint: "8MbKSBpyXs8fVneKgt71jfHrn5SWtX8n4wMLpiVfF9So",
    base: MAINNET_SPL_TOKENS.POLIS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.POLIS.decimals,
    version: 4
  },
  ATLAS_RAY_V4: {
    symbol: "ATLAS-RAY",
    name: "ATLAS-RAY V4 LP",
    mint: "418MFhkaYQtbn529wmjLLqL6uKxDz7j4eZBaV1cobkyd",
    base: MAINNET_SPL_TOKENS.ATLAS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.ATLAS.decimals,
    version: 4
  },
  POLIS_RAY_V4: {
    symbol: "POLIS-RAY",
    name: "POLIS-RAY V4 LP",
    mint: "9ysGKUH6WqzjQEUT4dxqYCUaFNVK9QFEa24pGzjFq8xg",
    base: MAINNET_SPL_TOKENS.POLIS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.POLIS.decimals,
    version: 4
  },
  ALEPH_RAY_V4: {
    symbol: "ALEPH-RAY",
    name: "ALEPH-RAY V4 LP",
    mint: "n76skjqv4LirhdLok2zJELXNLdRpYDgVJQuQFbamscy",
    base: MAINNET_SPL_TOKENS.ALEPH,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.ALEPH.decimals,
    version: 4
  },
  TULIP_RAY_V4: {
    symbol: "TULIP-RAY",
    name: "TULIP-RAY V4 LP",
    mint: "3AZTviji5qduMG2s4FfWGR3SSQmNUCyx8ao6UKCPg3oJ",
    base: MAINNET_SPL_TOKENS.TULIP,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.TULIP.decimals,
    version: 4
  },
  SLRS_RAY_V4: {
    symbol: "SLRS-RAY",
    name: "SLRS-RAY V4 LP",
    mint: "2pk78vsKT3jfJAcN2zbpMUnrR57SZrxHqaZYyFgp92mM",
    base: MAINNET_SPL_TOKENS.SLRS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SLRS.decimals,
    version: 4
  },
  MER_RAY_V4: {
    symbol: "MER-RAY",
    name: "MER-RAY V4 LP",
    mint: "214hxy3AbKoaEKgqcg2aC1cP5R67cGGAyDEg5GDwC7Ub",
    base: MAINNET_SPL_TOKENS.MER,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MER.decimals,
    version: 4
  },
  MEDIA_RAY_V4: {
    symbol: "MEDIA-RAY",
    name: "MEDIA-RAY V4 LP",
    mint: "9Aseg5A1JD1yCiFFdDaNNxCiJ7XzrpZFmcEmLjXFdPaH",
    base: MAINNET_SPL_TOKENS.MEDIA,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MEDIA.decimals,
    version: 4
  },
  SNY_RAY_V4: {
    symbol: "SNY-RAY",
    name: "SNY-RAY V4 LP",
    mint: "2k4quTuuLUxrSEhFH99qcoZzvgvVEc3b5sz3xz3qstfS",
    base: MAINNET_SPL_TOKENS.SNY,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SNY.decimals,
    version: 4
  },
  LIKE_RAY_V4: {
    symbol: "LIKE-RAY",
    name: "LIKE-RAY V4 LP",
    mint: "7xqDycbFSCpUpzkYapFeyPJWPwEpV7zdWbYf2MVHTNjv",
    base: MAINNET_SPL_TOKENS.LIKE,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.LIKE.decimals,
    version: 4
  },
  COPE_RAY_V4: {
    symbol: "COPE-RAY",
    name: "COPE-RAY V4 LP",
    mint: "A7GCVHA8NSsbdFscHdoNU41tL1TRKNmCH4K94CgcLK9F",
    base: MAINNET_SPL_TOKENS.COPE,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.COPE.decimals,
    version: 4
  },
  ETH_SOL_V4: {
    symbol: "ETH-SOL",
    name: "ETH-SOL V4 LP",
    mint: "GKfgC86iJoMjwAtcyiLu6nWnjggqUXsDQihXkP14fDez",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  stSOL_USDC_V4: {
    symbol: "stSOL-USDC",
    name: "stSOL-USDC V4 LP",
    mint: "HDUJMwYZkjUZre63xUeDhdCi8c6LgUDiBqxmP3QC3VPX",
    base: MAINNET_SPL_TOKENS.stSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.stSOL.decimals,
    version: 4
  },
  GRAPE_USDC_V4: {
    symbol: "GRAPE-USDC",
    name: "GRAPE-USDC V4 LP",
    mint: "A8ZYmnZ1vwxUa4wpJVUaJgegsuTEz5TKy5CiJXffvmpt",
    base: MAINNET_SPL_TOKENS.GRAPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.GRAPE.decimals,
    version: 4
  },
  LARIX_USDC_V4: {
    symbol: "LARIX-USDC",
    name: "LARIX-USDC V4 LP",
    mint: "7yieit4YsNsZ9CAK8H5ZEMvvk35kPEHHeXwp6naoWU9V",
    base: MAINNET_SPL_TOKENS.LARIX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LARIX.decimals,
    version: 4
  },
  RIN_USDC_V4: {
    symbol: "RIN-USDC",
    name: "RIN-USDC V4 LP",
    mint: "GfCWfrZez7BDmCSEeMERVDVUaaM2TEreyYUgb2cpuS3w",
    base: MAINNET_SPL_TOKENS.RIN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.RIN.decimals,
    version: 4
  },
  APEX_USDC_V4: {
    symbol: "APEX-USDC",
    name: "APEX-USDC V4 LP",
    mint: "444cVqYyDxJNo6FqiMb9qQWFUd7tYzFRdDuJRFrSAGnU",
    base: MAINNET_SPL_TOKENS.APEX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.APEX.decimals,
    version: 4
  },
  mSOL_RAY_V4: {
    symbol: "mSOL-RAY",
    name: "mSOL-RAY V4 LP",
    mint: "De2EHBAdkgfc72DpShqDGG42cV3iDWh8wvvZdPsiEcqP",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  MNDE_mSOL_V4: {
    symbol: "MNDE-mSOL",
    name: "MNDE-mSOL V4 LP",
    mint: "4bh8XCzTHSbqbWN8o1Jn4ueBdz1LvJFoEasN6K6CQ8Ny",
    base: MAINNET_SPL_TOKENS.MNDE,
    quote: MAINNET_SPL_TOKENS.mSOL,
    decimals: MAINNET_SPL_TOKENS.MNDE.decimals,
    version: 4
  },
  LARIX_RAY_V4: {
    symbol: "LARIX-RAY",
    name: "LARIX-RAY V4 LP",
    mint: "ZRDfSLgWGeaYSmhdPvFNKQQhDcYdZQaue2N8YDmHX4q",
    base: MAINNET_SPL_TOKENS.LARIX,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.LARIX.decimals,
    version: 4
  },
  LIQ_USDC_V4: {
    symbol: "LIQ-USDC",
    name: "LIQ-USDC V4 LP",
    mint: "GWpD3eTfhJB5KDCcnE85dBQrjAk2CsrgDF9b52R9CrjV",
    base: MAINNET_SPL_TOKENS.LIQ,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LIQ.decimals,
    version: 4
  },
  WAG_USDC_V4: {
    symbol: "WAG-USDC",
    name: "WAG-USDC V4 LP",
    mint: "4yykyPugitUVRewNPXXCviRvxGfsfsRMoP32z3b6FmUC",
    base: MAINNET_SPL_TOKENS.WAG,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WAG.decimals,
    version: 4
  },
  ETH_mSOL_V4: {
    symbol: "ETH-mSOL",
    name: "ETH-mSOL V4 LP",
    mint: "HYv3grQfi8QbV7nG7EFgNK1aJSrsJ7HynXJKJVPLL2Uh",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.mSOL,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  mSOL_USDT_V4: {
    symbol: "mSOL-USDT",
    name: "mSOL-USDT V4 LP",
    mint: "69NCmEW9mGpiWLjAcAWHq51k4ionJZmzgRfRT3wQaCCf",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  BTC_mSOL_V4: {
    symbol: "BTC-mSOL",
    name: "BTC-mSOL V4 LP",
    mint: "92bcERNtUmuaJ6mwLSxYHZYSph37jdKxRdoYNxpcYNPp",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.mSOL,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SLIM_SOL_V4: {
    symbol: "SLIM-SOL",
    name: "SLIM-SOL V4 LP",
    mint: "9X4EK8E59VAVi6ChnNvvd39m6Yg9RtkBbAPq1mDVJT57",
    base: MAINNET_SPL_TOKENS.SLIM,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.SLIM.decimals,
    version: 4
  },
  AURY_USDC_V4: {
    symbol: "AURY-USDC",
    name: "AURY-USDC V4 LP",
    mint: "Gub5dvTy4nzP82qpmpNkBxmRqjtqRddBTBqHSdNcf2oS",
    base: MAINNET_SPL_TOKENS.AURY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.AURY.decimals,
    version: 4
  },
  PRT_SOL_V4: {
    symbol: "PRT-SOL",
    name: "PRT-SOL V4 LP",
    mint: "EcJ8Wgwt1AzSPiDpVr6aaSur8TKAsNTPmmzRACeqT68Z",
    base: MAINNET_SPL_TOKENS.PRT,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.PRT.decimals,
    version: 4
  },
  LIQ_RAY_V4: {
    symbol: "LIQ-RAY",
    name: "LIQ-RAY V4 LP",
    mint: "49YUsDrThJosHSagCn1F59Uc9NRxbr9thVrZikUnQDXy",
    base: MAINNET_SPL_TOKENS.LIQ,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.LIQ.decimals,
    version: 4
  },
  SYP_SOL_V4: {
    symbol: "SYP-SOL",
    name: "SYP-SOL V4 LP",
    mint: "KHV6dfj2bDntzJ9z1S26cDfqWfUZdJRFmteLR6LxHwW",
    base: MAINNET_SPL_TOKENS.SYP,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.SYP.decimals,
    version: 4
  },
  SYP_RAY_V4: {
    symbol: "SYP-RAY",
    name: "SYP-RAY V4 LP",
    mint: "FT2KZqxxM8F2h9pZtTF4PyjK88bM4YbuBzd7ZPwQ5wMB",
    base: MAINNET_SPL_TOKENS.SYP,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SYP.decimals,
    version: 4
  },
  SYP_USDC_V4: {
    symbol: "SYP-USDC",
    name: "SYP-USDC V4 LP",
    mint: "2xJGuLAivAR1WkARRA6zP1v4jaA9jV2Qis8JfMNvrVyZ",
    base: MAINNET_SPL_TOKENS.SYP,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SYP.decimals,
    version: 4
  },
  FAB_USDC_V4: {
    symbol: "FAB-USDC",
    name: "FAB-USDC V4 LP",
    mint: "5rTCvZq6BcApsC3VV1EEUuTJfaVd8uYhcGjwTy1By6P8",
    base: MAINNET_SPL_TOKENS.FAB,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.FAB.decimals,
    version: 4
  },
  WOOF_RAY_V4: {
    symbol: "WOOF-RAY",
    name: "WOOF-RAY V4 LP",
    mint: "H2FAnazDaGFutcmnrwDxhmdncR1Bd7GG4mhPCSUiamDX",
    base: MAINNET_SPL_TOKENS.WOOF,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.WOOF.decimals,
    version: 4
  },
  WOOF_USDC_V4: {
    symbol: "WOOF-USDC",
    name: "WOOF-USDC V4 LP",
    mint: "EFSu5TMc1ijRevaYCxUkS7uGvbhsymDHEaTK3UVdNE3q",
    base: MAINNET_SPL_TOKENS.WOOF,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WOOF.decimals,
    version: 4
  },
  SLND_USDC_V4: {
    symbol: "SLND-USDC",
    name: "SLND-USDC V4 LP",
    mint: "EunE9uDh2cGsyJcsGuGKc6wte7kBn8iye2gzC4w2ePHn",
    base: MAINNET_SPL_TOKENS.SLND,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SLND.decimals,
    version: 4
  },
  FRKT_SOL_V4: {
    symbol: "FRKT-SOL",
    name: "FRKT-SOL V4 LP",
    mint: "HYUKXgpjaxMXHttyrFYtv3z2rdhZ1U9QDH8zEc8BooQC",
    base: MAINNET_SPL_TOKENS.FRKT,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.FRKT.decimals,
    version: 4
  },
  weWETH_SOL_V4: {
    symbol: "weWETH-SOL",
    name: "weWETH-SOL V4 LP",
    mint: "3hbozt2Por7bcrGod8N7kEeJNMocFFjCJrQR16TQGBrE",
    base: MAINNET_SPL_TOKENS.weWETH,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.weWETH.decimals,
    version: 4
  },
  weWETH_USDC_V4: {
    symbol: "weWETH-USDC",
    name: "weWETH-USDC V4 LP",
    mint: "3529SBnMCDW3S3xQ52aABbRHo7PcHvpQA4no8J12L5eK",
    base: MAINNET_SPL_TOKENS.weWETH,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weWETH.decimals,
    version: 4
  },
  weUNI_USDC_V4: {
    symbol: "weUNI-USDC",
    name: "weUNI-USDC V4 LP",
    mint: "EEC4QnT41py39QaYnzQnoYQEtDUDNa6Se8SBDgfPSN2a",
    base: MAINNET_SPL_TOKENS.weUNI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weUNI.decimals,
    version: 4
  },
  weSUSHI_USDC_V4: {
    symbol: "weSUSHI-USDC",
    name: "weSUSHI-USDC V4 LP",
    mint: "3wVrtQZsiDNp5yTPyfEzQHPU6iuJoMmpnWg6CTt4V8sR",
    base: MAINNET_SPL_TOKENS.weSUSHI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weSUSHI.decimals,
    version: 4
  },
  CYS_USDC_V4: {
    symbol: "CYS-USDC",
    name: "CYS-USDC V4 LP",
    mint: "GfV3QDzzdVUwCNSdfn6PjhmyJvjw18tn51RingWZYwk3",
    base: MAINNET_SPL_TOKENS.CYS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CYS.decimals,
    version: 4
  },
  SAMO_USDC_V4: {
    symbol: "SAMO-USDC",
    name: "SAMO-USDC V4 LP",
    mint: "B2PjGEP3vPf1999fUD14pYdxvSDRVBk43hxB2rgthwEY",
    base: MAINNET_SPL_TOKENS.SAMO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SAMO.decimals,
    version: 4
  },
  ABR_USDC_V4: {
    symbol: "ABR-USDC",
    name: "ABR-USDC V4 LP",
    mint: "ECHfxkf5zjjZFTX95QfFahNyzG7feyEKcfTdjsdrMSGU",
    base: MAINNET_SPL_TOKENS.ABR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ABR.decimals,
    version: 4
  },
  IN_USDC_V4: {
    symbol: "IN-USDC",
    name: "IN-USDC V4 LP",
    mint: "GbmJtVgg9fRmmmjKUYGMZeSt8wZ47cDDXasg5Y3iF4kz",
    base: MAINNET_SPL_TOKENS.IN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.IN.decimals,
    version: 4
  },
  weDYDX_USDC_V4: {
    symbol: "weDYDX-USDC",
    name: "weDYDX-USDC V4 LP",
    mint: "BjkkMZnnzmgLqzGErzDbkk15ozv48iVKQuunpeM2Hqnk",
    base: MAINNET_SPL_TOKENS.weDYDX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weDYDX.decimals,
    version: 4
  },
  STARS_USDC_V4: {
    symbol: "STARS-USDC",
    name: "STARS-USDC V4 LP",
    mint: "FJ68q7NChhETcGVdinMbM2FF1Cy79dpmUi6HC83K55Hv",
    base: MAINNET_SPL_TOKENS.STARS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.STARS.decimals,
    version: 4
  },
  weAXS_USDC_V4: {
    symbol: "weAXS-USDC",
    name: "weAXS-USDC V4 LP",
    mint: "6PSoJQ7myQ1BJtbQC6oiWR8HSecQGyoWsPYTZRJo2ci3",
    base: MAINNET_SPL_TOKENS.weAXS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weAXS.decimals,
    version: 4
  },
  weSHIB_USDC_V4: {
    symbol: "weSHIB-USDC",
    name: "weSHIB-USDC V4 LP",
    mint: "AcjX5pmTMGSgxkdxc3r82r6WMKBvS6eQXXFz5ck5KKUa",
    base: MAINNET_SPL_TOKENS.weSHIB,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weSHIB.decimals,
    version: 4
  },
  SBR_USDC_V4: {
    symbol: "SBR-USDC",
    name: "SBR-USDC V4 LP",
    mint: "9FC8xTFRbgTpuZZYAYnZLxgnQ8r7FwfSBM1SWvGwgF7s",
    base: MAINNET_SPL_TOKENS.SBR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SBR.decimals,
    version: 4
  },
  OXS_USDC_V4: {
    symbol: "OXS-USDC",
    name: "OXS-USDC V4 LP",
    mint: "et9pdjWm97rbmsJoN183GkFV5qzTGru79GE1Zhe7NTU",
    base: MAINNET_SPL_TOKENS.OXS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.OXS.decimals,
    version: 4
  },
  CWAR_USDC_V4: {
    symbol: "CWAR-USDC",
    name: "CWAR-USDC V4 LP",
    mint: "HjR23bxn2gtRDB2P1Tm3DLepAPPZgazsWJpLG9wqjnYR",
    base: MAINNET_SPL_TOKENS.CWAR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CWAR.decimals,
    version: 4
  },
  UPS_USDC_V4: {
    symbol: "UPS-USDC",
    name: "UPS-USDC V4 LP",
    mint: "9hSUZdREEsbaYaKY4FouvXr7xyAqtpdHRDoYCb6Mb28a",
    base: MAINNET_SPL_TOKENS.UPS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.UPS.decimals,
    version: 4
  },
  weSAND_USDC_V4: {
    symbol: "weSAND-USDC",
    name: "weSAND-USDC V4 LP",
    mint: "3dADrQa7utyiCsaFeVk9r7oebW1WheowhKo5soBYKBVT",
    base: MAINNET_SPL_TOKENS.weSAND,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weSAND.decimals,
    version: 4
  },
  weMANA_USDC_V4: {
    symbol: "weMANA-USDC",
    name: "weMANA-USDC V4 LP",
    mint: "HpUkVAPRJ5zNRuJ1ZwMXEhbMHL3gSuPb2QuSER9YUd3a",
    base: MAINNET_SPL_TOKENS.weMANA,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weMANA.decimals,
    version: 4
  },
  CAVE_USDC_V4: {
    symbol: "CAVE-USDC",
    name: "CAVE-USDC V4 LP",
    mint: "5Gba1k3fU7Vh7UtAiBmie9vhQNNq1JfEwgn1DPGZ7NKQ",
    base: MAINNET_SPL_TOKENS.CAVE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CAVE.decimals,
    version: 4
  },
  GENE_USDC_V4: {
    symbol: "GENE-USDC",
    name: "GENE-USDC V4 LP",
    mint: "7GKvfHEXenNiWYbJBKae89mdaMPr5gGMYwZmyC8gBNVG",
    base: MAINNET_SPL_TOKENS.GENE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.GENE.decimals,
    version: 4
  },
  GENE_RAY_V4: {
    symbol: "GENE-RAY",
    name: "GENE-RAY V4 LP",
    mint: "3HzXnc1qZ8mGqun18Ck3KA616XnZNqF1RWbgYE2nGRMA",
    base: MAINNET_SPL_TOKENS.GENE,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.GENE.decimals,
    version: 4
  },
  APT_USDC_V4: {
    symbol: "APT-USDC",
    name: "APT-USDC V4 LP",
    mint: "Hk8mDAJFq4E9kF3DtNgPFwzbo5kbeiusNFJgWmo3LoQ5",
    base: MAINNET_SPL_TOKENS.APT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.APT.decimals,
    version: 4
  },
  GOFX_USDC_V4: {
    symbol: "GOFX-USDC",
    name: "GOFX-USDC V4 LP",
    mint: "4svqAwrLPGRDCQuuieYTmtLXF75wiahjeK2rEN9tY1YL",
    base: MAINNET_SPL_TOKENS.GOFX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.GOFX.decimals,
    version: 4
  },
  SONAR_USDC_V4: {
    symbol: "SONAR-USDC",
    name: "SONAR-USDC V4 LP",
    mint: "2tAcfqJ1YYjpGLqwh76kyNt9VaNFDd4fJySfH6SmWfKt",
    base: MAINNET_SPL_TOKENS.SONAR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SONAR.decimals,
    version: 4
  },
  JSOL_SOL_V4: {
    symbol: "JSOL-SOL",
    name: "JSOL-SOL V4 LP",
    mint: "61z37rpHsU6d3Fq5sUjJ85K6tXGzkoYKDAG3kPJQNDRo",
    base: MAINNET_SPL_TOKENS.JSOL,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.JSOL.decimals,
    version: 4
  },
  JSOL_USDC_V4: {
    symbol: "JSOL-USDC",
    name: "JSOL-USDC V4 LP",
    mint: "3JZqf2VPNxj1kDZQsfzC7myM6spsGQbGuFv1gVfdYosN",
    base: MAINNET_SPL_TOKENS.JSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.JSOL.decimals,
    version: 4
  },
  SHILL_USDC_V4: {
    symbol: "SHILL-USDC",
    name: "SHILL-USDC V4 LP",
    mint: "CnUhYBtQEbSBZ76bgxAouVCTCb8rofZzwerVF5z5LREJ",
    base: MAINNET_SPL_TOKENS.SHILL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SHILL.decimals,
    version: 4
  },
  DFL_USDC_V4: {
    symbol: "DFL-USDC",
    name: "DFL-USDC V4 LP",
    mint: "Fffijd6UVJdQeLVXhenS8YcsnMUdWJqpbBeH42LFkXgS",
    base: MAINNET_SPL_TOKENS.DFL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.DFL.decimals,
    version: 4
  },
  BOKU_USDC_V4: {
    symbol: "BOKU-USDC",
    name: "BOKU-USDC V4 LP",
    mint: "8jjQn5Yagb6Nm2WGAxPW1bcGqrTWpg5adf6QukXEarcP",
    base: MAINNET_SPL_TOKENS.BOKU,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.BOKU.decimals,
    version: 4
  },
  MIMO_SOL_V4: {
    symbol: "MIMO-SOL",
    name: "MIMO-SOL V4 LP",
    mint: "HUJ1opSk8AiPfDT47r7n4hTiK2EXgrR3Msy7T8q1BywS",
    base: MAINNET_SPL_TOKENS.MIMO,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.MIMO.decimals,
    version: 4
  },
  wbWBNB_USDC_V4: {
    symbol: "wbWBNB-USDC",
    name: "wbWBNB-USDC V4 LP",
    mint: "FEsEfEJJSfiMQcshUgZ5UigfytfGRQ3z5puyF6DXDp9C",
    base: MAINNET_SPL_TOKENS.wbWBNB,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.wbWBNB.decimals,
    version: 4
  },
  wePEOPLE_USDC_V4: {
    symbol: "wePEOPLE-USDC",
    name: "wePEOPLE-USDC V4 LP",
    mint: "3e5ZCKi4etorpV4pv1fSckP5iJD67xcUkx3RtFCZhbzD",
    base: MAINNET_SPL_TOKENS.wePEOPLE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.wePEOPLE.decimals,
    version: 4
  },
  ISOLA_USDT_V4: {
    symbol: "ISOLA-USDT",
    name: "ISOLA-USDT V4 LP",
    mint: "H8s1wQsZpRK61pyLF3XwyQc6E8vNUnwRDhy3TBDCDENQ",
    base: MAINNET_SPL_TOKENS.ISOLA,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.ISOLA.decimals,
    version: 4
  },
  SPWN_USDC_V4: {
    symbol: "SPWN-USDC",
    name: "SPWN-USDC V4 LP",
    mint: "B5uyCAQcX6nAjZypLgiivbEKabSptgUb8JK9tkaSnqdW",
    base: MAINNET_SPL_TOKENS.SPWN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SPWN.decimals,
    version: 4
  },
  STR_USDC_V4: {
    symbol: "STR-USDC",
    name: "STR-USDC V4 LP",
    mint: "8uDVKmVwNmbXHDB7rNKqtpcT9VAsFHTJ5pPYxjyoBbNg",
    base: MAINNET_SPL_TOKENS.STR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.STR.decimals,
    version: 4
  },
  SOLC_USDT_V4: {
    symbol: "SOLC-USDT",
    name: "SOLC-USDT V4 LP",
    mint: "2g9JzTWycLzK4KEBBHsponAtZRee2ii63bRrJ8tefEyt",
    base: MAINNET_SPL_TOKENS.SOLC,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.SOLC.decimals,
    version: 4
  },
  VI_USDC_V4: {
    symbol: "VI-USDC",
    name: "VI-USDC V4 LP",
    mint: "3MwHyHCRfVqtH3ABFtdKXdY9dwemr9GGxQFaBkeq6NjY",
    base: MAINNET_SPL_TOKENS.VI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.VI.decimals,
    version: 4
  },
  KKO_USDC_V4: {
    symbol: "KKO-USDC",
    name: "KKO-USDC V4 LP",
    mint: "7xr1Doc1NiMWbUg99YVFqQSLfYXNzo6YvacXUsSgBMNW",
    base: MAINNET_SPL_TOKENS.KKO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.KKO.decimals,
    version: 4
  },
  XTAG_USDC_V4: {
    symbol: "XTAG-USDC",
    name: "XTAG-USDC V4 LP",
    mint: "GCEQbLg4ik5YJ4CMcbtuVqEc4sjLdSGy34rFk1CtGjdg",
    base: MAINNET_SPL_TOKENS.XTAG,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.XTAG.decimals,
    version: 4
  },
  TTT_USDC_V4: {
    symbol: "TTT-USDC",
    name: "TTT-USDC V4 LP",
    mint: "84fmrerHGohoRf4iLPDQ1KG4CjSjCRksYWGzjWfCRM8a",
    base: MAINNET_SPL_TOKENS.TTT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TTT.decimals,
    version: 4
  },
  RUN_USDC_V4: {
    symbol: "RUN-USDC",
    name: "RUN-USDC V4 LP",
    mint: "CjTLvvKSQdEujcSzeZRYgk4w1DpuXBbMppLHaxZyz11Y",
    base: MAINNET_SPL_TOKENS.RUN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.RUN.decimals,
    version: 4
  },
  CRWNY_USDC_V4: {
    symbol: "CRWNY-USDC",
    name: "CRWNY-USDC V4 LP",
    mint: "H3D9Gyi4frRLW6bS9vBthDVDJyzyRJ6XhhpP6PJGWaDC",
    base: MAINNET_SPL_TOKENS.CRWNY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CRWNY.decimals,
    version: 4
  },
  CRWNY_RAY_V4: {
    symbol: "CRWNY-RAY",
    name: "CRWNY-RAY V4 LP",
    mint: "5Cz9wGStNjiUg81q8t6sJJeckuT2C14CYSfyQbtYirSX",
    base: MAINNET_SPL_TOKENS.CRWNY,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.CRWNY.decimals,
    version: 4
  },
  BLOCK_USDC_V4: {
    symbol: "BLOCK-USDC",
    name: "BLOCK-USDC V4 LP",
    mint: "8i44Y23GkkwDYZ5iSkVEqmrXUfwNmwo9grguTDWKM8wg",
    base: MAINNET_SPL_TOKENS.BLOCK,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.BLOCK.decimals,
    version: 4
  },
  REAL_USDC_V4: {
    symbol: "REAL-USDC",
    name: "REAL-USDC V4 LP",
    mint: "EN43tp8xdkcM8RYSJ4msFHMPTJRXKhUteVYBDJLwTvr3",
    base: MAINNET_SPL_TOKENS.REAL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.REAL.decimals,
    version: 4
  },
  FRKT_USDC_V4: {
    symbol: "FRKT-USDC",
    name: "FRKT-USDC V4 LP",
    mint: "7MgzqVTGeA4wENme81QPTrPy45NJMKVL9XGwxmNT87cG",
    base: MAINNET_SPL_TOKENS.FRKT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.FRKT.decimals,
    version: 4
  },
  MBS_USDC_V4: {
    symbol: "MBS-USDC",
    name: "MBS-USDC V4 LP",
    mint: "BAgSWaPZpsQKyZJdvB5KyvmCNj6hzczzentt5FhDCVHb",
    base: MAINNET_SPL_TOKENS.MBS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MBS.decimals,
    version: 4
  },
  PRISM_USDC_V4: {
    symbol: "PRISM-USDC",
    name: "PRISM-USDC V4 LP",
    mint: "3baYkTcudvSFMe25UpZcBfdp4FA5kL2E4pfaeJ8AiYJB",
    base: MAINNET_SPL_TOKENS.PRISM,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.PRISM.decimals,
    version: 4
  },
  CHICKS_USDC_V4: {
    symbol: "CHICKS-USDC",
    name: "CHICKS-USDC V4 LP",
    mint: "CPzmcw81a6PDasSXhVLfDRKuTJXZPUqocS9VFf5zCFhs",
    base: MAINNET_SPL_TOKENS.CHICKS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CHICKS.decimals,
    version: 4
  },
  MEAN_RAY_V4: {
    symbol: "MEAN-RAY",
    name: "MEAN-RAY V4 LP",
    mint: "H9wUyrxpAErmdNVPitpHSXgwoomoh91ggJKPWtQQoCn1",
    base: MAINNET_SPL_TOKENS.MEAN,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MEAN.decimals,
    version: 4
  },
  TINY_USDC_V4: {
    symbol: "TINY-USDC",
    name: "TINY-USDC V4 LP",
    mint: "Hho6ZzRDj49L4z6zog8nQZFaxMSz6FX6wNzVpMeAMen",
    base: MAINNET_SPL_TOKENS.TINY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TINY.decimals,
    version: 4
  },
  SCY_USDC_V4: {
    symbol: "SCY-USDC",
    name: "SCY-USDC V4 LP",
    mint: "EcYk7t6Vw59HDnY2u6H1KDPkk8juMeA1NpGpHiGk1LDf",
    base: MAINNET_SPL_TOKENS.SCY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SCY.decimals,
    version: 4
  }
};

// src/token/testnet.ts
var TESTNET_SPL_TOKENS = {
  WSOL: __spreadValues({}, WSOL)
};
var TESTNET_LP_TOKENS = {};

// src/token/util.ts
var logger4 = Logger.from("token/util");
var TokenList = class {
  constructor(tokenList) {
    this.tokenList = tokenList;
    /**
     * Filter token by mint of token list.
     *
     * @param mint - Token's mint address
     */
    this.filterByMint = (mint) => {
      return this.tokenList.filter((token) => token.mint === mint);
    };
    /**
     * Filter unique token by mint of token list, must and can only have one result.
     */
    this.filterUniqueByMint = (mint, tokenType = "all") => {
      const result = this.tokenList.filter((token2) => token2.mint === mint);
      if (result.length === 0) {
        return logger4.throwArgumentError(`No token found`, "mint", mint);
      } else if (result.length > 1) {
        return logger4.throwArgumentError(`Multiple tokens found: ${result.length}`, "mint", mint);
      }
      const token = result[0];
      if (tokenType === "spl" && "version" in token) {
        return logger4.throwArgumentError("invalid SPL token mint", "mint", mint);
      } else if (tokenType === "lp" && !("version" in token)) {
        return logger4.throwArgumentError("invalid LP token mint", "mint", mint);
      }
      return token;
    };
    /**
     * Get list of token list
     */
    this.getList = () => {
      return this.tokenList;
    };
  }
};

// src/entity/currency.ts
var _Currency = class _Currency {
  /**
   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.SOL`.
   * @param decimals - decimals of the currency
   * @param symbol - symbol of the currency
   * @param name - name of the currency
   */
  constructor(decimals, symbol = "UNKNOWN", name = "UNKNOWN") {
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
  }
};
/**
 * The only instance of the base class `Currency`.
 */
_Currency.SOL = new _Currency(SOL.decimals, SOL.symbol, SOL.name);
var Currency = _Currency;
function inspectCurrency() {
  Currency.prototype.inspect = function() {
    return `<Currency: decimals=${this.decimals}, name=${this.name}, symbol=${this.symbol}>`;
  };
}
var _Token = class _Token extends Currency {
  constructor(programId, mint, decimals, symbol = "UNKNOWN", name = "UNKNOWN") {
    super(decimals, symbol, name);
    this.programId = validateAndParsePublicKey(programId);
    this.mint = validateAndParsePublicKey(mint);
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same mint address.
   * @param other - other token to compare
   */
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.mint.equals(other.mint);
  }
};
/**
 * The only instance of the base class `Token`.
 */
_Token.WSOL = new _Token(TOKEN_PROGRAM_ID, WSOL.mint, WSOL.decimals, SOL.symbol, SOL.name);
var Token = _Token;
function inspectToken() {
  Token.prototype.inspect = function() {
    return `<Token: mint=${this.mint.toBase58()}, decimals=${this.decimals}, name=${this.name}, symbol=${this.symbol}>`;
  };
}
function currencyEquals(currencyA, currencyB) {
  if (currencyA instanceof Token && currencyB instanceof Token) {
    return currencyA.equals(currencyB);
  } else if (currencyA instanceof Token || currencyB instanceof Token) {
    return false;
  } else {
    return currencyA === currencyB;
  }
}

// src/entity/fraction.ts
import _Big from "big.js";
import _Decimal from "decimal.js-light";

// src/entity/to-format.ts
import _toFarmat from "toformat";
var toFormat = _toFarmat;
var to_format_default = toFormat;

// src/entity/fraction.ts
var logger5 = Logger.from("entity/fraction");
var Big = to_format_default(_Big);
var Decimal = to_format_default(_Decimal);
var toSignificantRounding = {
  [0 /* ROUND_DOWN */]: Decimal.ROUND_DOWN,
  [1 /* ROUND_HALF_UP */]: Decimal.ROUND_HALF_UP,
  [2 /* ROUND_UP */]: Decimal.ROUND_UP
};
var toFixedRounding = {
  [0 /* ROUND_DOWN */]: Big.roundDown,
  [1 /* ROUND_HALF_UP */]: Big.roundHalfUp,
  [2 /* ROUND_UP */]: Big.roundUp
};
var Fraction = class _Fraction {
  constructor(numerator, denominator = ONE) {
    this.numerator = parseBigNumberish(numerator);
    this.denominator = parseBigNumberish(denominator);
  }
  // performs floor division
  get quotient() {
    return this.numerator.div(this.denominator);
  }
  invert() {
    return new _Fraction(this.denominator, this.numerator);
  }
  // +
  add(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    if (this.denominator.eq(otherParsed.denominator)) {
      return new _Fraction(this.numerator.add(otherParsed.numerator), this.denominator);
    }
    return new _Fraction(
      this.numerator.mul(otherParsed.denominator).add(otherParsed.numerator.mul(this.denominator)),
      this.denominator.mul(otherParsed.denominator)
    );
  }
  // -
  sub(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    if (this.denominator.eq(otherParsed.denominator)) {
      return new _Fraction(this.numerator.sub(otherParsed.numerator), this.denominator);
    }
    return new _Fraction(
      this.numerator.mul(otherParsed.denominator).sub(otherParsed.numerator.mul(this.denominator)),
      this.denominator.mul(otherParsed.denominator)
    );
  }
  // ×
  mul(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    return new _Fraction(this.numerator.mul(otherParsed.numerator), this.denominator.mul(otherParsed.denominator));
  }
  // ÷
  div(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    return new _Fraction(this.numerator.mul(otherParsed.denominator), this.denominator.mul(otherParsed.numerator));
  }
  toSignificant(significantDigits, format = { groupSeparator: "" }, rounding = 1 /* ROUND_HALF_UP */) {
    logger5.assert(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`);
    logger5.assert(significantDigits > 0, `${significantDigits} is not positive.`);
    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] });
    const quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  }
  toFixed(decimalPlaces, format = { groupSeparator: "" }, rounding = 1 /* ROUND_HALF_UP */) {
    logger5.assert(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`);
    logger5.assert(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
};

// src/entity/amount.ts
var logger6 = Logger.from("entity/amount");
var Big2 = to_format_default(_Big2);
function splitNumber(num, decimals) {
  let integral = "0";
  let fractional = "0";
  if (num.includes(".")) {
    const splited = num.split(".");
    if (splited.length === 2) {
      ;
      [integral, fractional] = splited;
      fractional = fractional.padEnd(decimals, "0");
    } else {
      return logger6.throwArgumentError("invalid number string", "num", num);
    }
  } else {
    integral = num;
  }
  return [integral, fractional.slice(0, decimals) || fractional];
}
var CurrencyAmount = class _CurrencyAmount extends Fraction {
  constructor(currency, amount, isRaw = true) {
    let parsedAmount = new BN5(0);
    const multiplier = TEN.pow(new BN5(currency.decimals));
    if (isRaw) {
      parsedAmount = parseBigNumberish(amount);
    } else {
      let integralAmount = new BN5(0);
      let fractionalAmount = new BN5(0);
      if (typeof amount === "string" || typeof amount === "number" || typeof amount === "bigint") {
        const [integral, fractional] = splitNumber(amount.toString(), currency.decimals);
        integralAmount = parseBigNumberish(integral);
        fractionalAmount = parseBigNumberish(fractional);
      }
      integralAmount = integralAmount.mul(multiplier);
      parsedAmount = integralAmount.add(fractionalAmount);
    }
    super(parsedAmount, multiplier);
    this.currency = currency;
  }
  get raw() {
    return this.numerator;
  }
  isZero() {
    return this.raw.isZero();
  }
  /**
   * a greater than b
   */
  gt(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "gt currency not equals");
    return this.raw.gt(other.raw);
  }
  /**
   * a less than b
   */
  lt(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "lt currency not equals");
    return this.raw.lt(other.raw);
  }
  add(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "add currency not equals");
    return new _CurrencyAmount(this.currency, this.raw.add(other.raw));
  }
  sub(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "sub currency not equals");
    return new _CurrencyAmount(this.currency, this.raw.sub(other.raw));
  }
  toSignificant(significantDigits = this.currency.decimals, format, rounding = 0 /* ROUND_DOWN */) {
    return super.toSignificant(significantDigits, format, rounding);
  }
  /**
   * To fixed
   *
   * @example
   * ```
   * 1 -> 1.000000000
   * 1.234 -> 1.234000000
   * 1.123456789876543 -> 1.123456789
   * ```
   */
  toFixed(decimalPlaces = this.currency.decimals, format, rounding = 0 /* ROUND_DOWN */) {
    logger6.assert(decimalPlaces <= this.currency.decimals, "decimals overflow");
    return super.toFixed(decimalPlaces, format, rounding);
  }
  /**
   * To exact
   *
   * @example
   * ```
   * 1 -> 1
   * 1.234 -> 1.234
   * 1.123456789876543 -> 1.123456789
   * ```
   */
  toExact(format = { groupSeparator: "" }) {
    Big2.DP = this.currency.decimals;
    return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
  }
};
var TokenAmount = class _TokenAmount extends CurrencyAmount {
  constructor(token, amount, isRaw = true) {
    super(token, amount, isRaw);
    this.token = token;
  }
  add(other) {
    logger6.assert(currencyEquals(this.token, other.token), "add token not equals");
    return new _TokenAmount(this.token, this.raw.add(other.raw));
  }
  subtract(other) {
    logger6.assert(currencyEquals(this.token, other.token), "sub token not equals");
    return new _TokenAmount(this.token, this.raw.sub(other.raw));
  }
};

// src/entity/percent.ts
var _100_PERCENT = new Fraction(_100);
var Percent = class extends Fraction {
  toSignificant(significantDigits = 5, format, rounding) {
    return this.mul(_100_PERCENT).toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = 2, format, rounding) {
    return this.mul(_100_PERCENT).toFixed(decimalPlaces, format, rounding);
  }
};

// src/entity/price.ts
var logger7 = Logger.from("entity/price");
var Price = class _Price extends Fraction {
  // denominator and numerator _must_ be raw, i.e. in the native representation
  constructor(baseCurrency, denominator, quoteCurrency, numerator) {
    super(numerator, denominator);
    this.baseCurrency = baseCurrency;
    this.quoteCurrency = quoteCurrency;
    this.scalar = new Fraction(tenExponentiate(baseCurrency.decimals), tenExponentiate(quoteCurrency.decimals));
  }
  get raw() {
    return new Fraction(this.numerator, this.denominator);
  }
  get adjusted() {
    return super.mul(this.scalar);
  }
  invert() {
    return new _Price(this.quoteCurrency, this.numerator, this.baseCurrency, this.denominator);
  }
  mul(other) {
    logger7.assert(currencyEquals(this.quoteCurrency, other.baseCurrency), "mul currency not equals");
    const fraction = super.mul(other);
    return new _Price(this.baseCurrency, fraction.denominator, other.quoteCurrency, fraction.numerator);
  }
  toSignificant(significantDigits = this.quoteCurrency.decimals, format, rounding) {
    return this.adjusted.toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = this.quoteCurrency.decimals, format, rounding) {
    return this.adjusted.toFixed(decimalPlaces, format, rounding);
  }
};

// src/marshmallow/index.ts
import { PublicKey as PublicKey6 } from "@solana/web3.js";
import BN6, { isBN } from "bn.js";

// src/marshmallow/buffer-layout.ts
import {
  bits as _bits,
  BitStructure as _BitStructure,
  blob as _blob,
  Blob as _Blob,
  cstr as _cstr,
  f32 as _f32,
  f32be as _f32be,
  f64 as _f64,
  f64be as _f64be,
  greedy as _greedy,
  Layout as _Layout,
  ns64 as _ns64,
  ns64be as _ns64be,
  nu64 as _nu64,
  nu64be as _nu64be,
  offset as _offset,
  s16 as _s16,
  s16be as _s16be,
  s24 as _s24,
  s24be as _s24be,
  s32 as _s32,
  s32be as _s32be,
  s40 as _s40,
  s40be as _s40be,
  s48 as _s48,
  s48be as _s48be,
  s8 as _s8,
  seq as _seq,
  struct as _struct,
  Structure as _Structure,
  u16 as _u16,
  u16be as _u16be,
  u24 as _u24,
  u24be as _u24be,
  u32 as _u32,
  u32be as _u32be,
  u40 as _u40,
  u40be as _u40be,
  u48 as _u48,
  u48be as _u48be,
  u8 as _u8,
  UInt as _UInt,
  union as _union,
  Union as _Union,
  unionLayoutDiscriminator as _unionLayoutDiscriminator,
  utf8 as _utf8
} from "@solana/buffer-layout";
var Layout = _Layout;
var Structure = _Structure;
var Union = _Union;
var BitStructure = _BitStructure;
var UInt = _UInt;
var Blob = _Blob;
var greedy = _greedy;
var u8 = _u8;
var u16 = _u16;
var u24 = _u24;
var u32 = _u32;
var u40 = _u40;
var u48 = _u48;
var nu64 = _nu64;
var u16be = _u16be;
var u24be = _u24be;
var u32be = _u32be;
var u40be = _u40be;
var u48be = _u48be;
var nu64be = _nu64be;
var s8 = _s8;
var s16 = _s16;
var s24 = _s24;
var s32 = _s32;
var s40 = _s40;
var s48 = _s48;
var ns64 = _ns64;
var s16be = _s16be;
var s24be = _s24be;
var s32be = _s32be;
var s40be = _s40be;
var s48be = _s48be;
var ns64be = _ns64be;
var f32 = _f32;
var f32be = _f32be;
var f64 = _f64;
var f64be = _f64be;
var seq = _seq;
var union = _union;
var unionLayoutDiscriminator = _unionLayoutDiscriminator;
var blob = _blob;
var cstr = _cstr;
var utf8 = _utf8;
var bits = _bits;
var offset = _offset;

// src/marshmallow/index.ts
var BNLayout = class extends Layout {
  constructor(span, signed, property) {
    super(span, property);
    this.blob = blob(span);
    this.signed = signed;
  }
  /** @override */
  decode(b, offset2 = 0) {
    const num = new BN6(this.blob.decode(b, offset2), 10, "le");
    if (this.signed) {
      return num.fromTwos(this.span * 8).clone();
    }
    return num;
  }
  /** @override */
  encode(src, b, offset2 = 0) {
    if (typeof src === "number") src = new BN6(src);
    if (this.signed) {
      src = src.toTwos(this.span * 8);
    }
    return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset2);
  }
};
var WideBits = class extends Layout {
  // TODO: unknown
  constructor(property) {
    super(8, property);
    this._lower = bits(u32(), false);
    this._upper = bits(u32(), false);
  }
  addBoolean(property) {
    if (this._lower.fields.length < 32) {
      this._lower.addBoolean(property);
    } else {
      this._upper.addBoolean(property);
    }
  }
  decode(b, offset2 = 0) {
    const lowerDecoded = this._lower.decode(b, offset2);
    const upperDecoded = this._upper.decode(b, offset2 + this._lower.span);
    return __spreadValues(__spreadValues({}, lowerDecoded), upperDecoded);
  }
  encode(src, b, offset2 = 0) {
    return this._lower.encode(src, b, offset2) + this._upper.encode(src, b, offset2 + this._lower.span);
  }
};
function u82(property) {
  return new UInt(1, property);
}
function u322(property) {
  return new UInt(4, property);
}
function u64(property) {
  return new BNLayout(8, false, property);
}
function u128(property) {
  return new BNLayout(16, false, property);
}
function i8(property) {
  return new BNLayout(1, true, property);
}
function i64(property) {
  return new BNLayout(8, true, property);
}
function i128(property) {
  return new BNLayout(16, true, property);
}
var WrappedLayout = class extends Layout {
  constructor(layout, decoder, encoder, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }
  decode(b, offset2) {
    return this.decoder(this.layout.decode(b, offset2));
  }
  encode(src, b, offset2) {
    return this.layout.encode(this.encoder(src), b, offset2);
  }
  getSpan(b, offset2) {
    return this.layout.getSpan(b, offset2);
  }
};
function publicKey(property) {
  return new WrappedLayout(
    blob(32),
    (b) => new PublicKey6(b),
    (key) => key.toBuffer(),
    property
  );
}
var OptionLayout = class extends Layout {
  constructor(layout, property) {
    super(-1, property);
    this.layout = layout;
    this.discriminator = u8();
  }
  encode(src, b, offset2 = 0) {
    if (src === null || src === void 0) {
      return this.discriminator.encode(0, b, offset2);
    }
    this.discriminator.encode(1, b, offset2);
    return this.layout.encode(src, b, offset2 + 1) + 1;
  }
  decode(b, offset2 = 0) {
    const discriminator = this.discriminator.decode(b, offset2);
    if (discriminator === 0) {
      return null;
    } else if (discriminator === 1) {
      return this.layout.decode(b, offset2 + 1);
    }
    throw new Error("Invalid option " + this.property);
  }
  getSpan(b, offset2 = 0) {
    const discriminator = this.discriminator.decode(b, offset2);
    if (discriminator === 0) {
      return 1;
    } else if (discriminator === 1) {
      return this.layout.getSpan(b, offset2 + 1) + 1;
    }
    throw new Error("Invalid option " + this.property);
  }
};
function option(layout, property) {
  return new OptionLayout(layout, property);
}
function bool2(property) {
  return new WrappedLayout(u8(), decodeBool, encodeBool, property);
}
function decodeBool(value) {
  if (value === 0) {
    return false;
  } else if (value === 1) {
    return true;
  }
  throw new Error("Invalid bool: " + value);
}
function encodeBool(value) {
  return value ? 1 : 0;
}
function vec(elementLayout, property) {
  const length = u32("length");
  const layout = struct([
    length,
    seq2(elementLayout, offset(length, -length.span), "values")
  ]);
  return new WrappedLayout(
    layout,
    ({ values }) => values,
    (values) => ({ values }),
    property
  );
}
function tagged(tag, layout, property) {
  const wrappedLayout = struct([u64("tag"), layout.replicate("data")]);
  function decodeTag({ tag: receivedTag, data }) {
    if (!receivedTag.eq(tag)) {
      throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
    }
    return data;
  }
  return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
}
function vecU8(property) {
  const length = u32("length");
  const layout = struct([length, blob(offset(length, -length.span), "data")]);
  return new WrappedLayout(
    layout,
    ({ data }) => data,
    (data) => ({ data }),
    property
  );
}
function str(property) {
  return new WrappedLayout(
    vecU8(),
    (data) => data.toString("utf-8"),
    (s) => Buffer.from(s, "utf-8"),
    property
  );
}
function rustEnum(variants, property) {
  const unionLayout = union(u8(), property);
  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
  return unionLayout;
}
function array(elementLayout, length, property) {
  const layout = struct([seq2(elementLayout, length, "values")]);
  return new WrappedLayout(
    layout,
    ({ values }) => values,
    (values) => ({ values }),
    property
  );
}
var Structure2 = class extends Structure {
  /** @override */
  decode(b, offset2) {
    return super.decode(b, offset2);
  }
};
function struct(fields, property, decodePrefixes) {
  return new Structure2(fields, property, decodePrefixes);
}
var Union2 = class extends Union {
  encodeInstruction(instruction) {
    const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));
    const b = Buffer.alloc(instructionMaxSpan);
    return b.slice(0, this.encode(instruction, b));
  }
  decodeInstruction(instruction) {
    return this.decode(instruction);
  }
};
function union2(discr, defaultLayout, property) {
  return new Union2(discr, defaultLayout, property);
}
var Zeros = class extends Blob {
  decode(b, offset2) {
    const slice = super.decode(b, offset2);
    if (!slice.every((v) => v === 0)) {
      throw new Error("nonzero padding bytes");
    }
    return slice;
  }
};
function zeros(length) {
  return new Zeros(length);
}
function seq2(elementLayout, count, property) {
  let parsedCount;
  const superCount = typeof count === "number" ? count : isBN(count) ? count.toNumber() : new Proxy(count, {
    get(target, property2) {
      if (!parsedCount) {
        const countProperty = Reflect.get(target, "count");
        parsedCount = isBN(countProperty) ? countProperty.toNumber() : countProperty;
        Reflect.set(target, "count", parsedCount);
      }
      return Reflect.get(target, property2);
    },
    set(target, property2, value) {
      if (property2 === "count") {
        parsedCount = value;
      }
      return Reflect.set(target, property2, value);
    }
  });
  return seq(elementLayout, superCount, property);
}

// src/spl/layout.ts
var SPL_MINT_LAYOUT = struct([
  u322("mintAuthorityOption"),
  publicKey("mintAuthority"),
  u64("supply"),
  u82("decimals"),
  u82("isInitialized"),
  u322("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
var SPL_ACCOUNT_LAYOUT = struct([
  publicKey("mint"),
  publicKey("owner"),
  u64("amount"),
  u322("delegateOption"),
  publicKey("delegate"),
  u82("state"),
  u322("isNativeOption"),
  u64("isNative"),
  u64("delegatedAmount"),
  u322("closeAuthorityOption"),
  publicKey("closeAuthority")
]);

// src/spl/spl.ts
import {
  createAssociatedTokenAccountInstruction,
  createCloseAccountInstruction,
  createInitializeAccountInstruction,
  createInitializeMintInstruction,
  createMintToInstruction,
  createTransferInstruction
} from "@solana/spl-token";
import { SystemProgram as SystemProgram2, TransactionInstruction as TransactionInstruction3 } from "@solana/web3.js";
import BN7 from "bn.js";

// src/base/pda.ts
import { PublicKey as PublicKey7 } from "@solana/web3.js";
function getATAAddress(owner, mint, programId) {
  return findProgramAddress(
    [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],
    new PublicKey7("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
  );
}

// src/spl/spl.ts
var Spl = class {
  static getAssociatedTokenAccount({
    mint,
    owner,
    programId
  }) {
    return getATAAddress(owner, mint, programId).publicKey;
  }
  static makeCreateAssociatedTokenAccountInstruction({
    programId,
    mint,
    associatedAccount,
    owner,
    payer,
    instructionsType
  }) {
    instructionsType.push(2 /* createATA */);
    return createAssociatedTokenAccountInstruction(payer, associatedAccount, owner, mint, programId);
  }
  // https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js
  static makeCreateWrappedNativeAccountInstructions(_0) {
    return __async(this, arguments, function* ({
      connection,
      owner,
      payer,
      amount,
      // baseRentExemption,
      commitment
    }) {
      const instructions = [];
      const instructionTypes = [];
      const balanceNeeded = yield connection.getMinimumBalanceForRentExemption(SPL_ACCOUNT_LAYOUT.span, commitment);
      const lamports = parseBigNumberish(amount).add(new BN7(balanceNeeded));
      const newAccount = generatePubKey({ fromPublicKey: payer, programId: TOKEN_PROGRAM_ID });
      instructions.push(
        SystemProgram2.createAccountWithSeed({
          fromPubkey: payer,
          basePubkey: payer,
          seed: newAccount.seed,
          newAccountPubkey: newAccount.publicKey,
          lamports: lamports.toNumber(),
          space: SPL_ACCOUNT_LAYOUT.span,
          programId: TOKEN_PROGRAM_ID
        })
      );
      instructionTypes.push(0 /* createAccount */);
      instructions.push(
        this.makeInitAccountInstruction({
          programId: TOKEN_PROGRAM_ID,
          mint: validateAndParsePublicKey(WSOL.mint),
          tokenAccount: newAccount.publicKey,
          owner,
          instructionTypes
        })
      );
      return {
        address: { newAccount: newAccount.publicKey },
        innerTransaction: {
          instructions,
          signers: [],
          lookupTableAddress: [],
          instructionTypes
        }
      };
    });
  }
  static insertCreateWrappedNativeAccount(_0) {
    return __async(this, arguments, function* ({
      connection,
      owner,
      payer,
      amount,
      instructions,
      instructionsType,
      signers,
      commitment
    }) {
      const ins = yield this.makeCreateWrappedNativeAccountInstructions({
        connection,
        owner,
        payer,
        amount,
        commitment
      });
      instructions.push(...ins.innerTransaction.instructions);
      signers.push(...ins.innerTransaction.signers);
      instructionsType.push(...ins.innerTransaction.instructionTypes);
      return ins.address.newAccount;
    });
  }
  static makeInitMintInstruction({
    programId,
    mint,
    decimals,
    mintAuthority,
    freezeAuthority = null,
    instructionTypes
  }) {
    instructionTypes.push(5 /* initMint */);
    return createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId);
  }
  static makeMintToInstruction({
    programId,
    mint,
    dest,
    authority,
    amount,
    multiSigners = [],
    instructionTypes
  }) {
    instructionTypes.push(6 /* mintTo */);
    return createMintToInstruction(mint, dest, authority, BigInt(String(amount)), multiSigners, programId);
  }
  static makeInitAccountInstruction({
    programId,
    mint,
    tokenAccount,
    owner,
    instructionTypes
  }) {
    instructionTypes.push(1 /* initAccount */);
    return createInitializeAccountInstruction(tokenAccount, mint, owner, programId);
  }
  static makeTransferInstruction({
    programId,
    source,
    destination,
    owner,
    amount,
    multiSigners = [],
    instructionsType
  }) {
    instructionsType.push(4 /* transferAmount */);
    return createTransferInstruction(source, destination, owner, BigInt(String(amount)), multiSigners, programId);
  }
  static makeCloseAccountInstruction({
    programId,
    tokenAccount,
    owner,
    payer,
    multiSigners = [],
    instructionsType
  }) {
    instructionsType.push(3 /* closeAccount */);
    return createCloseAccountInstruction(tokenAccount, payer, owner, multiSigners, programId);
  }
  static createInitAccountInstruction(programId, mint, account, owner) {
    const keys = [
      {
        pubkey: account,
        isSigner: false,
        isWritable: true
      },
      {
        pubkey: mint,
        isSigner: false,
        isWritable: false
      },
      {
        pubkey: owner,
        isSigner: false,
        isWritable: false
      },
      {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }
    ];
    const dataLayout = u82("instruction");
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode(1, data);
    return new TransactionInstruction3({
      keys,
      programId,
      data
    });
  }
};

// src/base/type.ts
var TxVersion = /* @__PURE__ */ ((TxVersion8) => {
  TxVersion8[TxVersion8["V0"] = 0] = "V0";
  TxVersion8[TxVersion8["LEGACY"] = 1] = "LEGACY";
  return TxVersion8;
})(TxVersion || {});
var InstructionType = /* @__PURE__ */ ((InstructionType2) => {
  InstructionType2[InstructionType2["createAccount"] = 0] = "createAccount";
  InstructionType2[InstructionType2["initAccount"] = 1] = "initAccount";
  InstructionType2[InstructionType2["createATA"] = 2] = "createATA";
  InstructionType2[InstructionType2["closeAccount"] = 3] = "closeAccount";
  InstructionType2[InstructionType2["transferAmount"] = 4] = "transferAmount";
  InstructionType2[InstructionType2["initMint"] = 5] = "initMint";
  InstructionType2[InstructionType2["mintTo"] = 6] = "mintTo";
  InstructionType2[InstructionType2["initMarket"] = 7] = "initMarket";
  InstructionType2[InstructionType2["util1216OwnerClaim"] = 8] = "util1216OwnerClaim";
  InstructionType2[InstructionType2["setComputeUnitPrice"] = 9] = "setComputeUnitPrice";
  InstructionType2[InstructionType2["setComputeUnitLimit"] = 10] = "setComputeUnitLimit";
  InstructionType2[InstructionType2["clmmCreatePool"] = 11] = "clmmCreatePool";
  InstructionType2[InstructionType2["clmmOpenPosition"] = 12] = "clmmOpenPosition";
  InstructionType2[InstructionType2["clmmIncreasePosition"] = 13] = "clmmIncreasePosition";
  InstructionType2[InstructionType2["clmmDecreasePosition"] = 14] = "clmmDecreasePosition";
  InstructionType2[InstructionType2["clmmClosePosition"] = 15] = "clmmClosePosition";
  InstructionType2[InstructionType2["clmmSwapBaseIn"] = 16] = "clmmSwapBaseIn";
  InstructionType2[InstructionType2["clmmSwapBaseOut"] = 17] = "clmmSwapBaseOut";
  InstructionType2[InstructionType2["clmmInitReward"] = 18] = "clmmInitReward";
  InstructionType2[InstructionType2["clmmSetReward"] = 19] = "clmmSetReward";
  InstructionType2[InstructionType2["clmmCollectReward"] = 20] = "clmmCollectReward";
  InstructionType2[InstructionType2["ammV4Swap"] = 21] = "ammV4Swap";
  InstructionType2[InstructionType2["ammV4AddLiquidity"] = 22] = "ammV4AddLiquidity";
  InstructionType2[InstructionType2["ammV4RemoveLiquidity"] = 23] = "ammV4RemoveLiquidity";
  InstructionType2[InstructionType2["ammV4SimulatePoolInfo"] = 24] = "ammV4SimulatePoolInfo";
  InstructionType2[InstructionType2["ammV4SwapBaseIn"] = 25] = "ammV4SwapBaseIn";
  InstructionType2[InstructionType2["ammV4SwapBaseOut"] = 26] = "ammV4SwapBaseOut";
  InstructionType2[InstructionType2["ammV4CreatePool"] = 27] = "ammV4CreatePool";
  InstructionType2[InstructionType2["ammV4InitPool"] = 28] = "ammV4InitPool";
  InstructionType2[InstructionType2["ammV4CreatePoolV2"] = 29] = "ammV4CreatePoolV2";
  InstructionType2[InstructionType2["ammV5AddLiquidity"] = 30] = "ammV5AddLiquidity";
  InstructionType2[InstructionType2["ammV5RemoveLiquidity"] = 31] = "ammV5RemoveLiquidity";
  InstructionType2[InstructionType2["ammV5SimulatePoolInfo"] = 32] = "ammV5SimulatePoolInfo";
  InstructionType2[InstructionType2["ammV5SwapBaseIn"] = 33] = "ammV5SwapBaseIn";
  InstructionType2[InstructionType2["ammV5SwapBaseOut"] = 34] = "ammV5SwapBaseOut";
  InstructionType2[InstructionType2["routeSwap"] = 35] = "routeSwap";
  InstructionType2[InstructionType2["routeSwap1"] = 36] = "routeSwap1";
  InstructionType2[InstructionType2["routeSwap2"] = 37] = "routeSwap2";
  InstructionType2[InstructionType2["farmV3Deposit"] = 38] = "farmV3Deposit";
  InstructionType2[InstructionType2["farmV3Withdraw"] = 39] = "farmV3Withdraw";
  InstructionType2[InstructionType2["farmV3CreateLedger"] = 40] = "farmV3CreateLedger";
  InstructionType2[InstructionType2["farmV5Deposit"] = 41] = "farmV5Deposit";
  InstructionType2[InstructionType2["farmV5Withdraw"] = 42] = "farmV5Withdraw";
  InstructionType2[InstructionType2["farmV5CreateLedger"] = 43] = "farmV5CreateLedger";
  InstructionType2[InstructionType2["farmV6Deposit"] = 44] = "farmV6Deposit";
  InstructionType2[InstructionType2["farmV6Withdraw"] = 45] = "farmV6Withdraw";
  InstructionType2[InstructionType2["farmV6Create"] = 46] = "farmV6Create";
  InstructionType2[InstructionType2["farmV6Restart"] = 47] = "farmV6Restart";
  InstructionType2[InstructionType2["farmV6CreatorAddReward"] = 48] = "farmV6CreatorAddReward";
  InstructionType2[InstructionType2["farmV6CreatorWithdraw"] = 49] = "farmV6CreatorWithdraw";
  InstructionType2[InstructionType2["test"] = 50] = "test";
  return InstructionType2;
})(InstructionType || {});

// src/base/base.ts
var Base = class {
  static _selectTokenAccount(params) {
    const { tokenAccounts, programId, mint, owner, config } = params;
    const { associatedOnly } = __spreadValues(__spreadValues({}, { associatedOnly: true }), config);
    const _tokenAccounts = tokenAccounts.filter(({ accountInfo }) => accountInfo.mint.equals(mint)).sort((a, b) => a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1);
    const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
    for (const tokenAccount of _tokenAccounts) {
      const { pubkey } = tokenAccount;
      if (associatedOnly) {
        if (ata.equals(pubkey)) return pubkey;
      } else {
        return pubkey;
      }
    }
    return null;
  }
  static _handleTokenAccount(params) {
    return __async(this, null, function* () {
      const {
        connection,
        side,
        amount,
        programId,
        mint,
        tokenAccount,
        owner,
        payer = owner,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      } = params;
      const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
      if (Token.WSOL.mint.equals(mint)) {
        const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner,
          payer,
          instructions: frontInstructions,
          instructionsType: frontInstructionsType,
          signers,
          amount
        });
        if (endInstructions) {
          endInstructions.push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID2,
              tokenAccount: newTokenAccount,
              owner,
              payer,
              instructionsType: endInstructionsType != null ? endInstructionsType : []
            })
          );
        }
        return newTokenAccount;
      } else if (!tokenAccount || side === "out" && !ata.equals(tokenAccount) && !bypassAssociatedCheck) {
        const _createATAIns = Spl.makeCreateAssociatedTokenAccountInstruction({
          programId,
          mint,
          associatedAccount: ata,
          owner,
          payer,
          instructionsType: frontInstructionsType
        });
        if (checkCreateATAOwner) {
          const ataInfo = yield connection.getAccountInfo(ata);
          if (ataInfo === null) {
            frontInstructions.push(_createATAIns);
          } else if (ataInfo.owner.equals(TOKEN_PROGRAM_ID2) && AccountLayout.decode(ataInfo.data).mint.equals(mint) && AccountLayout.decode(ataInfo.data).owner.equals(owner)) {
          } else {
            throw Error(`create ata check error -> mint: ${mint.toString()}, ata: ${ata.toString()}`);
          }
        } else {
          frontInstructions.push(_createATAIns);
        }
        return ata;
      }
      return tokenAccount;
    });
  }
  static _selectOrCreateTokenAccount(params) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const { mint, tokenAccounts, createInfo, associatedOnly, owner, checkCreateATAOwner, programId } = params;
      const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
      const accounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(mint) && (!associatedOnly || i.pubkey.equals(ata))).sort((a, b) => a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1);
      if (createInfo === void 0 || accounts.length > 0) {
        return accounts.length > 0 ? accounts[0].pubkey : void 0;
      }
      if (associatedOnly) {
        const _createATAIns = Spl.makeCreateAssociatedTokenAccountInstruction({
          programId,
          mint,
          associatedAccount: ata,
          owner,
          payer: createInfo.payer,
          instructionsType: createInfo.frontInstructionsType
        });
        if (checkCreateATAOwner) {
          const ataInfo = yield createInfo.connection.getAccountInfo(ata);
          if (ataInfo === null) {
            createInfo.frontInstructions.push(_createATAIns);
          } else if (ataInfo.owner.equals(programId) && AccountLayout.decode(ataInfo.data).mint.equals(mint) && AccountLayout.decode(ataInfo.data).owner.equals(owner)) {
          } else {
            throw Error(`create ata check error -> mint: ${mint.toString()}, ata: ${ata.toString()}`);
          }
        } else {
          createInfo.frontInstructions.push(_createATAIns);
        }
        if (mint.equals(Token.WSOL.mint) && createInfo.amount) {
          const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
            connection: createInfo.connection,
            owner,
            payer: createInfo.payer,
            instructions: createInfo.frontInstructions,
            instructionsType: createInfo.frontInstructionsType,
            signers: createInfo.signers,
            amount: (_a = createInfo.amount) != null ? _a : 0
          });
          ((_b = createInfo.endInstructions) != null ? _b : []).push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID2,
              tokenAccount: newTokenAccount,
              owner,
              payer: createInfo.payer,
              instructionsType: (_c = createInfo.endInstructionsType) != null ? _c : []
            })
          );
          if (createInfo.amount) {
            createInfo.frontInstructions.push(
              Spl.makeTransferInstruction({
                programId: TOKEN_PROGRAM_ID2,
                source: newTokenAccount,
                destination: ata,
                owner,
                amount: createInfo.amount,
                instructionsType: createInfo.frontInstructionsType
              })
            );
          }
        }
        ;
        ((_d = createInfo.endInstructions) != null ? _d : []).push(
          Spl.makeCloseAccountInstruction({
            programId,
            tokenAccount: ata,
            owner,
            payer: createInfo.payer,
            instructionsType: (_e = createInfo.endInstructionsType) != null ? _e : []
          })
        );
        return ata;
      } else {
        if (mint.equals(Token.WSOL.mint)) {
          const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
            connection: createInfo.connection,
            owner,
            payer: createInfo.payer,
            instructions: createInfo.frontInstructions,
            instructionsType: createInfo.frontInstructionsType,
            signers: createInfo.signers,
            amount: (_f = createInfo.amount) != null ? _f : 0
          });
          ((_g = createInfo.endInstructions) != null ? _g : []).push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID2,
              tokenAccount: newTokenAccount,
              owner,
              payer: createInfo.payer,
              instructionsType: (_h = createInfo.endInstructionsType) != null ? _h : []
            })
          );
          return newTokenAccount;
        } else {
          const newTokenAccount = generatePubKey({ fromPublicKey: owner, programId });
          const balanceNeeded = yield createInfo.connection.getMinimumBalanceForRentExemption(AccountLayout.span);
          const createAccountIns = SystemProgram3.createAccountWithSeed({
            fromPubkey: owner,
            basePubkey: owner,
            seed: newTokenAccount.seed,
            newAccountPubkey: newTokenAccount.publicKey,
            lamports: balanceNeeded,
            space: AccountLayout.span,
            programId
          });
          const initAccountIns = Spl.createInitAccountInstruction(programId, mint, newTokenAccount.publicKey, owner);
          createInfo.frontInstructions.push(createAccountIns, initAccountIns);
          createInfo.frontInstructionsType.push(0 /* createAccount */, 1 /* initAccount */);
          ((_i = createInfo.endInstructions) != null ? _i : []).push(
            Spl.makeCloseAccountInstruction({
              programId,
              tokenAccount: newTokenAccount.publicKey,
              owner,
              payer: createInfo.payer,
              instructionsType: (_j = createInfo.endInstructionsType) != null ? _j : []
            })
          );
          return newTokenAccount.publicKey;
        }
      }
    });
  }
};
function generatePubKey({
  fromPublicKey,
  programId = TOKEN_PROGRAM_ID2
}) {
  const seed = Keypair2.generate().publicKey.toBase58().slice(0, 32);
  const publicKey2 = createWithSeed(fromPublicKey, seed, programId);
  return { publicKey: publicKey2, seed };
}
function createWithSeed(fromPublicKey, seed, programId) {
  const buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);
  const publicKeyBytes = sha256(buffer);
  return new PublicKey9(publicKeyBytes);
}

// src/base/lookupTableCache.ts
import { AddressLookupTableAccount as AddressLookupTableAccount2, PublicKey as PublicKey10 } from "@solana/web3.js";
var LOOKUP_TABLE_CACHE = {
  "2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17": new AddressLookupTableAccount2({
    key: new PublicKey10("2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17"),
    state: AddressLookupTableAccount2.deserialize(
      Buffer.from(
        "AQAAAP//////////d49+DAAAAAAAAQZMWvw7GUNJdaccNBVnb57OKakxL2BHLYvhRwVILRsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAABt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkG3fbh7nWP3hhCXbzkbM3athr8TYO5DSf+vfko2KGL/AVKU1D4XciC1hSlVnJ4iilt3x6rq9CmBniISTL07vagBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvDQdRqCgtphMF/imcN7mY5YRx2xE1A3MQ+L4QRaYK9u4GRfZP3LsAd00a+IkCpA22UNQMKdq5BFbJuwuOLqc8zxCTDlqxBG8J0HcxtfogQHDK06ukzfaXiNDKAob1MqBHS9lJxDYCwz8gd5DtFqNSTKG5l1zxIaKpDP/sffi2is1H9aKveyXSu5StXElYRl9SD5As0DHE4N0GLnf84/siiKXVyp4Ez121kLcUui/jLLFZEz/BwZK3Ilf9B9OcsEAeDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu9N9LMnrw/JNO0hqMVB4rk/2ou4AB1loQ7FZoPwut2o4KZB+0p9xnbrQKw038qjpHar+PyDwvxBRcu5hpHw3dguezeWv+IwvgW5icu8EGkhGa9AkFPPJT7VMSFb8xowveU=",
        "base64"
      )
    )
  })
};

// src/base/util.ts
import { getTransferFeeConfig, unpackMint } from "@solana/spl-token";
import {
  PublicKey as PublicKey11,
  Transaction as Transaction3,
  TransactionMessage as TransactionMessage2,
  VersionedTransaction
} from "@solana/web3.js";
import BN8 from "bn.js";
function getWSOLAmount({ tokenAccounts }) {
  const WSOL_MINT = new PublicKey11(WSOL.mint);
  const amounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(WSOL_MINT)).map((i) => i.accountInfo.amount);
  const amount = amounts.reduce((a, b) => a.add(b), new BN8(0));
  return amount;
}
function unwarpSol(_0) {
  return __async(this, arguments, function* ({
    ownerInfo,
    tokenAccounts,
    makeTxVersion,
    connection
  }) {
    const WSOL_MINT = new PublicKey11(WSOL.mint);
    const instructionsInfo = tokenAccounts.filter((i) => i.accountInfo.mint.equals(WSOL_MINT)).map((i) => ({
      amount: i.accountInfo.amount,
      tx: Spl.makeCloseAccountInstruction({
        programId: TOKEN_PROGRAM_ID,
        tokenAccount: i.pubkey,
        owner: ownerInfo.wallet,
        payer: ownerInfo.payer,
        instructionsType: []
      })
    }));
    return {
      address: {},
      innerTransactions: yield splitTxAndSigners({
        connection,
        makeTxVersion,
        payer: ownerInfo.payer,
        innerTransaction: instructionsInfo.map((i) => ({
          instructionTypes: [3 /* closeAccount */],
          instructions: [i.tx],
          signers: []
        }))
      })
    };
  });
}
function buildSimpleTransaction(_0) {
  return __async(this, arguments, function* ({
    connection,
    makeTxVersion,
    payer,
    innerTransactions,
    recentBlockhash,
    addLookupTableInfo
  }) {
    var _a;
    if (makeTxVersion !== 0 /* V0 */ && makeTxVersion !== 1 /* LEGACY */) throw Error(" make tx version args error");
    const _recentBlockhash = recentBlockhash != null ? recentBlockhash : (yield connection.getLatestBlockhash()).blockhash;
    const txList = [];
    for (const itemIx of innerTransactions) {
      txList.push(
        _makeTransaction({
          makeTxVersion,
          instructions: itemIx.instructions,
          payer,
          recentBlockhash: _recentBlockhash,
          signers: itemIx.signers,
          lookupTableInfos: Object.values(__spreadValues(__spreadValues({}, addLookupTableInfo != null ? addLookupTableInfo : {}), (_a = itemIx.lookupTableAddress) != null ? _a : {}))
        })
      );
    }
    return txList;
  });
}
function buildTransaction(_0) {
  return __async(this, arguments, function* ({
    connection,
    makeTxVersion,
    payer,
    innerTransactions,
    recentBlockhash,
    lookupTableCache
  }) {
    var _a;
    if (makeTxVersion !== 0 /* V0 */ && makeTxVersion !== 1 /* LEGACY */) throw Error(" make tx version args error");
    const _recentBlockhash = recentBlockhash != null ? recentBlockhash : (yield connection.getLatestBlockhash()).blockhash;
    const _lookupTableCache = lookupTableCache != null ? lookupTableCache : {};
    const lta = [
      .../* @__PURE__ */ new Set([
        ...innerTransactions.map((i) => {
          var _a2;
          return (_a2 = i.lookupTableAddress) != null ? _a2 : [];
        }).flat().map((i) => i.toString())
      ])
    ];
    const needCacheLTA = [];
    for (const item of lta) {
      if (_lookupTableCache[item] === void 0) {
        needCacheLTA.push(new PublicKey11(item));
      }
    }
    const lookupTableAccountsCache = needCacheLTA.length > 0 ? yield getMultipleLookupTableInfo({ connection, address: needCacheLTA }) : {};
    for (const [key, value] of Object.entries(lookupTableAccountsCache)) {
      _lookupTableCache[key] = value;
    }
    const txList = [];
    for (const itemIx of innerTransactions) {
      const _itemLTA = {};
      if (makeTxVersion === 0 /* V0 */) {
        for (const item of (_a = itemIx.lookupTableAddress) != null ? _a : []) {
          _itemLTA[item.toString()] = _lookupTableCache[item.toString()];
        }
      }
      txList.push(
        _makeTransaction({
          makeTxVersion,
          instructions: itemIx.instructions,
          payer,
          recentBlockhash: _recentBlockhash,
          signers: itemIx.signers,
          lookupTableInfos: Object.values(_itemLTA)
        })
      );
    }
    return txList;
  });
}
function _makeTransaction({
  makeTxVersion,
  instructions,
  payer,
  recentBlockhash,
  signers,
  lookupTableInfos
}) {
  if (makeTxVersion === 1 /* LEGACY */) {
    const tx = new Transaction3();
    tx.add(...instructions);
    tx.feePayer = payer;
    tx.recentBlockhash = recentBlockhash;
    if (signers.length > 0) tx.sign(...signers);
    return tx;
  } else if (makeTxVersion === 0 /* V0 */) {
    const transactionMessage = new TransactionMessage2({
      payerKey: payer,
      recentBlockhash,
      instructions
    });
    const itemV = new VersionedTransaction(transactionMessage.compileToV0Message(lookupTableInfos));
    itemV.sign(signers);
    return itemV;
  } else {
    throw Error(" make tx version check error ");
  }
}
var POINT = 1e4;
function getTransferAmountFee(amount, feeConfig, epochInfo, addFee) {
  if (feeConfig === void 0) {
    return {
      amount,
      fee: void 0,
      expirationTime: void 0
    };
  }
  const nowFeeConfig = epochInfo.epoch < feeConfig.newerTransferFee.epoch ? feeConfig.olderTransferFee : feeConfig.newerTransferFee;
  const maxFee = new BN8(nowFeeConfig.maximumFee.toString());
  const expirationTime = epochInfo.epoch < feeConfig.newerTransferFee.epoch ? (Number(feeConfig.newerTransferFee.epoch) * epochInfo.slotsInEpoch - epochInfo.absoluteSlot) * 400 / 1e3 : void 0;
  if (addFee) {
    if (nowFeeConfig.transferFeeBasisPoints === POINT) {
      const nowMaxFee = new BN8(nowFeeConfig.maximumFee.toString());
      return {
        amount: amount.add(nowMaxFee),
        fee: nowMaxFee,
        expirationTime
      };
    } else {
      const _TAmount = BNDivCeil(amount.mul(new BN8(POINT)), new BN8(POINT - nowFeeConfig.transferFeeBasisPoints));
      const nowMaxFee = new BN8(nowFeeConfig.maximumFee.toString());
      const TAmount = _TAmount.sub(amount).gt(nowMaxFee) ? amount.add(nowMaxFee) : _TAmount;
      const _fee = BNDivCeil(TAmount.mul(new BN8(nowFeeConfig.transferFeeBasisPoints)), new BN8(POINT));
      const fee = _fee.gt(maxFee) ? maxFee : _fee;
      return {
        amount: TAmount,
        fee,
        expirationTime
      };
    }
  } else {
    const _fee = BNDivCeil(amount.mul(new BN8(nowFeeConfig.transferFeeBasisPoints)), new BN8(POINT));
    const fee = _fee.gt(maxFee) ? maxFee : _fee;
    return {
      amount,
      fee,
      expirationTime
    };
  }
}
function minExpirationTime(expirationTime1, expirationTime2) {
  if (expirationTime1 === void 0) return expirationTime2;
  if (expirationTime2 === void 0) return expirationTime1;
  return Math.min(expirationTime1, expirationTime2);
}
function fetchMultipleMintInfos(_0) {
  return __async(this, arguments, function* ({ connection, mints }) {
    var _a, _b;
    if (mints.length === 0) return {};
    const mintInfos = yield getMultipleAccountsInfoWithCustomFlags(
      connection,
      mints.map((i) => ({ pubkey: i }))
    );
    const mintK = {};
    for (const i of mintInfos) {
      const t = unpackMint(i.pubkey, i.accountInfo, (_a = i.accountInfo) == null ? void 0 : _a.owner);
      mintK[i.pubkey.toString()] = __spreadProps(__spreadValues({}, t), {
        feeConfig: (_b = getTransferFeeConfig(t)) != null ? _b : void 0
      });
    }
    return mintK;
  });
}
function BNDivCeil(bn1, bn2) {
  const { div, mod } = bn1.divmod(bn2);
  if (mod.gt(ZERO)) {
    return div.add(ONE);
  } else {
    return div;
  }
}

// src/farm/farm.ts
import { PublicKey as PublicKey13, SystemProgram as SystemProgram4, TransactionInstruction as TransactionInstruction7 } from "@solana/web3.js";
import BN9 from "bn.js";

// src/farm/importInstruction.ts
import { TransactionInstruction as TransactionInstruction6 } from "@solana/web3.js";
var anchorDataBuf = {
  voterStakeRegistryCreateVoter: Buffer.from([6, 24, 245, 52, 243, 255, 148, 25]),
  // CreateVoter
  voterStakeRegistryCreateDepositEntry: Buffer.from([185, 131, 167, 186, 159, 125, 19, 67]),
  // CreateDepositEntry
  voterStakeRegistryDeposit: Buffer.from([242, 35, 198, 137, 82, 225, 242, 182]),
  // Deposit
  voterStakeRegistryWithdraw: Buffer.from([183, 18, 70, 156, 148, 109, 161, 34]),
  // Withdraw
  voterStakeRegistryUpdateVoterWeightRecord: Buffer.from([45, 185, 3, 36, 109, 190, 115, 169])
  // UpdateVoterWeightRecord
};
function governanceCreateTokenOwnerRecord(programId, realm, governingTokenOwner, governingTokenMint, payer, tokenOwnerRecordAddress) {
  const dataLayout = struct([u82("ins")]);
  const keys = [
    AccountMetaReadonly(realm, false),
    AccountMetaReadonly(governingTokenOwner, false),
    AccountMeta(tokenOwnerRecordAddress, false),
    AccountMetaReadonly(governingTokenMint, false),
    AccountMeta(payer, true),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({ ins: 23 }, data);
  return new TransactionInstruction6({
    keys,
    programId,
    data
  });
}
function voterStakeRegistryCreateVoter(programId, registrar, voter, voterWeightRecord, voterAuthority, payer, voterBump, voterWeightRecordBump) {
  const dataLayout = struct([u82("voterBump"), u82("voterWeightRecordBump")]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMetaReadonly(voterAuthority, true),
    AccountMeta(voterWeightRecord, false),
    AccountMeta(payer, true),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
    AccountMetaReadonly(RENT_PROGRAM_ID, false),
    AccountMetaReadonly(INSTRUCTION_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({ voterBump, voterWeightRecordBump }, data);
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryCreateVoter, ...data]);
  return new TransactionInstruction6({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryCreateDepositEntry(programId, registrar, voter, voterVault, voterAuthority, payer, depositMint, depositEntryIndex, kind, startTs, periods, allowClawback) {
  const dataLayout = struct([
    u82("depositEntryIndex"),
    u82("kind"),
    u82("option"),
    u64("startTs"),
    u322("periods"),
    bool2("allowClawback")
  ]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMeta(voterVault, false),
    AccountMetaReadonly(voterAuthority, true),
    AccountMeta(payer, true),
    AccountMetaReadonly(depositMint, false),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
    AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
    AccountMetaReadonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
    AccountMetaReadonly(RENT_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      depositEntryIndex,
      kind,
      option: startTs === void 0 ? 0 : 1,
      startTs: startTs != null ? startTs : ZERO,
      periods,
      allowClawback
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryCreateDepositEntry, ...data]);
  return new TransactionInstruction6({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryDeposit(programId, registrar, voter, voterVault, depositToken, depositAuthority, userStakerInfoV2, pool, votingMint, votingMintAuthority, stakeProgramId, depositEntryIndex, amount) {
  const dataLayout = struct([u82("depositEntryIndex"), u64("amount")]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMeta(voterVault, false),
    AccountMeta(depositToken, false),
    AccountMetaReadonly(depositAuthority, true),
    AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
    AccountMeta(userStakerInfoV2, false),
    AccountMetaReadonly(pool, false),
    AccountMeta(votingMint, false),
    AccountMetaReadonly(votingMintAuthority, false),
    AccountMetaReadonly(stakeProgramId, false),
    AccountMetaReadonly(INSTRUCTION_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      depositEntryIndex,
      amount
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryDeposit, ...data]);
  return new TransactionInstruction6({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryUpdateVoterWeightRecord(programId, registrar, voter, voterWeightRecord) {
  const dataLayout = struct([]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMetaReadonly(voter, false),
    AccountMeta(voterWeightRecord, false),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({}, data);
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryUpdateVoterWeightRecord, ...data]);
  return new TransactionInstruction6({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryWithdraw(programId, registrar, voter, voterAuthority, tokenOwnerRecord, voterWeightRecord, vault, destination, userStakerInfoV2, pool, votingMint, votingMintAuthority, stakeProgramId, depositEntryIndex, amount) {
  const dataLayout = struct([u82("depositEntryIndex"), u64("amount")]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMetaReadonly(voterAuthority, true),
    AccountMetaReadonly(tokenOwnerRecord, false),
    AccountMeta(voterWeightRecord, false),
    AccountMeta(vault, false),
    AccountMeta(destination, false),
    AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
    AccountMeta(userStakerInfoV2, false),
    AccountMetaReadonly(pool, false),
    AccountMeta(votingMint, false),
    AccountMetaReadonly(votingMintAuthority, false),
    AccountMetaReadonly(stakeProgramId, false),
    AccountMetaReadonly(INSTRUCTION_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      depositEntryIndex,
      amount
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryWithdraw, ...data]);
  return new TransactionInstruction6({
    keys,
    programId,
    data: aData
  });
}

// src/farm/layout.ts
var REAL_FARM_STATE_LAYOUT_V3 = struct([
  u64("state"),
  u64("nonce"),
  publicKey("lpVault"),
  publicKey("rewardVault"),
  publicKey(),
  publicKey(),
  u64(),
  u64(),
  u64("totalReward"),
  u128("perShareReward"),
  u64("lastSlot"),
  u64("perSlotReward")
]);
var REAL_FARM_STATE_LAYOUT_V5 = struct([
  u64("state"),
  u64("nonce"),
  publicKey("lpVault"),
  publicKey("rewardVaultA"),
  u64("totalRewardA"),
  u128("perShareRewardA"),
  u64("perSlotRewardA"),
  u82("option"),
  publicKey("rewardVaultB"),
  blob(7),
  u64("totalRewardB"),
  u128("perShareRewardB"),
  u64("perSlotRewardB"),
  u64("lastSlot"),
  publicKey()
]);
var FARM_STATE_LAYOUT_V6_REWARD_INFO = struct([
  u64("rewardState"),
  u64("rewardOpenTime"),
  u64("rewardEndTime"),
  u64("rewardLastUpdateTime"),
  u64("totalReward"),
  u64("totalRewardEmissioned"),
  u64("rewardClaimed"),
  u64("rewardPerSecond"),
  u128("accRewardPerShare"),
  publicKey("rewardVault"),
  publicKey("rewardMint"),
  publicKey("rewardSender"),
  u64("rewardType"),
  seq2(u64(), 15, "padding")
]);
var REAL_FARM_STATE_LAYOUT_V6 = struct([
  u64(),
  u64("state"),
  u64("nonce"),
  u64("validRewardTokenNum"),
  u128("rewardMultiplier"),
  u64("rewardPeriodMax"),
  u64("rewardPeriodMin"),
  u64("rewardPeriodExtend"),
  publicKey("lpMint"),
  publicKey("lpVault"),
  seq2(FARM_STATE_LAYOUT_V6_REWARD_INFO, 5, "rewardInfos"),
  publicKey("creator"),
  publicKey(),
  seq2(u64(), 32, "padding")
]);
var FARM_STATE_LAYOUT_V3 = new Proxy(
  REAL_FARM_STATE_LAYOUT_V3,
  {
    get(target, p, receiver) {
      if (p === "decode")
        return (...decodeParams) => {
          const originalResult = target.decode(...decodeParams);
          return __spreadProps(__spreadValues({}, originalResult), {
            version: 3,
            rewardInfos: [
              {
                rewardVault: originalResult.rewardVault,
                totalReward: originalResult.totalReward,
                perSlotReward: originalResult.perSlotReward,
                perShareReward: originalResult.perShareReward
              }
            ]
          });
        };
      else return Reflect.get(target, p, receiver);
    }
  }
);
var FARM_STATE_LAYOUT_V5 = new Proxy(
  REAL_FARM_STATE_LAYOUT_V5,
  {
    get(target, p, receiver) {
      if (p === "decode")
        return (...decodeParams) => {
          const originalResult = target.decode(...decodeParams);
          return __spreadProps(__spreadValues({}, originalResult), {
            version: 5,
            rewardInfos: [
              {
                rewardVault: originalResult.rewardVaultA,
                totalReward: originalResult.totalRewardA,
                perSlotReward: originalResult.perSlotRewardA,
                perShareReward: originalResult.perShareRewardA
              },
              {
                rewardVault: originalResult.rewardVaultB,
                totalReward: originalResult.totalRewardB,
                perSlotReward: originalResult.perSlotRewardB,
                perShareReward: originalResult.perShareRewardB
              }
            ]
          });
        };
      else return Reflect.get(target, p, receiver);
    }
  }
);
var FARM_STATE_LAYOUT_V6 = new Proxy(
  REAL_FARM_STATE_LAYOUT_V6,
  {
    get(target, p, receiver) {
      if (p === "decode")
        return (...decodeParams) => {
          const originalResult = target.decode(...decodeParams);
          return __spreadProps(__spreadValues({}, originalResult), {
            version: 6,
            rewardInfos: originalResult.rewardInfos.map((item) => {
              var _a;
              return __spreadProps(__spreadValues({}, item), {
                rewardType: ((_a = Object.entries(poolTypeV6).find((i) => String(i[1]) === item.rewardType.toString())) != null ? _a : [
                  "Standard SPL"
                ])[0]
              });
            })
          });
        };
      else return Reflect.get(target, p, receiver);
    }
  }
);
var FARM_LEDGER_LAYOUT_V3_1 = struct([
  u64("state"),
  publicKey("id"),
  publicKey("owner"),
  u64("deposited"),
  seq2(u64(), 1, "rewardDebts")
]);
var FARM_LEDGER_LAYOUT_V3_2 = struct([
  u64("state"),
  publicKey("id"),
  publicKey("owner"),
  u64("deposited"),
  seq2(u128(), 1, "rewardDebts"),
  u64(""),
  u64("voteLockedBalance"),
  seq2(u64(), 15)
]);
var FARM_LEDGER_LAYOUT_V5_1 = struct([
  u64("state"),
  publicKey("id"),
  publicKey("owner"),
  u64("deposited"),
  seq2(u64(), 2, "rewardDebts")
]);
var FARM_LEDGER_LAYOUT_V5_2 = struct([
  u64("state"),
  publicKey("id"),
  publicKey("owner"),
  u64("deposited"),
  seq2(u128(), 2, "rewardDebts"),
  seq2(u64(), 17)
]);
var FARM_LEDGER_LAYOUT_V6_1 = struct([
  u64(),
  u64("state"),
  publicKey("id"),
  publicKey("owner"),
  u64("deposited"),
  seq2(u128(), 5, "rewardDebts"),
  seq2(u64(), 16)
]);
var FARM_VERSION_TO_STATE_LAYOUT = {
  3: FARM_STATE_LAYOUT_V3,
  5: FARM_STATE_LAYOUT_V5,
  6: FARM_STATE_LAYOUT_V6
};
var FARM_VERSION_TO_LEDGER_LAYOUT = {
  3: FARM_LEDGER_LAYOUT_V3_2,
  5: FARM_LEDGER_LAYOUT_V5_2,
  6: FARM_LEDGER_LAYOUT_V6_1
};
var VoterVotingMintConfig = struct([
  publicKey("mint"),
  publicKey("grantAuthority"),
  u64("baselineVoteWeightScaledFactor"),
  u64("maxExtraLockupVoteWeightScaledFactor"),
  u64("lockupSaturationSecs"),
  i8("digitShift"),
  // TODO
  seq2(u82(), 7, "reserved1"),
  seq2(u64(), 7, "reserved2")
]);
var VoterRegistrar = struct([
  blob(8),
  publicKey("governanceProgramId"),
  publicKey("realm"),
  publicKey("realmGoverningTokenMint"),
  publicKey("realmAuthority"),
  seq2(u82(), 32, "reserved1"),
  seq2(VoterVotingMintConfig, 4, "votingMints"),
  i64("timeOffset"),
  u82("bump"),
  seq2(u82(), 7, "reserved2"),
  seq2(u64(), 11, "reserved3")
]);
var VoterLockup = struct([i64("startTime"), i64("endTime"), u82("kind"), seq2(u82(), 15, "reserved")]);
var VoterDepositEntry = struct([
  seq2(VoterLockup, 1, "lockup"),
  u64("amountDeposited_native"),
  u64("amountInitiallyLockedNative"),
  bool2("isUsed"),
  bool2("allowClawback"),
  u82("votingMintConfigIdx"),
  seq2(u82(), 29, "reserved")
]);
var Voter = struct([
  blob(8),
  publicKey("voterAuthority"),
  publicKey("registrar"),
  seq2(VoterDepositEntry, 32, "deposits"),
  u82("voterBump"),
  u82("voterWweightRecordBump"),
  seq2(u82(), 94, "reserved")
]);

// src/farm/pda.ts
function getRegistrarAddress(programId, realm, communityTokenMint) {
  return findProgramAddress(
    [realm.toBuffer(), Buffer.from("registrar", "utf8"), communityTokenMint.toBuffer()],
    programId
  );
}
function getVotingTokenMint(programId, poolId) {
  return findProgramAddress([poolId.toBuffer(), Buffer.from("voting_mint_seed", "utf8")], programId);
}
function getVotingMintAuthority(programId, poolId) {
  return findProgramAddress([poolId.toBuffer()], programId);
}
function getVoterAddress(programId, registrar, authority) {
  return findProgramAddress([registrar.toBuffer(), Buffer.from("voter", "utf8"), authority.toBuffer()], programId);
}
function getVoterWeightRecordAddress(programId, registrar, authority) {
  return findProgramAddress(
    [registrar.toBuffer(), Buffer.from("voter-weight-record", "utf8"), authority.toBuffer()],
    programId
  );
}
function getTokenOwnerRecordAddress(programId, realm, governingTokenMint, governingTokenOwner) {
  return findProgramAddress(
    [
      Buffer.from("governance", "utf8"),
      realm.toBuffer(),
      governingTokenMint.toBuffer(),
      governingTokenOwner.toBuffer()
    ],
    programId
  );
}

// src/farm/farm.ts
var logger8 = Logger.from("Farm");
var poolTypeV6 = { "Standard SPL": 0, "Option tokens": 1 };
var Farm = class _Farm extends Base {
  /* ================= get layout ================= */
  static getStateLayout(version2) {
    const STATE_LAYOUT = FARM_VERSION_TO_STATE_LAYOUT[version2];
    logger8.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
    return STATE_LAYOUT;
  }
  static getLedgerLayout(version2) {
    const LEDGER_LAYOUT = FARM_VERSION_TO_LEDGER_LAYOUT[version2];
    logger8.assertArgument(!!LEDGER_LAYOUT, "invalid version", "version", version2);
    return LEDGER_LAYOUT;
  }
  static getLayouts(version2) {
    return { state: this.getStateLayout(version2), ledger: this.getLedgerLayout(version2) };
  }
  /* ================= get key ================= */
  static getAssociatedAuthority({ programId, poolId }) {
    return findProgramAddress([poolId.toBuffer()], programId);
  }
  static getAssociatedLedgerAccount({
    programId,
    poolId,
    owner,
    version: version2
  }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [
        poolId.toBuffer(),
        owner.toBuffer(),
        Buffer.from(version2 === 6 ? "farmer_info_associated_seed" : "staker_info_v2_associated_seed", "utf-8")
      ],
      programId
    );
    return publicKey2;
  }
  static getAssociatedLedgerPoolAccount({
    programId,
    poolId,
    mint,
    type
  }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [
        poolId.toBuffer(),
        mint.toBuffer(),
        Buffer.from(
          type === "lpVault" ? "lp_vault_associated_seed" : type === "rewardVault" ? "reward_vault_associated_seed" : "",
          "utf-8"
        )
      ],
      programId
    );
    return publicKey2;
  }
  /* ================= make instruction and transaction ================= */
  static makeDepositInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 3) {
      return this.makeDepositInstructionV3(params);
    } else if (version2 === 5) {
      return this.makeDepositInstructionV5(params);
    } else if (version2 === 6) {
      return this.makeDepositInstructionV6(params);
    }
    return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeDepositInstructionV3({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      poolKeys.rewardInfos.length === 1,
      "lengths not equal 1",
      "poolKeys.rewardInfos",
      poolKeys.rewardInfos
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === 1,
      "lengths not equal 1",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct([u82("instruction"), u64("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 10,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [38 /* farmV3Deposit */]
      }
    };
  }
  static makeDepositInstructionV5({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct([u82("instruction"), u64("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 11,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    for (let index = 1; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
    }
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [41 /* farmV5Deposit */]
      }
    };
  }
  static makeDepositInstructionV6({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length !== 0,
      "lengths equal zero",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct([u82("instruction"), u64("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 1,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false)
    ];
    for (let index = 0; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [44 /* farmV6Deposit */]
      }
    };
  }
  static makeWithdrawInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 3) {
      return this.makeWithdrawInstructionV3(params);
    } else if (version2 === 5) {
      return this.makeWithdrawInstructionV5(params);
    } else if (version2 === 6) {
      return this.makeWithdrawInstructionV6(params);
    }
    return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeWithdrawInstructionV3({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      poolKeys.rewardInfos.length === 1,
      "lengths not equal 1",
      "poolKeys.rewardInfos",
      poolKeys.rewardInfos
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === 1,
      "lengths not equal 1",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct([u82("instruction"), u64("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 11,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [41 /* farmV5Deposit */]
      }
    };
  }
  static makeWithdrawInstructionV5({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with params.poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct([u82("instruction"), u64("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 12,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    for (let index = 1; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
    }
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [42 /* farmV5Withdraw */]
      }
    };
  }
  static makeWithdrawInstructionV6({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length !== 0,
      "lengths equal zero",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with params.poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct([u82("instruction"), u64("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 2,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false)
    ];
    for (let index = 0; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [45 /* farmV6Withdraw */]
      }
    };
  }
  static makeCreateAssociatedLedgerAccountInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 3) {
      return this.makeCreateAssociatedLedgerAccountInstructionV3(params);
    } else if (version2 === 5) {
      return this.makeCreateAssociatedLedgerAccountInstructionV5(params);
    }
    return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeCreateAssociatedLedgerAccountInstructionV3({
    poolKeys,
    userKeys
  }) {
    const LAYOUT = struct([u82("instruction")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 9
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      // system
      AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
      AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false)
    ];
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [40 /* farmV3CreateLedger */]
      }
    };
  }
  static makeCreateAssociatedLedgerAccountInstructionV5({
    poolKeys,
    userKeys
  }) {
    const LAYOUT = struct([u82("instruction")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 10
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      // system
      AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
      AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false)
    ];
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction7({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [43 /* farmV5CreateLedger */]
      }
    };
  }
  static makeCreateFarmInstruction({ connection, userKeys, poolInfo }) {
    const { version: version2 } = poolInfo;
    if (version2 === 6) {
      return this.makeCreateFarmInstructionV6({
        connection,
        userKeys,
        poolInfo
      });
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreateFarmInstructionV6(_0) {
    return __async(this, arguments, function* ({ connection, userKeys, poolInfo }) {
      var _a, _b, _c;
      const payer = (_a = userKeys.payer) != null ? _a : userKeys.owner;
      const farmId = generatePubKey({ fromPublicKey: payer, programId: poolInfo.programId });
      const lamports = yield connection.getMinimumBalanceForRentExemption(FARM_STATE_LAYOUT_V6.span);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      frontInstructions.push(
        SystemProgram4.createAccountWithSeed({
          fromPubkey: payer,
          basePubkey: payer,
          seed: farmId.seed,
          newAccountPubkey: farmId.publicKey,
          lamports,
          space: FARM_STATE_LAYOUT_V6.span,
          programId: poolInfo.programId
        })
      );
      const { publicKey: authority, nonce } = _Farm.getAssociatedAuthority({
        programId: poolInfo.programId,
        poolId: farmId.publicKey
      });
      const lpVault = _Farm.getAssociatedLedgerPoolAccount({
        programId: poolInfo.programId,
        poolId: farmId.publicKey,
        mint: poolInfo.lpMint,
        type: "lpVault"
      });
      const rewardInfoConfig = [];
      const rewardInfoKey = [];
      for (const rewardInfo of poolInfo.rewardInfos) {
        logger8.assertArgument(
          rewardInfo.rewardOpenTime < rewardInfo.rewardEndTime,
          "start time error",
          "rewardInfo.rewardOpenTime",
          rewardInfo.rewardOpenTime
        );
        logger8.assertArgument(
          poolTypeV6[rewardInfo.rewardType] !== void 0,
          "reward type error",
          "rewardInfo.rewardType",
          rewardInfo.rewardType
        );
        logger8.assertArgument(
          parseBigNumberish(rewardInfo.rewardPerSecond).gt(ZERO),
          "rewardPerSecond error",
          "rewardInfo.rewardPerSecond",
          rewardInfo.rewardPerSecond
        );
        rewardInfoConfig.push({
          isSet: new BN9(1),
          rewardPerSecond: parseBigNumberish(rewardInfo.rewardPerSecond),
          rewardOpenTime: parseBigNumberish(rewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(rewardInfo.rewardEndTime),
          rewardType: parseBigNumberish(poolTypeV6[rewardInfo.rewardType])
        });
        let userRewardToken;
        if (rewardInfo.rewardMint.equals(PublicKey13.default)) {
          userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
            connection,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructions: frontInstructions,
            signers,
            amount: parseBigNumberish(rewardInfo.rewardEndTime).sub(parseBigNumberish(rewardInfo.rewardOpenTime)).mul(parseBigNumberish(rewardInfo.rewardPerSecond)),
            instructionsType: frontInstructionsType
          });
          endInstructions.push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: userRewardToken,
              owner: userKeys.owner,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              instructionsType: endInstructionsType
            })
          );
        } else {
          userRewardToken = this._selectTokenAccount({
            programId: TOKEN_PROGRAM_ID,
            tokenAccounts: userKeys.tokenAccounts,
            mint: rewardInfo.rewardMint,
            owner: userKeys.owner,
            config: { associatedOnly: false }
          });
        }
        logger8.assertArgument(
          userRewardToken !== null,
          "cannot found target token accounts",
          "tokenAccounts",
          userKeys.tokenAccounts
        );
        const rewardMint = rewardInfo.rewardMint.equals(PublicKey13.default) ? Token.WSOL.mint : rewardInfo.rewardMint;
        rewardInfoKey.push({
          rewardMint,
          rewardVault: _Farm.getAssociatedLedgerPoolAccount({
            programId: poolInfo.programId,
            poolId: farmId.publicKey,
            mint: rewardMint,
            type: "rewardVault"
          }),
          userRewardToken
        });
      }
      const lockUserAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts: userKeys.tokenAccounts,
        mint: poolInfo.lockInfo.lockMint,
        owner: userKeys.owner,
        config: { associatedOnly: false }
      });
      logger8.assertArgument(lockUserAccount !== null, "cannot found lock vault", "tokenAccounts", userKeys.tokenAccounts);
      const rewardTimeInfo = struct([
        u64("isSet"),
        u64("rewardPerSecond"),
        u64("rewardOpenTime"),
        u64("rewardEndTime"),
        u64("rewardType")
      ]);
      const LAYOUT = struct([u82("instruction"), u64("nonce"), seq2(rewardTimeInfo, 5, "rewardTimeInfo")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 0,
          nonce: new BN9(nonce),
          rewardTimeInfo: rewardInfoConfig
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
        AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false),
        AccountMeta(farmId.publicKey, false),
        AccountMetaReadonly(authority, false),
        AccountMeta(lpVault, false),
        AccountMetaReadonly(poolInfo.lpMint, false),
        AccountMeta(poolInfo.lockInfo.lockVault, false),
        AccountMetaReadonly(poolInfo.lockInfo.lockMint, false),
        AccountMeta(lockUserAccount != null ? lockUserAccount : PublicKey13.default, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      for (const item of rewardInfoKey) {
        keys.push(
          ...[
            { pubkey: item.rewardMint, isSigner: false, isWritable: false },
            { pubkey: item.rewardVault, isSigner: false, isWritable: true },
            { pubkey: item.userRewardToken, isSigner: false, isWritable: true }
          ]
        );
      }
      const ins = new TransactionInstruction7({
        programId: poolInfo.programId,
        keys,
        data
      });
      return {
        address: { farmId: farmId.publicKey },
        innerTransaction: {
          instructions: [...frontInstructions, ins, ...endInstructions],
          signers,
          lookupTableAddress: [],
          instructionTypes: [...frontInstructionsType, 46 /* farmV6Create */, ...endInstructionsType]
        }
      };
    });
  }
  static makeCreatorWithdrawFarmRewardInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeCreatorWithdrawFarmRewardInstructionV6(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreatorWithdrawFarmRewardInstructionV6({
    poolKeys,
    userKeys,
    withdrawMint
  }) {
    var _a;
    const rewardInfo = poolKeys.rewardInfos.find(
      (item) => item.rewardMint.equals(withdrawMint.equals(PublicKey13.default) ? Token.WSOL.mint : withdrawMint)
    );
    logger8.assertArgument(rewardInfo !== void 0, "withdraw mint error", "poolKeys.rewardInfos", poolKeys.rewardInfos);
    const rewardVault = (_a = rewardInfo == null ? void 0 : rewardInfo.rewardVault) != null ? _a : PublicKey13.default;
    const LAYOUT = struct([u82("instruction")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode({ instruction: 5 }, data);
    const keys = [
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMetaReadonly(poolKeys.lpVault, false),
      AccountMeta(rewardVault, false),
      AccountMeta(userKeys.userRewardToken, false),
      AccountMetaReadonly(userKeys.owner, true)
    ];
    const ins = new TransactionInstruction7({
      programId: poolKeys.programId,
      keys,
      data
    });
    return {
      address: {},
      innerTransaction: {
        instructions: [ins],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [49 /* farmV6CreatorWithdraw */]
      }
    };
  }
  /* ================= fetch data ================= */
  static fetchMultipleInfoAndUpdate(_0) {
    return __async(this, arguments, function* ({
      connection,
      pools,
      owner,
      config,
      chainTime
    }) {
      let hasNotV6Pool = false;
      let hasV6Pool = false;
      const publicKeys = [];
      const apiPoolInfo = {};
      for (const pool of pools) {
        apiPoolInfo[pool.id.toString()] = pool;
        if (pool.version === 6) hasV6Pool = true;
        else hasNotV6Pool = true;
        publicKeys.push({
          pubkey: pool.id,
          version: pool.version,
          key: "state",
          poolId: pool.id
        });
        publicKeys.push({
          pubkey: pool.lpVault,
          version: pool.version,
          key: "lpVault",
          poolId: pool.id
        });
        if (owner) {
          publicKeys.push({
            pubkey: this.getAssociatedLedgerAccount({
              programId: pool.programId,
              poolId: pool.id,
              owner,
              version: pool.version
            }),
            version: pool.version,
            key: "ledger",
            poolId: pool.id
          });
        }
      }
      const poolsInfo = {};
      const accountsInfo = yield getMultipleAccountsInfoWithCustomFlags(connection, publicKeys, config);
      for (const { pubkey, version: version2, key, poolId, accountInfo } of accountsInfo) {
        const _poolId = poolId.toBase58();
        if (key === "state") {
          const STATE_LAYOUT = this.getStateLayout(version2);
          if (!accountInfo || !accountInfo.data || accountInfo.data.length !== STATE_LAYOUT.span) {
            return logger8.throwArgumentError("invalid farm state account info", "pools.id", pubkey);
          }
          poolsInfo[_poolId] = __spreadValues(__spreadValues(__spreadValues({}, poolsInfo[_poolId]), { apiPoolInfo: apiPoolInfo[_poolId] }), { state: STATE_LAYOUT.decode(accountInfo.data) });
        } else if (key === "lpVault") {
          if (!accountInfo || !accountInfo.data || accountInfo.data.length !== SPL_ACCOUNT_LAYOUT.span) {
            return logger8.throwArgumentError("invalid farm lp vault account info", "pools.lpVault", pubkey);
          }
          poolsInfo[_poolId] = __spreadValues(__spreadValues({}, poolsInfo[_poolId]), { lpVault: SPL_ACCOUNT_LAYOUT.decode(accountInfo.data) });
        } else if (key === "ledger") {
          const LEDGER_LAYOUT = this.getLedgerLayout(version2);
          if (accountInfo && accountInfo.data) {
            logger8.assertArgument(
              accountInfo.data.length === LEDGER_LAYOUT.span,
              "invalid farm ledger account info",
              "ledger",
              pubkey
            );
            poolsInfo[_poolId] = __spreadValues(__spreadValues({}, poolsInfo[_poolId]), { ledger: LEDGER_LAYOUT.decode(accountInfo.data) });
          }
        }
      }
      const slot = hasV6Pool || hasNotV6Pool ? yield connection.getSlot() : 0;
      for (const poolId of Object.keys(poolsInfo)) {
        if (poolsInfo[poolId] === void 0) continue;
        poolsInfo[poolId].state = _Farm.updatePoolInfo(poolsInfo[poolId].state, poolsInfo[poolId].lpVault, slot, chainTime);
      }
      for (const [poolId, { state, ledger }] of Object.entries(poolsInfo)) {
        if (ledger) {
          let multiplier;
          if (state.version === 6) {
            multiplier = state.rewardMultiplier;
          } else {
            multiplier = state.rewardInfos.length === 1 ? TEN.pow(new BN9(9)) : TEN.pow(new BN9(15));
          }
          const pendingRewards = state.rewardInfos.map((rewardInfo, index) => {
            const rewardDebt = ledger.rewardDebts[index];
            const pendingReward = ledger.deposited.mul(state.version === 6 ? rewardInfo.accRewardPerShare : rewardInfo.perShareReward).div(multiplier).sub(rewardDebt);
            return pendingReward;
          });
          poolsInfo[poolId].wrapped = __spreadProps(__spreadValues({}, poolsInfo[poolId].wrapped), {
            pendingRewards
          });
        }
      }
      return poolsInfo;
    });
  }
  static updatePoolInfo(poolInfo, lpVault, slot, chainTime) {
    if (poolInfo.version === 3 || poolInfo.version === 5) {
      if (poolInfo.lastSlot.gte(new BN9(slot))) return poolInfo;
      const spread = new BN9(slot).sub(poolInfo.lastSlot);
      poolInfo.lastSlot = new BN9(slot);
      for (const itemRewardInfo of poolInfo.rewardInfos) {
        if (lpVault.amount.eq(new BN9(0))) continue;
        const reward = itemRewardInfo.perSlotReward.mul(spread);
        itemRewardInfo.perShareReward = itemRewardInfo.perShareReward.add(
          reward.mul(new BN9(10).pow(new BN9(poolInfo.version === 3 ? 9 : 15))).div(lpVault.amount)
        );
        itemRewardInfo.totalReward = itemRewardInfo.totalReward.add(reward);
      }
    } else if (poolInfo.version === 6) {
      for (const itemRewardInfo of poolInfo.rewardInfos) {
        if (itemRewardInfo.rewardState.eq(new BN9(0))) continue;
        const updateTime = BN9.min(new BN9(chainTime), itemRewardInfo.rewardEndTime);
        if (itemRewardInfo.rewardOpenTime.gte(updateTime)) continue;
        const spread = updateTime.sub(itemRewardInfo.rewardLastUpdateTime);
        let reward = spread.mul(itemRewardInfo.rewardPerSecond);
        const leftReward = itemRewardInfo.totalReward.sub(itemRewardInfo.totalRewardEmissioned);
        if (leftReward.lt(reward)) {
          reward = leftReward;
          itemRewardInfo.rewardLastUpdateTime = itemRewardInfo.rewardLastUpdateTime.add(
            leftReward.div(itemRewardInfo.rewardPerSecond)
          );
        } else {
          itemRewardInfo.rewardLastUpdateTime = updateTime;
        }
        if (lpVault.amount.eq(new BN9(0))) continue;
        itemRewardInfo.accRewardPerShare = itemRewardInfo.accRewardPerShare.add(
          reward.mul(poolInfo.rewardMultiplier).div(lpVault.amount)
        );
        itemRewardInfo.totalRewardEmissioned = itemRewardInfo.totalRewardEmissioned.add(reward);
      }
    }
    return poolInfo;
  }
  /* ================= make instruction simple ================= */
  static makeCreatorWithdrawFarmRewardInstructionSimple(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeCreatorWithdrawFarmRewardInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreatorWithdrawFarmRewardInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      userKeys,
      withdrawMint,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c, _d;
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let userRewardToken;
      if (withdrawMint.equals(PublicKey13.default)) {
        userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner: userKeys.owner,
          payer: (_a = userKeys.payer) != null ? _a : userKeys.owner,
          instructions: frontInstructions,
          signers,
          amount: 0,
          instructionsType: frontInstructionsType
        });
        endInstructions.push(
          Spl.makeCloseAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            tokenAccount: userRewardToken,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructionsType: endInstructionsType
          })
        );
      } else {
        const selectUserRewardToken = this._selectTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          tokenAccounts: userKeys.tokenAccounts,
          mint: withdrawMint,
          owner: userKeys.owner
        });
        if (selectUserRewardToken === null) {
          userRewardToken = getATAAddress(userKeys.owner, withdrawMint, TOKEN_PROGRAM_ID).publicKey;
          frontInstructions.push(
            Spl.makeCreateAssociatedTokenAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              mint: withdrawMint,
              associatedAccount: userRewardToken,
              owner: userKeys.owner,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              instructionsType: frontInstructionsType
            })
          );
        } else {
          userRewardToken = selectUserRewardToken;
        }
      }
      const ins = this.makeCreatorWithdrawFarmRewardInstructionV6({
        poolKeys,
        userKeys: { userRewardToken, owner: userKeys.owner, payer: userKeys.payer },
        withdrawMint
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCreateFarmInstructionSimple(params) {
    const { version: version2 } = params.poolInfo;
    if (version2 === 6) {
      return this.makeCreateFarmInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreateFarmInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      userKeys,
      poolInfo,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c, _d;
      const payer = (_a = userKeys.payer) != null ? _a : userKeys.owner;
      const farmId = generatePubKey({ fromPublicKey: payer, programId: poolInfo.programId });
      const lamports = yield connection.getMinimumBalanceForRentExemption(FARM_STATE_LAYOUT_V6.span);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      frontInstructions.push(
        SystemProgram4.createAccountWithSeed({
          fromPubkey: payer,
          basePubkey: payer,
          seed: farmId.seed,
          newAccountPubkey: farmId.publicKey,
          lamports,
          space: FARM_STATE_LAYOUT_V6.span,
          programId: poolInfo.programId
        })
      );
      const { publicKey: authority, nonce } = _Farm.getAssociatedAuthority({
        programId: poolInfo.programId,
        poolId: farmId.publicKey
      });
      const lpVault = _Farm.getAssociatedLedgerPoolAccount({
        programId: poolInfo.programId,
        poolId: farmId.publicKey,
        mint: poolInfo.lpMint,
        type: "lpVault"
      });
      const rewardInfoConfig = [];
      const rewardInfoKey = [];
      for (const rewardInfo of poolInfo.rewardInfos) {
        logger8.assertArgument(
          rewardInfo.rewardOpenTime < rewardInfo.rewardEndTime,
          "start time error",
          "rewardInfo.rewardOpenTime",
          rewardInfo.rewardOpenTime
        );
        logger8.assertArgument(
          poolTypeV6[rewardInfo.rewardType] !== void 0,
          "reward type error",
          "rewardInfo.rewardType",
          rewardInfo.rewardType
        );
        logger8.assertArgument(
          parseBigNumberish(rewardInfo.rewardPerSecond).gt(ZERO),
          "rewardPerSecond error",
          "rewardInfo.rewardPerSecond",
          rewardInfo.rewardPerSecond
        );
        rewardInfoConfig.push({
          isSet: new BN9(1),
          rewardPerSecond: parseBigNumberish(rewardInfo.rewardPerSecond),
          rewardOpenTime: parseBigNumberish(rewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(rewardInfo.rewardEndTime),
          rewardType: parseBigNumberish(poolTypeV6[rewardInfo.rewardType])
        });
        let userRewardToken;
        if (rewardInfo.rewardMint.equals(PublicKey13.default)) {
          userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
            connection,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructions: frontInstructions,
            signers,
            amount: parseBigNumberish(rewardInfo.rewardEndTime).sub(parseBigNumberish(rewardInfo.rewardOpenTime)).mul(parseBigNumberish(rewardInfo.rewardPerSecond)),
            instructionsType: frontInstructionsType
          });
          endInstructions.push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: userRewardToken,
              owner: userKeys.owner,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              instructionsType: endInstructionsType
            })
          );
        } else {
          userRewardToken = this._selectTokenAccount({
            programId: TOKEN_PROGRAM_ID,
            tokenAccounts: userKeys.tokenAccounts,
            mint: rewardInfo.rewardMint,
            owner: userKeys.owner,
            config: { associatedOnly: false }
          });
        }
        logger8.assertArgument(
          userRewardToken !== null,
          "cannot found target token accounts",
          "tokenAccounts",
          userKeys.tokenAccounts
        );
        if (userRewardToken === null) throw Error("cannot found target token accounts");
        const rewardMint = rewardInfo.rewardMint.equals(PublicKey13.default) ? Token.WSOL.mint : rewardInfo.rewardMint;
        rewardInfoKey.push({
          rewardMint,
          rewardVault: _Farm.getAssociatedLedgerPoolAccount({
            programId: poolInfo.programId,
            poolId: farmId.publicKey,
            mint: rewardMint,
            type: "rewardVault"
          }),
          userRewardToken
        });
      }
      const lockUserAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts: userKeys.tokenAccounts,
        mint: poolInfo.lockInfo.lockMint,
        owner: userKeys.owner,
        config: { associatedOnly: false }
      });
      logger8.assertArgument(lockUserAccount !== null, "cannot found lock vault", "tokenAccounts", userKeys.tokenAccounts);
      const rewardTimeInfo = struct([
        u64("isSet"),
        u64("rewardPerSecond"),
        u64("rewardOpenTime"),
        u64("rewardEndTime"),
        u64("rewardType")
      ]);
      const LAYOUT = struct([u82("instruction"), u64("nonce"), seq2(rewardTimeInfo, 5, "rewardTimeInfo")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 0,
          nonce: new BN9(nonce),
          rewardTimeInfo: rewardInfoConfig
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
        AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false),
        AccountMeta(farmId.publicKey, false),
        AccountMetaReadonly(authority, false),
        AccountMeta(lpVault, false),
        AccountMetaReadonly(poolInfo.lpMint, false),
        AccountMeta(poolInfo.lockInfo.lockVault, false),
        AccountMetaReadonly(poolInfo.lockInfo.lockMint, false),
        AccountMeta(lockUserAccount != null ? lockUserAccount : PublicKey13.default, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      for (const item of rewardInfoKey) {
        keys.push(
          ...[
            { pubkey: item.rewardMint, isSigner: false, isWritable: false },
            { pubkey: item.rewardVault, isSigner: false, isWritable: true },
            { pubkey: item.userRewardToken, isSigner: false, isWritable: true }
          ]
        );
      }
      const ins = new TransactionInstruction7({
        programId: poolInfo.programId,
        keys,
        data
      });
      return {
        address: { farmId: farmId.publicKey },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: [46 /* farmV6Create */], instructions: [ins], signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeRestartFarmInstructionSimple(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeRestartFarmInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeRestartFarmInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      userKeys,
      newRewardInfo,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c, _d;
      logger8.assertArgument(
        newRewardInfo.rewardOpenTime < newRewardInfo.rewardEndTime,
        "start time error",
        "newRewardInfo",
        newRewardInfo
      );
      const rewardMint = newRewardInfo.rewardMint.equals(PublicKey13.default) ? Token.WSOL.mint : newRewardInfo.rewardMint;
      const rewardInfo = poolKeys.rewardInfos.find((item) => item.rewardMint.equals(rewardMint));
      logger8.assertArgument(rewardInfo, "configuration does not exist", "rewardInfo", rewardInfo);
      const rewardVault = (_a = rewardInfo == null ? void 0 : rewardInfo.rewardVault) != null ? _a : PublicKey13.default;
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let userRewardToken;
      if (newRewardInfo.rewardMint.equals(PublicKey13.default)) {
        userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner: userKeys.owner,
          payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
          instructions: frontInstructions,
          signers,
          amount: parseBigNumberish(newRewardInfo.rewardEndTime).sub(parseBigNumberish(newRewardInfo.rewardOpenTime)).mul(parseBigNumberish(newRewardInfo.rewardPerSecond)),
          instructionsType: frontInstructionsType
        });
        endInstructions.push(
          Spl.makeCloseAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            tokenAccount: userRewardToken,
            owner: userKeys.owner,
            payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
            instructionsType: endInstructionsType
          })
        );
      } else {
        userRewardToken = this._selectTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          tokenAccounts: userKeys.tokenAccounts,
          mint: newRewardInfo.rewardMint,
          owner: userKeys.owner,
          config: { associatedOnly: false }
        });
      }
      logger8.assertArgument(
        userRewardToken !== null,
        "cannot found target token accounts",
        "tokenAccounts",
        userKeys.tokenAccounts
      );
      if (userRewardToken === null) throw Error("cannot found target token accounts");
      const LAYOUT = struct([u82("instruction"), u64("rewardReopenTime"), u64("rewardEndTime"), u64("rewardPerSecond")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 3,
          rewardReopenTime: parseBigNumberish(newRewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(newRewardInfo.rewardEndTime),
          rewardPerSecond: parseBigNumberish(newRewardInfo.rewardPerSecond)
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.lpVault, false),
        AccountMeta(rewardVault, false),
        AccountMeta(userRewardToken, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      const ins = new TransactionInstruction7({
        programId: poolKeys.programId,
        keys,
        data
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: [47 /* farmV6Restart */], instructions: [ins], signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeFarmCreatorAddRewardTokenInstructionSimple(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeFarmCreatorAddRewardTokenInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeFarmCreatorAddRewardTokenInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      userKeys,
      newRewardInfo,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c;
      const rewardVault = _Farm.getAssociatedLedgerPoolAccount({
        programId: poolKeys.programId,
        poolId: poolKeys.id,
        mint: newRewardInfo.rewardMint.equals(PublicKey13.default) ? Token.WSOL.mint : newRewardInfo.rewardMint,
        type: "rewardVault"
      });
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let userRewardToken;
      if (newRewardInfo.rewardMint.equals(PublicKey13.default)) {
        userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner: userKeys.owner,
          payer: (_a = userKeys.payer) != null ? _a : userKeys.owner,
          instructions: frontInstructions,
          signers,
          amount: parseBigNumberish(newRewardInfo.rewardEndTime).sub(parseBigNumberish(newRewardInfo.rewardOpenTime)).mul(parseBigNumberish(newRewardInfo.rewardPerSecond)),
          instructionsType: frontInstructionsType
        });
        endInstructions.push(
          Spl.makeCloseAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            tokenAccount: userRewardToken,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructionsType: endInstructionsType
          })
        );
      } else {
        userRewardToken = this._selectTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          tokenAccounts: userKeys.tokenAccounts,
          mint: newRewardInfo.rewardMint,
          owner: userKeys.owner,
          config: { associatedOnly: false }
        });
      }
      logger8.assertArgument(
        userRewardToken !== null,
        "cannot found target token accounts",
        "tokenAccounts",
        userKeys.tokenAccounts
      );
      if (userRewardToken === null) throw Error("cannot found target token accounts");
      const rewardMint = newRewardInfo.rewardMint.equals(PublicKey13.default) ? Token.WSOL.mint : newRewardInfo.rewardMint;
      const LAYOUT = struct([
        u82("instruction"),
        u64("isSet"),
        u64("rewardPerSecond"),
        u64("rewardOpenTime"),
        u64("rewardEndTime"),
        u64("rewardType")
      ]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 4,
          isSet: new BN9(1),
          rewardPerSecond: parseBigNumberish(newRewardInfo.rewardPerSecond),
          rewardOpenTime: parseBigNumberish(newRewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(newRewardInfo.rewardEndTime),
          rewardType: parseBigNumberish(poolTypeV6[newRewardInfo.rewardType])
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
        AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false),
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.authority, false),
        AccountMetaReadonly(rewardMint, false),
        AccountMeta(rewardVault, false),
        AccountMeta(userRewardToken, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      const ins = new TransactionInstruction7({
        programId: poolKeys.programId,
        keys,
        data
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: [48 /* farmV6CreatorAddReward */], instructions: [ins], signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeDepositInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      fetchPoolInfo,
      ownerInfo,
      amount,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const { lpVault, apiPoolInfo, ledger } = fetchPoolInfo;
      const lpMint = lpVault.mint;
      const ownerLpTokenAccount = ownerMintToAccount[lpMint.toString()];
      logger8.assertArgument(ownerLpTokenAccount, "you don't have any lp", "lp zero", ownerMintToAccount);
      const rewardAccounts = [];
      for (const itemReward of apiPoolInfo.rewardInfos) {
        const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = (_a = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          mint: itemReward.rewardMint,
          tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: rewardUseSOLBalance ? endInstructions : [],
            endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
        rewardAccounts.push(ownerRewardAccount);
      }
      const ledgerAddress = yield _Farm.getAssociatedLedgerAccount({
        programId: new PublicKey13(apiPoolInfo.programId),
        poolId: new PublicKey13(apiPoolInfo.id),
        owner: ownerInfo.wallet,
        version: apiPoolInfo.version
      });
      if (apiPoolInfo.version < 6 && !ledger) {
        const ins = _Farm.makeCreateAssociatedLedgerAccountInstruction({
          poolKeys,
          userKeys: {
            owner: ownerInfo.wallet,
            ledger: ledgerAddress
          }
        });
        frontInstructions.push(...ins.innerTransaction.instructions);
        frontInstructionsType.push(...ins.innerTransaction.instructionTypes);
      }
      const depositInstruction = _Farm.makeDepositInstruction({
        poolKeys,
        userKeys: {
          ledger: ledgerAddress,
          lpTokenAccount: ownerLpTokenAccount,
          owner: ownerInfo.wallet,
          rewardTokenAccounts: rewardAccounts
        },
        amount
      });
      return {
        address: depositInstruction.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            depositInstruction.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeWithdrawInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      fetchPoolInfo,
      ownerInfo,
      amount,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const withdrawInstructions = [];
      const withdrawInstructionsType = [];
      const signers = [];
      const { lpVault, wrapped, apiPoolInfo } = fetchPoolInfo;
      if (wrapped === void 0) throw Error("no lp");
      const lpMint = lpVault.mint;
      const lpMintUseSOLBalance = ownerInfo.useSOLBalance && lpMint.equals(Token.WSOL.mint);
      const ownerLpTokenAccount = (_a = ownerMintToAccount[lpMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: lpMint,
        tokenAccounts: lpMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          signers
        },
        associatedOnly: lpMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      ownerMintToAccount[lpMint.toString()] = ownerLpTokenAccount;
      const rewardAccounts = [];
      for (const itemReward of apiPoolInfo.rewardInfos) {
        const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = (_b = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          mint: itemReward.rewardMint,
          tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: rewardUseSOLBalance ? endInstructions : [],
            endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
        rewardAccounts.push(ownerRewardAccount);
      }
      const ins = this.makeWithdrawInstruction({
        poolKeys: apiPoolInfo,
        userKeys: {
          ledger: this.getAssociatedLedgerAccount({
            programId: apiPoolInfo.programId,
            poolId: apiPoolInfo.id,
            owner: ownerInfo.wallet,
            version: apiPoolInfo.version
          }),
          lpTokenAccount: ownerLpTokenAccount,
          rewardTokenAccounts: rewardAccounts,
          owner: ownerInfo.wallet
        },
        amount
      });
      withdrawInstructions.push(...ins.innerTransaction.instructions);
      withdrawInstructionsType.push(...ins.innerTransaction.instructionTypes);
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: withdrawInstructionsType, instructions: withdrawInstructions, signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeHarvestAllRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      fetchPoolInfos,
      ownerInfo,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const harvestInstructions = [];
      const signers = [];
      for (const { lpVault, wrapped, apiPoolInfo, ledger } of Object.values(fetchPoolInfos)) {
        if (wrapped === void 0 || ledger === void 0 || !(wrapped.pendingRewards.find((i) => i.gt(ZERO)) !== void 0 || ledger.deposited.isZero()))
          continue;
        const lpMint = lpVault.mint;
        const lpMintUseSOLBalance = ownerInfo.useSOLBalance && lpMint.equals(Token.WSOL.mint);
        const ownerLpTokenAccount = (_a = ownerMintToAccount[lpMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          mint: lpMint,
          tokenAccounts: lpMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            signers
          },
          associatedOnly: lpMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[lpMint.toString()] = ownerLpTokenAccount;
        const rewardAccounts = [];
        for (const itemReward of apiPoolInfo.rewardInfos) {
          const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token.WSOL.mint);
          const ownerRewardAccount = (_b = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
            programId: TOKEN_PROGRAM_ID,
            mint: itemReward.rewardMint,
            tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardUseSOLBalance ? endInstructions : [],
              endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
              signers
            },
            associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
          rewardAccounts.push(ownerRewardAccount);
        }
        const ins = this.makeWithdrawInstruction({
          poolKeys: apiPoolInfo,
          userKeys: {
            ledger: this.getAssociatedLedgerAccount({
              programId: apiPoolInfo.programId,
              poolId: apiPoolInfo.id,
              owner: ownerInfo.wallet,
              version: apiPoolInfo.version
            }),
            lpTokenAccount: ownerLpTokenAccount,
            rewardTokenAccounts: rewardAccounts,
            owner: ownerInfo.wallet
          },
          amount: 0
        });
        harvestInstructions.push(ins.innerTransaction);
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...harvestInstructions,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  /**
   * @deprecated the method is **DANGEROUS**, please don't use
   */
  static makeV1InfoToV2PdaAndHarvestSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      wallet,
      tokenAccounts,
      programIdV3,
      programIdV5,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      const mintToAccount = {};
      for (const item of tokenAccounts) {
        const mint = item.accountInfo.mint;
        const ata = getATAAddress(wallet, mint, item.programId).publicKey;
        if (ata.equals(item.pubkey)) mintToAccount[mint.toString()] = ata;
        if (mintToAccount[mint.toString()] === void 0) mintToAccount[mint.toString()] = item.pubkey;
      }
      const dataInfoV3 = yield connection.getProgramAccounts(programIdV3, {
        filters: [{ memcmp: { offset: 40, bytes: wallet.toString() } }]
      });
      const dataInfoV5 = yield connection.getProgramAccounts(programIdV5, {
        filters: [{ memcmp: { offset: 40, bytes: wallet.toString() } }]
      });
      const poolIdToAccountV3 = {};
      const poolIdToAccountV5 = {};
      for (const item of dataInfoV3) {
        const layout = item.account.data.length === FARM_LEDGER_LAYOUT_V3_1.span ? FARM_LEDGER_LAYOUT_V3_1 : FARM_LEDGER_LAYOUT_V3_2;
        const info = layout.decode(item.account.data);
        const poolId = info.id.toString();
        const pda = this.getAssociatedLedgerAccount({
          programId: programIdV3,
          poolId: info.id,
          owner: wallet,
          version: 3
        });
        if (poolIdToAccountV3[poolId] === void 0) {
          poolIdToAccountV3[poolId] = { pda: void 0, other: [] };
        }
        if (pda.equals(item.pubkey)) {
          poolIdToAccountV3[poolId].pda = item.pubkey;
        } else {
          poolIdToAccountV3[poolId].other.push(item.pubkey);
        }
      }
      for (const item of dataInfoV5) {
        const layout = item.account.data.length === FARM_LEDGER_LAYOUT_V5_1.span ? FARM_LEDGER_LAYOUT_V5_1 : FARM_LEDGER_LAYOUT_V5_2;
        const info = layout.decode(item.account.data);
        const poolId = info.id.toString();
        const pda = this.getAssociatedLedgerAccount({
          programId: programIdV5,
          poolId: info.id,
          owner: wallet,
          version: 5
        });
        if (poolIdToAccountV5[poolId] === void 0) {
          poolIdToAccountV5[poolId] = { pda: void 0, other: [] };
        }
        if (pda.equals(item.pubkey)) {
          poolIdToAccountV5[poolId].pda = item.pubkey;
        } else {
          poolIdToAccountV5[poolId].other.push(item.pubkey);
        }
      }
      const needCheckPoolId = [
        ...Object.entries(poolIdToAccountV3).filter((i) => i[1].other.length > 0).map((i) => i[0]),
        ...Object.entries(poolIdToAccountV5).filter((i) => i[1].other.length > 0).map((i) => i[0])
      ];
      const allPoolInfo = yield connection.getMultipleAccountsInfo(needCheckPoolId.map((i) => new PublicKey13(i)));
      const poolIdToInfo = {};
      for (let i = 0; i < needCheckPoolId.length; i++) {
        const id = needCheckPoolId[i];
        const info = allPoolInfo[i];
        if (info === null) continue;
        poolIdToInfo[id] = info.data;
      }
      const frontInstructions = [];
      const frontInstructionsType = [];
      const instructions = [];
      const endInstructions = [];
      const endInstructionsType = [];
      for (const [poolId, info] of Object.entries(poolIdToAccountV3)) {
        if (info.other.length === 0) continue;
        if (poolIdToInfo[poolId] === void 0) continue;
        const poolInfo = REAL_FARM_STATE_LAYOUT_V3.decode(poolIdToInfo[poolId]);
        const [_lpInfo, _rewardInfo] = yield connection.getMultipleAccountsInfo([poolInfo.lpVault, poolInfo.rewardVault]);
        if (_lpInfo === null || _rewardInfo === null) throw Error("get lp and reward info error");
        const lpInfo = SPL_ACCOUNT_LAYOUT.decode(_lpInfo.data);
        const rewardInfo = SPL_ACCOUNT_LAYOUT.decode(_rewardInfo.data);
        let lpAccount = mintToAccount[lpInfo.mint.toString()];
        if (lpAccount === void 0) {
          lpAccount = yield this._selectOrCreateTokenAccount({
            programId: _lpInfo.owner,
            mint: lpInfo.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: [],
              endInstructionsType: [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[lpInfo.mint.toString()] = lpAccount;
        }
        let rewardAccount = mintToAccount[rewardInfo.mint.toString()];
        if (rewardAccount === void 0) {
          rewardAccount = yield this._selectOrCreateTokenAccount({
            programId: _rewardInfo.owner,
            mint: rewardInfo.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardInfo.mint.toString() === WSOL.mint ? endInstructions : [],
              endInstructionsType: rewardInfo.mint.toString() === WSOL.mint ? endInstructionsType : [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[rewardInfo.mint.toString()] = rewardAccount;
        }
        if (info.pda === void 0) {
          const _i2 = this.makeCreateAssociatedLedgerAccountInstructionV3({
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            poolKeys: { programId: programIdV3, id: new PublicKey13(poolId) },
            userKeys: {
              ledger: this.getAssociatedLedgerAccount({
                programId: programIdV3,
                poolId: new PublicKey13(poolId),
                owner: wallet,
                version: 3
              }),
              owner: wallet
            }
          });
          instructions.push(_i2.innerTransaction);
        }
        const _i = this.makeDepositInstructionV3({
          amount: 0,
          userKeys: {
            ledger: this.getAssociatedLedgerAccount({
              programId: programIdV3,
              poolId: new PublicKey13(poolId),
              owner: wallet,
              version: 3
            }),
            owner: wallet,
            lpTokenAccount: lpAccount,
            rewardTokenAccounts: [rewardAccount],
            auxiliaryLedgers: info.other
          },
          poolKeys: {
            programId: programIdV3,
            id: new PublicKey13(poolId),
            authority: this.getAssociatedAuthority({ programId: programIdV3, poolId: new PublicKey13(poolId) }).publicKey,
            lpVault: poolInfo.lpVault,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            rewardInfos: [{ rewardVault: poolInfo.rewardVault }]
          }
        });
        instructions.push(_i.innerTransaction);
      }
      for (const [poolId, info] of Object.entries(poolIdToAccountV5)) {
        if (info.other.length === 0) continue;
        if (poolIdToInfo[poolId] === void 0) continue;
        const poolInfo = REAL_FARM_STATE_LAYOUT_V5.decode(poolIdToInfo[poolId]);
        const [_lpInfo, _rewardInfoA, _rewardInfoB] = yield connection.getMultipleAccountsInfo([
          poolInfo.lpVault,
          poolInfo.rewardVaultA,
          poolInfo.rewardVaultB
        ]);
        if (_lpInfo === null || _rewardInfoA === null || _rewardInfoB === null)
          throw Error("get lp and reward A / B info error");
        const lpInfo = SPL_ACCOUNT_LAYOUT.decode(_lpInfo.data);
        const rewardInfoA = SPL_ACCOUNT_LAYOUT.decode(_rewardInfoA.data);
        const rewardInfoB = SPL_ACCOUNT_LAYOUT.decode(_rewardInfoB.data);
        let lpAccount = mintToAccount[lpInfo.mint.toString()];
        if (lpAccount === void 0) {
          lpAccount = yield this._selectOrCreateTokenAccount({
            programId: _lpInfo.owner,
            mint: lpInfo.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: [],
              endInstructionsType: [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[lpInfo.mint.toString()] = lpAccount;
        }
        let rewardAccountA = mintToAccount[rewardInfoA.mint.toString()];
        if (rewardAccountA === void 0) {
          rewardAccountA = yield this._selectOrCreateTokenAccount({
            programId: _rewardInfoA.owner,
            mint: rewardInfoA.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardInfoA.mint.toString() === WSOL.mint ? endInstructions : [],
              endInstructionsType: rewardInfoA.mint.toString() === WSOL.mint ? endInstructionsType : [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[rewardInfoA.mint.toString()] = rewardAccountA;
        }
        let rewardAccountB = mintToAccount[rewardInfoB.mint.toString()];
        if (rewardAccountB === void 0) {
          rewardAccountB = yield this._selectOrCreateTokenAccount({
            programId: _rewardInfoB.owner,
            mint: rewardInfoB.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardInfoB.mint.toString() === WSOL.mint ? endInstructions : [],
              endInstructionsType: rewardInfoB.mint.toString() === WSOL.mint ? endInstructionsType : [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[rewardInfoB.mint.toString()] = rewardAccountB;
        }
        if (info.pda === void 0) {
          const _i2 = this.makeCreateAssociatedLedgerAccountInstructionV5({
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            poolKeys: { programId: programIdV5, id: new PublicKey13(poolId) },
            userKeys: {
              ledger: this.getAssociatedLedgerAccount({
                programId: programIdV5,
                poolId: new PublicKey13(poolId),
                owner: wallet,
                version: 5
              }),
              owner: wallet
            }
          });
          instructions.push(_i2.innerTransaction);
        }
        const _i = this.makeDepositInstructionV5({
          amount: 0,
          userKeys: {
            ledger: this.getAssociatedLedgerAccount({
              programId: programIdV5,
              poolId: new PublicKey13(poolId),
              owner: wallet,
              version: 5
            }),
            owner: wallet,
            lpTokenAccount: lpAccount,
            rewardTokenAccounts: [rewardAccountA, rewardAccountB],
            auxiliaryLedgers: info.other
          },
          poolKeys: {
            programId: programIdV5,
            id: new PublicKey13(poolId),
            authority: this.getAssociatedAuthority({ programId: programIdV5, poolId: new PublicKey13(poolId) }).publicKey,
            lpVault: poolInfo.lpVault,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            rewardInfos: [{ rewardVault: poolInfo.rewardVaultA }, { rewardVault: poolInfo.rewardVaultB }]
          }
        });
        instructions.push(_i.innerTransaction);
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: wallet,
          innerTransaction: [
            {
              instructionTypes: frontInstructionsType.slice(0, 10),
              instructions: frontInstructions.slice(0, 10),
              signers: []
            },
            ...frontInstructions.length > 10 ? [
              {
                instructionTypes: frontInstructionsType.slice(10),
                instructions: frontInstructions.slice(10),
                signers: []
              }
            ] : [],
            ...instructions,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeDepositTokenInstruction(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      governanceProgramId,
      voteWeightAddinProgramId,
      realm,
      communityTokenMint,
      owner,
      poolId
    }) {
      const registrar = getRegistrarAddress(voteWeightAddinProgramId, realm, communityTokenMint).publicKey;
      const ownerPda = this.getAssociatedLedgerAccount({ programId, poolId, owner, version: 3 });
      const ownerAccountInfo = yield connection.getAccountInfo(ownerPda);
      if (ownerAccountInfo === null) {
        throw Error("user is not staker");
      }
      const ownerInfo = FARM_LEDGER_LAYOUT_V3_2.decode(ownerAccountInfo.data);
      const mintAmount = ownerInfo.deposited.sub(ownerInfo.voteLockedBalance);
      if (mintAmount.eq(ZERO)) {
        throw Error("user do not has new stake amount");
      }
      const votingMint = getVotingTokenMint(programId, poolId).publicKey;
      const votingMintAuthority = getVotingMintAuthority(programId, poolId).publicKey;
      const { publicKey: voter, nonce: voterBump } = getVoterAddress(voteWeightAddinProgramId, registrar, owner);
      const voterVault = getATAAddress(voter, votingMint, TOKEN_PROGRAM_ID).publicKey;
      const { publicKey: voterWeightRecord, nonce: voterWeightRecordBump } = getVoterWeightRecordAddress(
        voteWeightAddinProgramId,
        registrar,
        owner
      );
      const tokenOwnerRecordAddress = getTokenOwnerRecordAddress(
        governanceProgramId,
        realm,
        communityTokenMint,
        owner
      ).publicKey;
      const instructions = [];
      const depositToken = getATAAddress(owner, votingMint, TOKEN_PROGRAM_ID).publicKey;
      const depositTokenAccountInfo = yield connection.getAccountInfo(depositToken);
      if (depositTokenAccountInfo === null) {
        instructions.push(
          Spl.makeCreateAssociatedTokenAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            mint: votingMint,
            associatedAccount: depositToken,
            owner,
            payer: owner,
            instructionsType: []
          })
        );
      }
      const voterAccountInfo = yield connection.getAccountInfo(voter);
      if (voterAccountInfo === null) {
        const createTokenOwnerRecodeIns = governanceCreateTokenOwnerRecord(
          governanceProgramId,
          realm,
          owner,
          communityTokenMint,
          owner,
          tokenOwnerRecordAddress
        );
        instructions.push(
          createTokenOwnerRecodeIns,
          voterStakeRegistryCreateVoter(
            voteWeightAddinProgramId,
            registrar,
            voter,
            voterWeightRecord,
            owner,
            owner,
            voterBump,
            voterWeightRecordBump
          )
        );
      }
      const { index: depositEntryIndex, isInit: depositEntryInit } = yield getDepositEntryIndex(
        connection,
        registrar,
        voter,
        votingMint
      );
      if (!depositEntryInit) {
        instructions.push(
          voterStakeRegistryCreateDepositEntry(
            voteWeightAddinProgramId,
            registrar,
            voter,
            voterVault,
            owner,
            owner,
            votingMint,
            depositEntryIndex,
            0,
            void 0,
            0,
            false
          )
        );
      }
      instructions.push(
        voterStakeRegistryDeposit(
          voteWeightAddinProgramId,
          registrar,
          voter,
          voterVault,
          depositToken,
          owner,
          ownerPda,
          poolId,
          votingMint,
          votingMintAuthority,
          programId,
          depositEntryIndex,
          mintAmount
        ),
        voterStakeRegistryUpdateVoterWeightRecord(voteWeightAddinProgramId, registrar, voter, voterWeightRecord)
      );
      return {
        address: {},
        innerTransaction: {
          instructions,
          signers: [],
          lookupTableAddress: [],
          instructionTypes: Array(instructions.length).fill(50 /* test */)
        }
      };
    });
  }
  static makeWithdrawTokenInstruction(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      governanceProgramId,
      voteWeightAddinProgramId,
      realm,
      communityTokenMint,
      owner,
      poolId
    }) {
      const registrar = getRegistrarAddress(voteWeightAddinProgramId, realm, communityTokenMint).publicKey;
      const ownerPda = this.getAssociatedLedgerAccount({ programId, poolId, owner, version: 3 });
      const ownerAccountInfo = yield connection.getAccountInfo(ownerPda);
      if (ownerAccountInfo === null) {
        throw Error("user is not staker");
      }
      const ownerInfo = FARM_LEDGER_LAYOUT_V3_2.decode(ownerAccountInfo.data);
      if (ownerInfo.voteLockedBalance.eq(ZERO)) {
        throw Error("user has vote locked balance = 0");
      }
      const votingMint = getVotingTokenMint(programId, poolId).publicKey;
      const votingMintAuthority = getVotingMintAuthority(programId, poolId).publicKey;
      const { publicKey: voter } = getVoterAddress(voteWeightAddinProgramId, registrar, owner);
      const voterVault = getATAAddress(voter, votingMint, TOKEN_PROGRAM_ID).publicKey;
      const { publicKey: voterWeightRecord } = getVoterWeightRecordAddress(voteWeightAddinProgramId, registrar, owner);
      const tokenOwnerRecordAddress = getTokenOwnerRecordAddress(
        governanceProgramId,
        realm,
        communityTokenMint,
        owner
      ).publicKey;
      const instructions = [];
      const { index: depositEntryIndex, isInit: depositEntryInit } = yield getDepositEntryIndex(
        connection,
        registrar,
        voter,
        votingMint
      );
      if (!depositEntryInit) throw Error("deposit entry index check error");
      instructions.push(
        voterStakeRegistryWithdraw(
          voteWeightAddinProgramId,
          registrar,
          voter,
          owner,
          tokenOwnerRecordAddress,
          voterWeightRecord,
          voterVault,
          getATAAddress(owner, votingMint, TOKEN_PROGRAM_ID).publicKey,
          ownerPda,
          poolId,
          votingMint,
          votingMintAuthority,
          programId,
          depositEntryIndex,
          ownerInfo.voteLockedBalance
        )
      );
      return {
        address: {},
        innerTransaction: {
          instructions,
          signers: [],
          lookupTableAddress: [],
          instructionTypes: Array(instructions.length).fill(50 /* test */)
        }
      };
    });
  }
};
function getDepositEntryIndex(connection, registrar, voter, voterMint) {
  return __async(this, null, function* () {
    const registrarAccountData = yield connection.getAccountInfo(registrar);
    if (registrarAccountData === null) throw Error("registrar info check error");
    const registrarData = VoterRegistrar.decode(registrarAccountData.data);
    const votingMintConfigIndex = registrarData.votingMints.findIndex((i) => i.mint.equals(voterMint));
    if (votingMintConfigIndex === -1) throw Error("find voter mint error");
    const voterAccountData = yield connection.getAccountInfo(voter);
    if (voterAccountData === null) return { index: votingMintConfigIndex, isInit: false };
    const voterData = Voter.decode(voterAccountData.data);
    const depositEntryIndex = voterData.deposits.findIndex(
      (i) => i.isUsed && i.votingMintConfigIdx === votingMintConfigIndex
    );
    if (depositEntryIndex === -1) return { index: votingMintConfigIndex, isInit: false };
    else return { index: depositEntryIndex, isInit: true };
  });
}

// src/farm/pool.ts
var MAINNET_FARM_POOLS = [
  {
    id: "AvbVWpBi2e4C9HPmZgShGdPoNydG4Yw8GJvG9HUcLgce",
    lp: MAINNET_LP_TOKENS.RAY_USDT_V4,
    version: 3
  },
  {
    id: "4EwbZo8BZXP5313z5A2H11MRBP15M5n6YxfmkjXESKAW",
    lp: MAINNET_SPL_TOKENS.RAY,
    version: 3
  },
  {
    id: "XnRBbNMf6YcWvC1u2vBXXuMcagmRBRLu1y84mpqnKwW",
    lp: MAINNET_LP_TOKENS.xCOPE_USDC_V4,
    version: 5
  },
  {
    id: "8xhjCzfzVcP79jE7jXR2xtNaSL6aJYoDRLVT9FMjpRTC",
    lp: MAINNET_LP_TOKENS.STEP_USDC_V4,
    version: 5
  },
  {
    id: "Ef1gD9JMzWF6PNw2uc4744zouh57GyWAeVTjHHbQ2nsu",
    lp: MAINNET_LP_TOKENS.MEDIA_USDC_V4,
    version: 5
  },
  {
    id: "AxVvbT9fDFEkmdLwKUJRY5HsG2RXAZbe1dRAgJ2bDDwg",
    lp: MAINNET_LP_TOKENS.COPE_USDC_V4,
    version: 5
  },
  {
    id: "D4pYuD4tbir9KBsb7Kr63v9e86JY2UoUZeFK9eHKQFZM",
    lp: MAINNET_LP_TOKENS.MER_USDC_V4,
    version: 5
  },
  {
    id: "BLy8KuRck5bcJkQdMDLSZnL1Ka4heAZSGiwTJfEfY727",
    lp: MAINNET_LP_TOKENS.ROPE_USDC_V4,
    version: 5
  },
  {
    id: "JAP8SFagJBm6vt2LoFGNeSJ1hKDZ2p3yXb3CvBx11How",
    lp: MAINNET_LP_TOKENS.ALEPH_USDC_V4,
    version: 5
  },
  {
    id: "7U8Z6TWQMtsMcHV2htALnF9VQonnD1MrVm17YtmGEGEw",
    lp: MAINNET_LP_TOKENS.TULIP_USDC_V4,
    version: 5
  },
  {
    id: "31QSh1TwgoA9GbvkgfEEwKEm11t8CR4KiQr6WCyJr7EN",
    lp: MAINNET_LP_TOKENS.SNY_USDC_V4,
    version: 5
  },
  {
    id: "EEe8b72w5q6T86nYRNJdFcY25tznPzrd1jGjuxZ7f9mX",
    lp: MAINNET_LP_TOKENS.BOP_RAY_V4,
    version: 5
  },
  {
    id: "5PVVwSqwzkCvuiKEZwWkM35ApBnoWqF8XopsVZjPwA8z",
    lp: MAINNET_LP_TOKENS.SLRS_USDC_V4,
    version: 5
  },
  {
    id: "Bw932pURVJRYjEJwRZGWjfUNpeyz18kjMNdb833eMxoj",
    lp: MAINNET_LP_TOKENS.SAMO_RAY_V4,
    version: 5
  },
  {
    id: "BRM5bdX2mjmFGg2RAent1Whd61o9asQD16BXsC6QvEni",
    lp: MAINNET_LP_TOKENS.LIKE_USDC_V4,
    version: 5
  },
  {
    id: "HUDr9BDaAGqi37xbQHzxCyXvfMCKPTPNF8g9c9bPu1Fu",
    lp: MAINNET_LP_TOKENS.RAY_SOL_V4,
    version: 3
  },
  {
    id: "CHYrUBX2RKX8iBg7gYTkccoGNBzP44LdaazMHCLcdEgS",
    lp: MAINNET_LP_TOKENS.RAY_USDC_V4,
    version: 3
  },
  {
    id: "B6fbnZZ7sbKHR18ffEDD5Nncgp54iKN1GbCgjTRdqhS1",
    lp: MAINNET_LP_TOKENS.RAY_ETH_V4,
    version: 3
  },
  {
    id: "5DFbcYNLLy5SJiBpCCDzNSs7cWCsUbYnCkLXzcPQiKnR",
    lp: MAINNET_LP_TOKENS.RAY_SRM_V4,
    version: 3
  },
  {
    id: "GzEDEkHSFFfxKMu3Toww1nrEjtbQGJKRPNRK1Pfd59Zn",
    lp: MAINNET_LP_TOKENS.MNGO_USDC_V4,
    version: 5
  },
  {
    id: "CM9XTJfXEHceGPXhmXxheR87Ng9CZ4jiBoTVQHhs9DVN",
    lp: MAINNET_LP_TOKENS.COPE_RAY_V4,
    version: 5
  },
  {
    id: "AMcVWK66iexwwCHn8drxywdNr2UgH3vmRzLXQFdErGmL",
    lp: MAINNET_LP_TOKENS.LIKE_RAY_V4,
    version: 5
  },
  {
    id: "DJfvL6srBht8XFMWYuuKHYGainqvwXyA5icVsDne3pwN",
    lp: MAINNET_LP_TOKENS.MEDIA_RAY_V4,
    version: 5
  },
  {
    id: "21xhrT4j8QnaBvj3QjhP5kZu8sXJMCE7hzHKGtWEkdKr",
    lp: MAINNET_LP_TOKENS.MER_RAY_V4,
    version: 5
  },
  {
    id: "J61AnYYSwjtJ4wDqEqqWSBuZbiR2SDDrtF7FFobutM6a",
    lp: MAINNET_LP_TOKENS.SLRS_RAY_V4,
    version: 5
  },
  {
    id: "JEC3P83x2GEijYDwXiksuh5H6YrQt5xW6MC2GDKkMoe",
    lp: MAINNET_LP_TOKENS.SNY_RAY_V4,
    version: 5
  },
  {
    id: "BmbG9hv5PazcW3rYWvatA6HpNPkozEdkWBiU64pZxuwr",
    lp: MAINNET_LP_TOKENS.TULIP_RAY_V4,
    version: 5
  },
  {
    id: "4wvZ9SwWaHKTpshQbCSKQoPosZp9KGwUzuQdESi39qPn",
    lp: MAINNET_LP_TOKENS.ALEPH_RAY_V4,
    version: 5
  },
  {
    id: "BnYoq5y2MoH4TsBHeEZrEPowhwebHxQq7nJW1vTjPTWu",
    lp: MAINNET_LP_TOKENS.RAY_SRM_V4,
    version: 5
  },
  {
    id: "93wRz2LeQ3TJoair827VTng62MjCzYDgJjG9Q5GmQ3Pd",
    lp: MAINNET_LP_TOKENS.ATLAS_USDC_V4,
    version: 5
  },
  {
    id: "7qcihXTsRW5wS5BgK7iuD84W43ECByoJP45R3hu2r6mF",
    lp: MAINNET_LP_TOKENS.POLIS_USDC_V4,
    version: 5
  },
  {
    id: "BHHhNLdJn69K1XPJcpcw4MBY3TPetpLxhj8s4K4ydsDV",
    lp: MAINNET_LP_TOKENS.ATLAS_RAY_V4,
    version: 5
  },
  {
    id: "HHm8Pgnzc56fTUYkicPv4DqGYp5fcPZFV1V1uhixSrMk",
    lp: MAINNET_LP_TOKENS.POLIS_RAY_V4,
    version: 5
  },
  {
    id: "8GBa1cK1NxevoxiRNK6YW9tWuo2xftcA3as9Cu4nhFL7",
    lp: MAINNET_LP_TOKENS.GRAPE_USDC_V4,
    version: 5
  },
  {
    id: "HzxveT6pUMwYByqnScvTbpUv4avzkUDrDpS9D7DToEry",
    lp: MAINNET_LP_TOKENS.LARIX_USDC_V4,
    version: 5
  },
  {
    id: "Fbwy4XWMjXuP1nXg4xph4RJ9E9twVXeknXokF38PVgG1",
    lp: MAINNET_LP_TOKENS.LARIX_RAY_V4,
    version: 5
  },
  {
    id: "5gzQgxaKAU13SZeffmjjE2y9HwMJ42FxQkqJhJ5nqHeh",
    lp: MAINNET_LP_TOKENS.stSOL_USDC_V4,
    version: 5
  },
  {
    id: "914jyHBQFiroKFVCpKkzjGSaZyr4gMwgxE7snbNfGjnL",
    lp: MAINNET_LP_TOKENS.BTC_mSOL_V4,
    version: 5
  },
  {
    id: "54vUWjEmg9wfCsZF7wwq2HJu5BU3cfDFAQQQgXPECcwE",
    lp: MAINNET_LP_TOKENS.ETH_mSOL_V4,
    version: 5
  },
  {
    id: "HxhxYASqdLcR6yehT9hB9HUpgcF1R2t9HtkHdngGZ2Dh",
    lp: MAINNET_LP_TOKENS.mSOL_USDT_V4,
    version: 5
  },
  {
    id: "97N6tPMVCrAunC9embwTcffye9xC95fA5y3LauhNZ444",
    lp: MAINNET_LP_TOKENS.MNDE_mSOL_V4,
    version: 5
  },
  {
    id: "DjtZxyFBgifzpaZEzfsWXogNX5zUCnTRXJqarGe9CiSv",
    lp: MAINNET_LP_TOKENS.mSOL_USDC_V4,
    version: 5
  },
  {
    id: "7wNhbTS6XQczXs52wcVmfiodRMPfycB3YaG52dWWY6SD",
    lp: MAINNET_LP_TOKENS.mSOL_RAY_V4,
    version: 5
  },
  {
    id: "CzKUrVbP7hH8EjcHNc55ZFW33rJyLQ2r52bxCzaGTpz",
    lp: MAINNET_LP_TOKENS.LIQ_USDC_V4,
    version: 5
  },
  {
    id: "5XdeFdcJoCAPMfgYndMPcsijFBKFp2cPSCjrCZzmpTE5",
    lp: MAINNET_LP_TOKENS.LIQ_RAY_V4,
    version: 5
  },
  {
    id: "Gf3qFzKnGvMCVMQZERW2Qso5uEYxd9B9kWZZHsrMmmHj",
    lp: MAINNET_LP_TOKENS.SYP_RAY_V4,
    version: 5
  },
  {
    id: "2pQQnoNpm5LoG6sZs5toNBXi4m1Pj3ExXdggPQYyiP2x",
    lp: MAINNET_LP_TOKENS.SYP_SOL_V4,
    version: 5
  },
  {
    id: "Byt2kL5qi45pMpdAsNNciKZ8HLp7oU5jizCbyARLtQJy",
    lp: MAINNET_LP_TOKENS.SYP_USDC_V4,
    version: 5
  },
  {
    id: "8W2TqGCiFiqR1JD4sbW8uTRjV2HvFjLhkZ2tAQTYE4Gc",
    lp: MAINNET_LP_TOKENS.WOOF_RAY_V4,
    version: 5
  },
  {
    id: "FgApVk6mASrkuWNxmsFvsaAYkFKqdiwMTvYZK36A2DaC",
    lp: MAINNET_LP_TOKENS.KIN_RAY_V4,
    version: 5
  },
  {
    id: "AwUDfg4NYbLQRAcFipoJwyZTpqNvw5v6C7EypryL12Y6",
    lp: MAINNET_LP_TOKENS.STARS_USDC_V4,
    version: 5
  },
  {
    id: "Gi3Z6TXeH1ZhCCbwg6oJL8SE4LcmxmGRNhhfA6NZhwTK",
    lp: MAINNET_LP_TOKENS.weWETH_SOL_V4,
    version: 5
  },
  {
    id: "8JJSdD1ca5SDtGCEm3yBbQKek2FvJ1EbNt9q2ET3E9Jt",
    lp: MAINNET_LP_TOKENS.weWETH_USDC_V4,
    version: 5
  },
  {
    id: "6X495xkPWkw9SQFYf7yL1K8QooZyaeEQ6u7yMWNNZxNV",
    lp: MAINNET_LP_TOKENS.weUNI_USDC_V4,
    version: 5
  },
  {
    id: "AuyqPBiY6sNUpH6jx415NGcdvNdYbkbYsyVabUqEVdkj",
    lp: MAINNET_LP_TOKENS.weSUSHI_USDC_V4,
    version: 5
  },
  {
    id: "7fe8QcJ6W2kHKL1h1HMYYJoGXz2LUcwCjkxX6MX35orK",
    lp: MAINNET_LP_TOKENS.weAXS_USDC_V4,
    version: 5
  },
  {
    id: "C8BjS9DGDvC2zS3n6fTvm1rjPbA33uZ7CAvEUZ3tg7aM",
    lp: MAINNET_LP_TOKENS.weDYDX_USDC_V4,
    version: 5
  },
  {
    id: "CZZnmfvSgNVUiDBG4wN2NNcaYbsKDN4kLsc3SN8DMw6i",
    lp: MAINNET_LP_TOKENS.weSHIB_USDC_V4,
    version: 5
  },
  {
    id: "FAKzZoGVCEBDRuHN4gDswAx7PsocCorDqH6dQaxnyorT",
    lp: MAINNET_LP_TOKENS.weSAND_USDC_V4,
    version: 5
  },
  {
    id: "EBS8tc4proQE2Fj6HxU4piiZP8oiDrvyJUijDCX7P7QN",
    lp: MAINNET_LP_TOKENS.weMANA_USDC_V4,
    version: 5
  },
  {
    id: "6AxxjJhAz6APspTQM4vVCHgfzEyZgBTCogJLdai7bXYE",
    lp: MAINNET_LP_TOKENS.wbWBNB_USDC_V4,
    version: 5
  },
  {
    id: "3HGPRHH3XFFu972MR1EdS65qc1nN9sM7miZtFTi6QcEd",
    lp: MAINNET_LP_TOKENS.wePEOPLE_USDC_V4,
    version: 5
  },
  {
    id: "27bysJaX5eu5Urb5kftR66otiVc6DKK7TnifKwnpNzYu",
    lp: MAINNET_LP_TOKENS.SRM_USDC_V4,
    version: 5
  },
  {
    id: "FDnxy4NkJVG3GNMMrtUZmUmoYeYE34YRDwCYTi1yBTM",
    lp: MAINNET_LP_TOKENS.CAVE_USDC_V4,
    version: 5
  },
  {
    id: "DDRNVVJBEXEemcprVVUcrTbYnR88JyN6jjT2ypgAQHC8",
    lp: MAINNET_LP_TOKENS.GENE_USDC_V4,
    version: 5
  },
  {
    id: "GVfLbXA3dpEHPvc4do9HvMZ8TACxm3x54BVrHPMEixcr",
    lp: MAINNET_LP_TOKENS.GENE_RAY_V4,
    version: 5
  },
  {
    id: "7NZ18KhsSdJBQkJEJwhEHfdaPRNdbMd17CMoxsKxavEo",
    lp: MAINNET_LP_TOKENS.CWAR_USDC_V4,
    version: 5
  },
  {
    id: "5Mdq5o3KKPyeVVBsbnivVk9qCATjfEQ22oysXVsd2DvJ",
    lp: MAINNET_LP_TOKENS.SONAR_USDC_V4,
    version: 5
  },
  {
    id: "7W8BKbMgcVpGYvTgEK758pJgDRZJ9WafKfgkV1XCkP33",
    lp: MAINNET_LP_TOKENS.APT_USDC_V4,
    version: 5
  },
  {
    id: "CgokwBwwdYsgo8hbUMtJ3GoNM3bVjvMcmaPrVvCw4sBi",
    lp: MAINNET_LP_TOKENS.SHILL_USDC_V4,
    version: 5
  },
  {
    id: "AWbmotuJS7NLBmra9ctbfVR1BnoHmiG1HGW6hm49TuRZ",
    lp: MAINNET_LP_TOKENS.DFL_USDC_V4,
    version: 5
  },
  {
    id: "665VvECKsLpXN4fLy8GYbyQpGJRNkxRx56X93U9FVSbv",
    lp: MAINNET_LP_TOKENS.BOKU_USDC_V4,
    version: 5
  },
  {
    id: "7yk1XUWmZpWMCoFpUT985z61UNTypyBGgZF3JpKgcwmL",
    lp: MAINNET_LP_TOKENS.MIMO_SOL_V4,
    version: 5
  },
  {
    id: "E5L4Bx3Lsif7bDb9XMWi5guHUt4kkYpbqQ4CbmnRjHs1",
    lp: MAINNET_LP_TOKENS.XTAG_USDC_V4,
    version: 5
  },
  {
    id: "HtvQ5AEvu8sDM7C1oB4r5fJ5E2Q1wsJ4TADwNMqR9ccF",
    lp: MAINNET_LP_TOKENS.TTT_USDC_V4,
    version: 5
  },
  {
    id: "GUzaohfNuFbBqQTnPgPSNciv3aUvriXYjQduRE3ZkqFw",
    lp: MAINNET_LP_TOKENS.SOL_USDC_V4,
    version: 5
  },
  {
    id: "5r878BSWPtoXgnqaeFJi7BCycKZ5CodBB2vS9SeiV8q",
    lp: MAINNET_LP_TOKENS.SOL_USDT_V4,
    version: 5
  },
  {
    id: "3J3SYLeFZWKnUCsrPzikw9bcD9vRs7YNGfmg7ZSg3tsK",
    lp: MAINNET_LP_TOKENS.RUN_USDC_V4,
    version: 5
  },
  {
    id: "BYmeWrwA4ixvJhNrxWzQsA3Fsz6EtUDJTo39WYZ6o1FS",
    lp: MAINNET_LP_TOKENS.CRWNY_RAY_V4,
    version: 5
  },
  {
    id: "6VNF4rF7ESUohzNeRf3aTg61dyFjbab749RGUHCTDFQL",
    lp: MAINNET_LP_TOKENS.CRWNY_USDC_V4,
    version: 5
  },
  {
    id: "7RQDGZ1cvHcREu211R35WSKHFjTxM5dmJHeFAWag29BA",
    lp: MAINNET_LP_TOKENS.REAL_USDC_V4,
    version: 5
  },
  {
    id: "ELovJ3jDKMiWhCUCdZzPfTeVmQwhj4cvYuGwS8FfhEtJ",
    lp: MAINNET_LP_TOKENS.BLOCK_USDC_V4,
    version: 5
  },
  {
    id: "36Rf8dzq5gy4Ew2bLQEgKoCKVTku4EJPLqFYG6mzFrkr",
    lp: MAINNET_LP_TOKENS.FRKT_SOL_V4,
    version: 5
  },
  {
    id: "HXpQJeAcBCKfGY6YhZgBocZGgV4xApPVK7r8CPXfvCin",
    lp: MAINNET_LP_TOKENS.FRKT_USDC_V4,
    version: 5
  },
  {
    id: "Eqn7unnxmneDuTuXQ7EAN1wBkHMFD4LgCCAkCdPA9KbV",
    lp: MAINNET_LP_TOKENS.MBS_USDC_V4,
    version: 5
  },
  {
    id: "DtU5pZB99rVtxe5qe5hQa2rRpw7poFiqaHvMAbPgT2TM",
    lp: MAINNET_LP_TOKENS.PRISM_USDC_V4,
    version: 5
  },
  {
    id: "Gue2c9J2aRtY3aJ1HEwabQznwg2MUt9d9kUyr6otujR",
    lp: MAINNET_LP_TOKENS.CHICKS_USDC_V4,
    version: 5
  },
  {
    id: "Ej7iBkW79EdF26RxaRQfGo58PqRdzHzRmE4C2e3z3dPY",
    lp: MAINNET_LP_TOKENS.MEAN_RAY_V4,
    version: 5
  },
  {
    id: "Bd1hAsMAghtCjK38Ut4m938Ep7zyEp2TydQ7G35nPvUj",
    lp: MAINNET_LP_TOKENS.TINY_USDC_V4,
    version: 5
  },
  {
    id: "2G7qTQzw3KXm7WEMJf2izqFQWh8CLZ1wFbQVP5qo3ME9",
    lp: MAINNET_LP_TOKENS.SCY_USDC_V4,
    version: 5
  }
];
var TESTNET_FARM_POOLS = [];
var DEVNET_FARM_POOLS = [];

// src/liquidity/layout.ts
var LIQUIDITY_STATE_LAYOUT_V4 = struct([
  u64("status"),
  u64("nonce"),
  u64("maxOrder"),
  u64("depth"),
  u64("baseDecimal"),
  u64("quoteDecimal"),
  u64("state"),
  u64("resetFlag"),
  u64("minSize"),
  u64("volMaxCutRatio"),
  u64("amountWaveRatio"),
  u64("baseLotSize"),
  u64("quoteLotSize"),
  u64("minPriceMultiplier"),
  u64("maxPriceMultiplier"),
  u64("systemDecimalValue"),
  u64("minSeparateNumerator"),
  u64("minSeparateDenominator"),
  u64("tradeFeeNumerator"),
  u64("tradeFeeDenominator"),
  u64("pnlNumerator"),
  u64("pnlDenominator"),
  u64("swapFeeNumerator"),
  u64("swapFeeDenominator"),
  u64("baseNeedTakePnl"),
  u64("quoteNeedTakePnl"),
  u64("quoteTotalPnl"),
  u64("baseTotalPnl"),
  u64("poolOpenTime"),
  u64("punishPcAmount"),
  u64("punishCoinAmount"),
  u64("orderbookToInitTime"),
  // u128('poolTotalDepositPc'),
  // u128('poolTotalDepositCoin'),
  u128("swapBaseInAmount"),
  u128("swapQuoteOutAmount"),
  u64("swapBase2QuoteFee"),
  u128("swapQuoteInAmount"),
  u128("swapBaseOutAmount"),
  u64("swapQuote2BaseFee"),
  // amm vault
  publicKey("baseVault"),
  publicKey("quoteVault"),
  // mint
  publicKey("baseMint"),
  publicKey("quoteMint"),
  publicKey("lpMint"),
  // market
  publicKey("openOrders"),
  publicKey("marketId"),
  publicKey("marketProgramId"),
  publicKey("targetOrders"),
  publicKey("withdrawQueue"),
  publicKey("lpVault"),
  publicKey("owner"),
  // true circulating supply without lock up
  u64("lpReserve"),
  seq2(u64(), 3, "padding")
]);
var LIQUIDITY_STATE_LAYOUT_V5 = struct([
  u64("accountType"),
  u64("status"),
  u64("nonce"),
  u64("maxOrder"),
  u64("depth"),
  u64("baseDecimal"),
  u64("quoteDecimal"),
  u64("state"),
  u64("resetFlag"),
  u64("minSize"),
  u64("volMaxCutRatio"),
  u64("amountWaveRatio"),
  u64("baseLotSize"),
  u64("quoteLotSize"),
  u64("minPriceMultiplier"),
  u64("maxPriceMultiplier"),
  u64("systemDecimalsValue"),
  u64("abortTradeFactor"),
  u64("priceTickMultiplier"),
  u64("priceTick"),
  // Fees
  u64("minSeparateNumerator"),
  u64("minSeparateDenominator"),
  u64("tradeFeeNumerator"),
  u64("tradeFeeDenominator"),
  u64("pnlNumerator"),
  u64("pnlDenominator"),
  u64("swapFeeNumerator"),
  u64("swapFeeDenominator"),
  // OutPutData
  u64("baseNeedTakePnl"),
  u64("quoteNeedTakePnl"),
  u64("quoteTotalPnl"),
  u64("baseTotalPnl"),
  u64("poolOpenTime"),
  u64("punishPcAmount"),
  u64("punishCoinAmount"),
  u64("orderbookToInitTime"),
  u128("swapBaseInAmount"),
  u128("swapQuoteOutAmount"),
  u128("swapQuoteInAmount"),
  u128("swapBaseOutAmount"),
  u64("swapQuote2BaseFee"),
  u64("swapBase2QuoteFee"),
  publicKey("baseVault"),
  publicKey("quoteVault"),
  publicKey("baseMint"),
  publicKey("quoteMint"),
  publicKey("lpMint"),
  publicKey("modelDataAccount"),
  publicKey("openOrders"),
  publicKey("marketId"),
  publicKey("marketProgramId"),
  publicKey("targetOrders"),
  publicKey("owner"),
  seq2(u64(), 64, "padding")
]);
var LIQUIDITY_VERSION_TO_STATE_LAYOUT = {
  4: LIQUIDITY_STATE_LAYOUT_V4,
  5: LIQUIDITY_STATE_LAYOUT_V5
};

// src/liquidity/liquidity.ts
import { PublicKey as PublicKey20, TransactionInstruction as TransactionInstruction10 } from "@solana/web3.js";
import BN16 from "bn.js";

// src/clmm/clmm.ts
import { TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID2 } from "@solana/spl-token";
import {
  Keypair as Keypair4,
  PublicKey as PublicKey16,
  SystemProgram as SystemProgram5
} from "@solana/web3.js";
import BN15 from "bn.js";
import Decimal3 from "decimal.js";

// src/clmm/instrument.ts
import { TOKEN_2022_PROGRAM_ID } from "@solana/spl-token";
import { TransactionInstruction as TransactionInstruction8 } from "@solana/web3.js";
var anchorDataBuf2 = {
  createPool: [233, 146, 209, 142, 207, 104, 64, 188],
  initReward: [95, 135, 192, 196, 242, 129, 230, 68],
  setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137],
  openPosition: [77, 184, 74, 214, 112, 86, 241, 199],
  closePosition: [123, 134, 81, 0, 49, 68, 98, 98],
  increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10],
  decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96],
  swap: [43, 4, 237, 11, 26, 201, 30, 98],
  // [248, 198, 158, 145, 225, 117, 135, 200],
  collectReward: [18, 237, 166, 197, 34, 16, 213, 144]
};
function createPoolInstruction(programId, poolId, poolCreator, ammConfigId, observationId, mintA, mintVaultA, mintProgramIdA, mintB, mintVaultB, mintProgramIdB, exTickArrayBitmap, sqrtPriceX64, startTime) {
  const dataLayout = struct([u128("sqrtPriceX64"), u64("startTime")]);
  const keys = [
    { pubkey: poolCreator, isSigner: true, isWritable: true },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: mintA, isSigner: false, isWritable: false },
    { pubkey: mintB, isSigner: false, isWritable: false },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: observationId, isSigner: false, isWritable: false },
    { pubkey: exTickArrayBitmap, isSigner: false, isWritable: true },
    { pubkey: mintProgramIdA, isSigner: false, isWritable: false },
    { pubkey: mintProgramIdB, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      sqrtPriceX64,
      startTime
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.createPool, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function openPositionFromLiquidityInstruction(programId, payer, poolId, positionNftOwner, positionNftMint, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerTokenAccountA, ownerTokenAccountB, tokenVaultA, tokenVaultB, tokenMintA, tokenMintB, tickLowerIndex, tickUpperIndex, tickArrayLowerStartIndex, tickArrayUpperStartIndex, liquidity, amountMaxA, amountMaxB, withMetadata, exTickArrayBitmap) {
  const dataLayout = struct([
    s32("tickLowerIndex"),
    s32("tickUpperIndex"),
    s32("tickArrayLowerStartIndex"),
    s32("tickArrayUpperStartIndex"),
    u128("liquidity"),
    u64("amountMaxA"),
    u64("amountMaxB"),
    bool2("withMetadata"),
    u82("optionBaseFlag"),
    bool2("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: positionNftOwner, isSigner: false, isWritable: false },
    { pubkey: positionNftMint, isSigner: true, isWritable: true },
    { pubkey: positionNftAccount, isSigner: false, isWritable: true },
    { pubkey: metadataAccount, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: tokenVaultA, isSigner: false, isWritable: true },
    { pubkey: tokenVaultB, isSigner: false, isWritable: true },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: tokenMintA, isSigner: false, isWritable: false },
    { pubkey: tokenMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      tickLowerIndex,
      tickUpperIndex,
      tickArrayLowerStartIndex,
      tickArrayUpperStartIndex,
      liquidity,
      amountMaxA,
      amountMaxB,
      withMetadata: withMetadata === "create",
      baseFlag: false,
      optionBaseFlag: 0
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.openPosition, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function openPositionFromBaseInstruction(programId, payer, poolId, positionNftOwner, positionNftMint, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerTokenAccountA, ownerTokenAccountB, tokenVaultA, tokenVaultB, tokenMintA, tokenMintB, tickLowerIndex, tickUpperIndex, tickArrayLowerStartIndex, tickArrayUpperStartIndex, withMetadata, base, baseAmount, otherAmountMax, exTickArrayBitmap) {
  const dataLayout = struct([
    s32("tickLowerIndex"),
    s32("tickUpperIndex"),
    s32("tickArrayLowerStartIndex"),
    s32("tickArrayUpperStartIndex"),
    u128("liquidity"),
    u64("amountMaxA"),
    u64("amountMaxB"),
    bool2("withMetadata"),
    u82("optionBaseFlag"),
    bool2("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: positionNftOwner, isSigner: false, isWritable: false },
    { pubkey: positionNftMint, isSigner: true, isWritable: true },
    { pubkey: positionNftAccount, isSigner: false, isWritable: true },
    { pubkey: metadataAccount, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: tokenVaultA, isSigner: false, isWritable: true },
    { pubkey: tokenVaultB, isSigner: false, isWritable: true },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: tokenMintA, isSigner: false, isWritable: false },
    { pubkey: tokenMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      tickLowerIndex,
      tickUpperIndex,
      tickArrayLowerStartIndex,
      tickArrayUpperStartIndex,
      liquidity: ZERO,
      amountMaxA: base === "MintA" ? baseAmount : otherAmountMax,
      amountMaxB: base === "MintA" ? otherAmountMax : baseAmount,
      withMetadata: withMetadata === "create",
      baseFlag: base === "MintA",
      optionBaseFlag: 1
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.openPosition, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function closePositionInstruction(programId, positionNftOwner, positionNftMint, positionNftAccount, personalPosition) {
  const dataLayout = struct([]);
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: true },
    { pubkey: positionNftMint, isSigner: false, isWritable: true },
    { pubkey: positionNftAccount, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({}, data);
  const aData = Buffer.from([...anchorDataBuf2.closePosition, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function increasePositionFromLiquidityInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, liquidity, amountMaxA, amountMaxB, exTickArrayBitmap) {
  const dataLayout = struct([
    u128("liquidity"),
    u64("amountMaxA"),
    u64("amountMaxB"),
    u82("optionBaseFlag"),
    bool2("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: false },
    { pubkey: positionNftAccount, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: mintMintA, isSigner: false, isWritable: false },
    { pubkey: mintMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      liquidity,
      amountMaxA,
      amountMaxB,
      optionBaseFlag: 0,
      baseFlag: false
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.increaseLiquidity, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function increasePositionFromBaseInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, base, baseAmount, otherAmountMax, exTickArrayBitmap) {
  const dataLayout = struct([
    u128("liquidity"),
    u64("amountMaxA"),
    u64("amountMaxB"),
    u82("optionBaseFlag"),
    bool2("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: false },
    { pubkey: positionNftAccount, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: mintMintA, isSigner: false, isWritable: false },
    { pubkey: mintMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      liquidity: ZERO,
      amountMaxA: base === "MintA" ? baseAmount : otherAmountMax,
      amountMaxB: base === "MintA" ? otherAmountMax : baseAmount,
      baseFlag: base === "MintA",
      optionBaseFlag: 1
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.increaseLiquidity, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function decreaseLiquidityInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, rewardAccounts, liquidity, amountMinA, amountMinB, exTickArrayBitmap) {
  const dataLayout = struct([u128("liquidity"), u64("amountMinA"), u64("amountMinB")]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : [],
    ...rewardAccounts.map((i) => [
      { pubkey: i.poolRewardVault, isSigner: false, isWritable: true },
      { pubkey: i.ownerRewardVault, isSigner: false, isWritable: true },
      { pubkey: i.rewardMint, isSigner: false, isWritable: false }
    ]).flat()
  ];
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: false },
    { pubkey: positionNftAccount, isSigner: false, isWritable: false },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: mintMintA, isSigner: false, isWritable: false },
    { pubkey: mintMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      liquidity,
      amountMinA,
      amountMinB
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.decreaseLiquidity, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function swapInstruction(programId, payer, poolId, ammConfigId, inputTokenAccount, outputTokenAccount, inputVault, outputVault, inputMint, outputMint, tickArray, observationId, amount, otherAmountThreshold, sqrtPriceLimitX64, isBaseInput, exTickArrayBitmap) {
  const dataLayout = struct([
    u64("amount"),
    u64("otherAmountThreshold"),
    u128("sqrtPriceLimitX64"),
    bool2("isBaseInput")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : [],
    ...tickArray.map((i) => ({ pubkey: i, isSigner: false, isWritable: true }))
  ];
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: false },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: inputTokenAccount, isSigner: false, isWritable: true },
    { pubkey: outputTokenAccount, isSigner: false, isWritable: true },
    { pubkey: inputVault, isSigner: false, isWritable: true },
    { pubkey: outputVault, isSigner: false, isWritable: true },
    { pubkey: observationId, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: inputMint, isSigner: false, isWritable: false },
    { pubkey: outputMint, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      amount,
      otherAmountThreshold,
      sqrtPriceLimitX64,
      isBaseInput
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.swap, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function initRewardInstruction(programId, payer, poolId, operationId, ammConfigId, ownerTokenAccount, rewardProgramId, rewardMint, rewardVault, openTime, endTime, emissionsPerSecondX64) {
  const dataLayout = struct([u64("openTime"), u64("endTime"), u128("emissionsPerSecondX64")]);
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: operationId, isSigner: false, isWritable: true },
    { pubkey: rewardMint, isSigner: false, isWritable: false },
    { pubkey: rewardVault, isSigner: false, isWritable: true },
    { pubkey: rewardProgramId, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      openTime: parseBigNumberish(openTime),
      endTime: parseBigNumberish(endTime),
      emissionsPerSecondX64
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.initReward, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function setRewardInstruction(programId, payer, poolId, operationId, ammConfigId, ownerTokenAccount, rewardVault, rewardMint, rewardIndex, openTime, endTime, emissionsPerSecondX64) {
  const dataLayout = struct([u82("rewardIndex"), u128("emissionsPerSecondX64"), u64("openTime"), u64("endTime")]);
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: operationId, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: rewardVault, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
    { pubkey: rewardMint, isSigner: false, isWritable: true }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      rewardIndex,
      emissionsPerSecondX64,
      openTime: parseBigNumberish(openTime),
      endTime: parseBigNumberish(endTime)
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.setRewardEmissions, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}
function collectRewardInstruction(programId, payer, poolId, ownerTokenAccount, rewardVault, rewardMint, rewardIndex) {
  const dataLayout = struct([u82("rewardIndex")]);
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: rewardVault, isSigner: false, isWritable: true },
    { pubkey: rewardMint, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      rewardIndex
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.collectReward, ...data]);
  return new TransactionInstruction8({
    keys,
    programId,
    data: aData
  });
}

// src/clmm/utils/tick.ts
import BN11 from "bn.js";

// src/clmm/utils/constants.ts
import BN10 from "bn.js";
var NEGATIVE_ONE = new BN10(-1);
var Q64 = new BN10(1).shln(64);
var Q128 = new BN10(1).shln(128);
var MaxU64 = Q64.sub(ONE);
var U64Resolution = 64;
var MaxUint128 = Q128.subn(1);
var MIN_TICK = -443636;
var MAX_TICK = -MIN_TICK;
var MIN_SQRT_PRICE_X64 = new BN10("4295048016");
var MAX_SQRT_PRICE_X64 = new BN10("79226673521066979257578248091");
var BIT_PRECISION = 16;
var LOG_B_2_X32 = "59543866431248";
var LOG_B_P_ERR_MARGIN_LOWER_X64 = "184467440737095516";
var LOG_B_P_ERR_MARGIN_UPPER_X64 = "15793534762490258745";
var FEE_RATE_DENOMINATOR = new BN10(10).pow(new BN10(6));
var Fee = /* @__PURE__ */ ((Fee3) => {
  Fee3[Fee3["rate_500"] = 500] = "rate_500";
  Fee3[Fee3["rate_3000"] = 3e3] = "rate_3000";
  Fee3[Fee3["rate_10000"] = 1e4] = "rate_10000";
  return Fee3;
})(Fee || {});
var TICK_SPACINGS = {
  [500 /* rate_500 */]: 10,
  [3e3 /* rate_3000 */]: 60,
  [1e4 /* rate_10000 */]: 200
};
var U64_IGNORE_RANGE = new BN10("18446744073700000000");

// src/clmm/utils/util.ts
function u16ToBytes(num) {
  const arr = new ArrayBuffer(2);
  const view = new DataView(arr);
  view.setUint16(0, num, false);
  return new Uint8Array(arr);
}
function i16ToBytes(num) {
  const arr = new ArrayBuffer(2);
  const view = new DataView(arr);
  view.setInt16(0, num, false);
  return new Uint8Array(arr);
}
function u32ToBytes(num) {
  const arr = new ArrayBuffer(4);
  const view = new DataView(arr);
  view.setUint32(0, num, false);
  return new Uint8Array(arr);
}
function i32ToBytes(num) {
  const arr = new ArrayBuffer(4);
  const view = new DataView(arr);
  view.setInt32(0, num, false);
  return new Uint8Array(arr);
}
function leadingZeros(bitNum, data) {
  let i = 0;
  for (let j = bitNum - 1; j >= 0; j--) {
    if (!data.testn(j)) {
      i++;
    } else {
      break;
    }
  }
  return i;
}
function trailingZeros(bitNum, data) {
  let i = 0;
  for (let j = 0; j < bitNum; j++) {
    if (!data.testn(j)) {
      i++;
    } else {
      break;
    }
  }
  return i;
}
function isZero(bitNum, data) {
  for (let i = 0; i < bitNum; i++) {
    if (data.testn(i)) return false;
  }
  return true;
}
function mostSignificantBit(bitNum, data) {
  if (isZero(bitNum, data)) return null;
  else return leadingZeros(bitNum, data);
}
function leastSignificantBit(bitNum, data) {
  if (isZero(bitNum, data)) return null;
  else return trailingZeros(bitNum, data);
}

// src/clmm/utils/pda.ts
var AMM_CONFIG_SEED = Buffer.from("amm_config", "utf8");
var POOL_SEED = Buffer.from("pool", "utf8");
var POOL_VAULT_SEED = Buffer.from("pool_vault", "utf8");
var POOL_REWARD_VAULT_SEED = Buffer.from("pool_reward_vault", "utf8");
var POSITION_SEED = Buffer.from("position", "utf8");
var TICK_ARRAY_SEED = Buffer.from("tick_array", "utf8");
var OPERATION_SEED = Buffer.from("operation", "utf8");
var POOL_TICK_ARRAY_BITMAP_SEED = Buffer.from("pool_tick_array_bitmap_extension", "utf8");
function getPdaAmmConfigId(programId, index) {
  return findProgramAddress([AMM_CONFIG_SEED, u16ToBytes(index)], programId);
}
function getPdaPoolId(programId, ammConfigId, mintA, mintB) {
  return findProgramAddress([POOL_SEED, ammConfigId.toBuffer(), mintA.toBuffer(), mintB.toBuffer()], programId);
}
function getPdaPoolVaultId(programId, poolId, vaultMint) {
  return findProgramAddress([POOL_VAULT_SEED, poolId.toBuffer(), vaultMint.toBuffer()], programId);
}
function getPdaPoolRewardVaulId(programId, poolId, rewardMint) {
  return findProgramAddress([POOL_REWARD_VAULT_SEED, poolId.toBuffer(), rewardMint.toBuffer()], programId);
}
function getPdaTickArrayAddress(programId, poolId, startIndex) {
  return findProgramAddress([TICK_ARRAY_SEED, poolId.toBuffer(), i32ToBytes(startIndex)], programId);
}
function getPdaProtocolPositionAddress(programId, poolId, tickLower, tickUpper) {
  return findProgramAddress([POSITION_SEED, poolId.toBuffer(), i32ToBytes(tickLower), i32ToBytes(tickUpper)], programId);
}
function getPdaPersonalPositionAddress(programId, nftMint) {
  return findProgramAddress([POSITION_SEED, nftMint.toBuffer()], programId);
}
function getPdaMetadataKey(mint) {
  return findProgramAddress(
    [Buffer.from("metadata", "utf8"), METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()],
    METADATA_PROGRAM_ID
  );
}
function getPdaOperationAccount(programId) {
  return findProgramAddress([OPERATION_SEED], programId);
}
function getPdaExBitmapAccount(programId, poolId) {
  return findProgramAddress([POOL_TICK_ARRAY_BITMAP_SEED, poolId.toBuffer()], programId);
}

// src/clmm/utils/tickQuery.ts
var FETCH_TICKARRAY_COUNT = 15;
var TickQuery = class _TickQuery {
  static getTickArrays(connection, programId, poolId, tickCurrent, tickSpacing, tickArrayBitmapArray, exTickArrayBitmap) {
    return __async(this, null, function* () {
      const tickArraysToFetch = [];
      const currentTickArrayStartIndex = TickUtils.getTickArrayStartIndexByTick(tickCurrent, tickSpacing);
      const startIndexArray = TickUtils.getInitializedTickArrayInRange(
        tickArrayBitmapArray,
        exTickArrayBitmap,
        tickSpacing,
        currentTickArrayStartIndex,
        Math.floor(FETCH_TICKARRAY_COUNT / 2)
      );
      for (let i = 0; i < startIndexArray.length; i++) {
        const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndexArray[i]);
        tickArraysToFetch.push(tickArrayAddress);
      }
      const fetchedTickArrays = (yield getMultipleAccountsInfo(connection, tickArraysToFetch)).map(
        (i) => i !== null ? TickArrayLayout.decode(i.data) : null
      );
      const tickArrayCache = {};
      for (let i = 0; i < tickArraysToFetch.length; i++) {
        const _info = fetchedTickArrays[i];
        if (_info === null) continue;
        tickArrayCache[_info.startTickIndex] = __spreadProps(__spreadValues({}, _info), {
          address: tickArraysToFetch[i]
        });
      }
      return tickArrayCache;
    });
  }
  static nextInitializedTick(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne) {
    let {
      initializedTick: nextTick,
      tickArrayAddress,
      tickArrayStartTickIndex
    } = this.nextInitializedTickInOneArray(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne);
    while (nextTick == void 0 || nextTick.liquidityGross.lten(0)) {
      tickArrayStartTickIndex = TickUtils.getNextTickArrayStartIndex(tickArrayStartTickIndex, tickSpacing, zeroForOne);
      if (this.checkIsValidStartIndex(tickArrayStartTickIndex, tickSpacing)) {
        throw new Error("No enough initialized tickArray");
      }
      const cachedTickArray = tickArrayCache[tickArrayStartTickIndex];
      if (cachedTickArray === void 0) continue;
      const {
        nextTick: _nextTick,
        tickArrayAddress: _tickArrayAddress,
        tickArrayStartTickIndex: _tickArrayStartTickIndex
      } = this.firstInitializedTickInOneArray(programId, poolId, cachedTickArray, zeroForOne);
      [nextTick, tickArrayAddress, tickArrayStartTickIndex] = [_nextTick, _tickArrayAddress, _tickArrayStartTickIndex];
    }
    if (nextTick == void 0) {
      throw new Error("No invaild tickArray cache");
    }
    return { nextTick, tickArrayAddress, tickArrayStartTickIndex };
  }
  static nextInitializedTickArray(tickIndex, tickSpacing, zeroForOne, tickArrayBitmap, exBitmapInfo) {
    const currentOffset = Math.floor(tickIndex / _TickQuery.tickCount(tickSpacing));
    const result = zeroForOne ? TickUtils.searchLowBitFromStart(tickArrayBitmap, exBitmapInfo, currentOffset - 1, 1, tickSpacing) : TickUtils.searchHightBitFromStart(tickArrayBitmap, exBitmapInfo, currentOffset + 1, 1, tickSpacing);
    return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
  }
  static firstInitializedTickInOneArray(programId, poolId, tickArray, zeroForOne) {
    let nextInitializedTick = void 0;
    if (zeroForOne) {
      let i = TICK_ARRAY_SIZE - 1;
      while (i >= 0) {
        const tickInArray = tickArray.ticks[i];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        i = i - 1;
      }
    } else {
      let i = 0;
      while (i < TICK_ARRAY_SIZE) {
        const tickInArray = tickArray.ticks[i];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        i = i + 1;
      }
    }
    const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, tickArray.startTickIndex);
    return { nextTick: nextInitializedTick, tickArrayAddress, tickArrayStartTickIndex: tickArray.startTickIndex };
  }
  static nextInitializedTickInOneArray(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne) {
    const startIndex = TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
    let tickPositionInArray = Math.floor((tickIndex - startIndex) / tickSpacing);
    const cachedTickArray = tickArrayCache[startIndex];
    if (cachedTickArray == void 0) {
      return {
        initializedTick: void 0,
        tickArrayAddress: void 0,
        tickArrayStartTickIndex: startIndex
      };
    }
    let nextInitializedTick = void 0;
    if (zeroForOne) {
      while (tickPositionInArray >= 0) {
        const tickInArray = cachedTickArray.ticks[tickPositionInArray];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        tickPositionInArray = tickPositionInArray - 1;
      }
    } else {
      tickPositionInArray = tickPositionInArray + 1;
      while (tickPositionInArray < TICK_ARRAY_SIZE) {
        const tickInArray = cachedTickArray.ticks[tickPositionInArray];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        tickPositionInArray = tickPositionInArray + 1;
      }
    }
    const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndex);
    return {
      initializedTick: nextInitializedTick,
      tickArrayAddress,
      tickArrayStartTickIndex: cachedTickArray.startTickIndex
    };
  }
  static getArrayStartIndex(tickIndex, tickSpacing) {
    const ticksInArray = this.tickCount(tickSpacing);
    const start = Math.floor(tickIndex / ticksInArray);
    return start * ticksInArray;
  }
  static checkIsValidStartIndex(tickIndex, tickSpacing) {
    if (TickUtils.checkIsOutOfBoundary(tickIndex)) {
      if (tickIndex > MAX_TICK) {
        return false;
      }
      const minStartIndex = TickUtils.getTickArrayStartIndexByTick(MIN_TICK, tickSpacing);
      return tickIndex == minStartIndex;
    }
    return tickIndex % this.tickCount(tickSpacing) == 0;
  }
  static tickCount(tickSpacing) {
    return TICK_ARRAY_SIZE * tickSpacing;
  }
};

// src/clmm/utils/tick.ts
var TICK_ARRAY_SIZE = 60;
var TICK_ARRAY_BITMAP_SIZE = 512;
var TickUtils = class _TickUtils {
  static getTickArrayAddressByTick(programId, poolId, tickIndex, tickSpacing) {
    const startIndex = _TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
    const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndex);
    return tickArrayAddress;
  }
  static getTickOffsetInArray(tickIndex, tickSpacing) {
    if (tickIndex % tickSpacing != 0) {
      throw new Error("tickIndex % tickSpacing not equal 0");
    }
    const startTickIndex = _TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
    const offsetInArray = Math.floor((tickIndex - startTickIndex) / tickSpacing);
    if (offsetInArray < 0 || offsetInArray >= TICK_ARRAY_SIZE) {
      throw new Error("tick offset in array overflow");
    }
    return offsetInArray;
  }
  static getTickArrayBitIndex(tickIndex, tickSpacing) {
    const ticksInArray = TickQuery.tickCount(tickSpacing);
    let startIndex = tickIndex / ticksInArray;
    if (tickIndex < 0 && tickIndex % ticksInArray != 0) {
      startIndex = Math.ceil(startIndex) - 1;
    } else {
      startIndex = Math.floor(startIndex);
    }
    return startIndex;
  }
  static getTickArrayStartIndexByTick(tickIndex, tickSpacing) {
    return this.getTickArrayBitIndex(tickIndex, tickSpacing) * TickQuery.tickCount(tickSpacing);
  }
  static getTickArrayOffsetInBitmapByTick(tick, tickSpacing) {
    const multiplier = tickSpacing * TICK_ARRAY_SIZE;
    const compressed = Math.floor(tick / multiplier) + 512;
    return Math.abs(compressed);
  }
  static checkTickArrayIsInitialized(bitmap, tick, tickSpacing) {
    const multiplier = tickSpacing * TICK_ARRAY_SIZE;
    const compressed = Math.floor(tick / multiplier) + 512;
    const bitPos = Math.abs(compressed);
    return {
      isInitialized: bitmap.testn(bitPos),
      startIndex: (bitPos - 512) * multiplier
    };
  }
  static getNextTickArrayStartIndex(lastTickArrayStartIndex, tickSpacing, zeroForOne) {
    return zeroForOne ? lastTickArrayStartIndex - tickSpacing * TICK_ARRAY_SIZE : lastTickArrayStartIndex + tickSpacing * TICK_ARRAY_SIZE;
  }
  static mergeTickArrayBitmap(bns) {
    let b = new BN11(0);
    for (let i = 0; i < bns.length; i++) {
      b = b.add(bns[i].shln(64 * i));
    }
    return b;
  }
  static getInitializedTickArrayInRange(tickArrayBitmap, exTickArrayBitmap, tickSpacing, tickArrayStartIndex, expectedCount) {
    const tickArrayOffset = Math.floor(tickArrayStartIndex / (tickSpacing * TICK_ARRAY_SIZE));
    return [
      // find right of currenct offset
      ..._TickUtils.searchLowBitFromStart(
        tickArrayBitmap,
        exTickArrayBitmap,
        tickArrayOffset - 1,
        expectedCount,
        tickSpacing
      ),
      // find left of current offset
      ..._TickUtils.searchHightBitFromStart(
        tickArrayBitmap,
        exTickArrayBitmap,
        tickArrayOffset,
        expectedCount,
        tickSpacing
      )
    ];
  }
  static getAllInitializedTickArrayStartIndex(tickArrayBitmap, exTickArrayBitmap, tickSpacing) {
    return _TickUtils.searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, 0, TICK_ARRAY_BITMAP_SIZE, tickSpacing);
  }
  static getAllInitializedTickArrayInfo(programId, poolId, tickArrayBitmap, exTickArrayBitmap, tickSpacing) {
    const result = [];
    const allInitializedTickArrayIndex = _TickUtils.getAllInitializedTickArrayStartIndex(
      tickArrayBitmap,
      exTickArrayBitmap,
      tickSpacing
    );
    for (const startIndex of allInitializedTickArrayIndex) {
      const { publicKey: address } = getPdaTickArrayAddress(programId, poolId, startIndex);
      result.push({
        tickArrayStartIndex: startIndex,
        tickArrayAddress: address
      });
    }
    return result;
  }
  static getAllInitializedTickInTickArray(tickArray) {
    return tickArray.ticks.filter((i) => i.liquidityGross.gtn(0));
  }
  static searchLowBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
    const tickArrayBitmaps = [
      ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
      tickArrayBitmap.slice(0, 8),
      tickArrayBitmap.slice(8, 16),
      ...exTickArrayBitmap.positiveTickArrayBitmap
    ].map((i) => _TickUtils.mergeTickArrayBitmap(i));
    const result = [];
    while (currentTickArrayBitStartIndex >= -7680) {
      const arrayIndex = Math.floor((currentTickArrayBitStartIndex + 7680) / 512);
      const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
      if (tickArrayBitmaps[arrayIndex].testn(searchIndex)) result.push(currentTickArrayBitStartIndex);
      currentTickArrayBitStartIndex--;
      if (result.length === expectedCount) break;
    }
    const tickCount = TickQuery.tickCount(tickSpacing);
    return result.map((i) => i * tickCount);
  }
  static searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
    const tickArrayBitmaps = [
      ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
      tickArrayBitmap.slice(0, 8),
      tickArrayBitmap.slice(8, 16),
      ...exTickArrayBitmap.positiveTickArrayBitmap
    ].map((i) => _TickUtils.mergeTickArrayBitmap(i));
    const result = [];
    while (currentTickArrayBitStartIndex < 7680) {
      const arrayIndex = Math.floor((currentTickArrayBitStartIndex + 7680) / 512);
      const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
      if (tickArrayBitmaps[arrayIndex].testn(searchIndex)) result.push(currentTickArrayBitStartIndex);
      currentTickArrayBitStartIndex++;
      if (result.length === expectedCount) break;
    }
    const tickCount = TickQuery.tickCount(tickSpacing);
    return result.map((i) => i * tickCount);
  }
  static checkIsOutOfBoundary(tick) {
    return tick < MIN_TICK || tick > MAX_TICK;
  }
  static nextInitTick(tickArrayCurrent, currentTickIndex, tickSpacing, zeroForOne, t) {
    const currentTickArrayStartIndex = TickQuery.getArrayStartIndex(currentTickIndex, tickSpacing);
    if (currentTickArrayStartIndex != tickArrayCurrent.startTickIndex) {
      return null;
    }
    let offsetInArray = Math.floor((currentTickIndex - tickArrayCurrent.startTickIndex) / tickSpacing);
    if (zeroForOne) {
      while (offsetInArray >= 0) {
        if (tickArrayCurrent.ticks[offsetInArray].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[offsetInArray];
        }
        offsetInArray = offsetInArray - 1;
      }
    } else {
      if (!t) offsetInArray = offsetInArray + 1;
      while (offsetInArray < TICK_ARRAY_SIZE) {
        if (tickArrayCurrent.ticks[offsetInArray].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[offsetInArray];
        }
        offsetInArray = offsetInArray + 1;
      }
    }
    return null;
  }
  static firstInitializedTick(tickArrayCurrent, zeroForOne) {
    if (zeroForOne) {
      let i = TICK_ARRAY_SIZE - 1;
      while (i >= 0) {
        if (tickArrayCurrent.ticks[i].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[i];
        }
        i = i - 1;
      }
    } else {
      let i = 0;
      while (i < TICK_ARRAY_SIZE) {
        if (tickArrayCurrent.ticks[i].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[i];
        }
        i = i + 1;
      }
    }
    throw Error(`firstInitializedTick check error: ${tickArrayCurrent} - ${zeroForOne}`);
  }
};

// src/clmm/utils/tickarrayBitmap.ts
var EXTENSION_TICKARRAY_BITMAP_SIZE = 14;
var TickArrayBitmap = class {
  static maxTickInTickarrayBitmap(tickSpacing) {
    return tickSpacing * TICK_ARRAY_SIZE * TICK_ARRAY_BITMAP_SIZE;
  }
  static getBitmapTickBoundary(tickarrayStartIndex, tickSpacing) {
    const ticksInOneBitmap = this.maxTickInTickarrayBitmap(tickSpacing);
    let m = Math.floor(Math.abs(tickarrayStartIndex) / ticksInOneBitmap);
    if (tickarrayStartIndex < 0 && Math.abs(tickarrayStartIndex) % ticksInOneBitmap != 0) m += 1;
    const minValue = ticksInOneBitmap * m;
    return tickarrayStartIndex < 0 ? { minValue: -minValue, maxValue: -minValue + ticksInOneBitmap } : { minValue, maxValue: minValue + ticksInOneBitmap };
  }
  static nextInitializedTickArrayStartIndex(bitMap, lastTickArrayStartIndex, tickSpacing, zeroForOne) {
    if (!TickQuery.checkIsValidStartIndex(lastTickArrayStartIndex, tickSpacing))
      throw Error("nextInitializedTickArrayStartIndex check error");
    const tickBoundary = this.maxTickInTickarrayBitmap(tickSpacing);
    const nextTickArrayStartIndex = zeroForOne ? lastTickArrayStartIndex - TickQuery.tickCount(tickSpacing) : lastTickArrayStartIndex + TickQuery.tickCount(tickSpacing);
    if (nextTickArrayStartIndex < -tickBoundary || nextTickArrayStartIndex >= tickBoundary) {
      return { isInit: false, tickIndex: lastTickArrayStartIndex };
    }
    const multiplier = tickSpacing * TICK_ARRAY_SIZE;
    let compressed = nextTickArrayStartIndex / multiplier + 512;
    if (nextTickArrayStartIndex < 0 && nextTickArrayStartIndex % multiplier != 0) {
      compressed--;
    }
    const bitPos = Math.abs(compressed);
    if (zeroForOne) {
      const offsetBitMap = bitMap.shln(1024 - bitPos - 1);
      const nextBit = mostSignificantBit(1024, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = (bitPos - nextBit - 512) * multiplier;
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: -tickBoundary };
      }
    } else {
      const offsetBitMap = bitMap.shrn(bitPos);
      const nextBit = leastSignificantBit(1024, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = (bitPos + nextBit - 512) * multiplier;
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: tickBoundary - TickQuery.tickCount(tickSpacing) };
      }
    }
  }
};
var TickArrayBitmapExtension = class {
  static getBitmapOffset(tickIndex, tickSpacing) {
    if (!TickQuery.checkIsValidStartIndex(tickIndex, tickSpacing)) {
      throw new Error("No enough initialized tickArray");
    }
    this.checkExtensionBoundary(tickIndex, tickSpacing);
    const ticksInOneBitmap = TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    let offset2 = Math.floor(Math.abs(tickIndex) / ticksInOneBitmap) - 1;
    if (tickIndex < 0 && Math.abs(tickIndex) % ticksInOneBitmap === 0) offset2--;
    return offset2;
  }
  static getBitmap(tickIndex, tickSpacing, tickArrayBitmapExtension) {
    const offset2 = this.getBitmapOffset(tickIndex, tickSpacing);
    if (tickIndex < 0) {
      return { offset: offset2, tickarrayBitmap: tickArrayBitmapExtension.negativeTickArrayBitmap[offset2] };
    } else {
      return { offset: offset2, tickarrayBitmap: tickArrayBitmapExtension.positiveTickArrayBitmap[offset2] };
    }
  }
  static checkExtensionBoundary(tickIndex, tickSpacing) {
    const { positiveTickBoundary, negativeTickBoundary } = this.extensionTickBoundary(tickSpacing);
    if (tickIndex >= negativeTickBoundary && tickIndex < positiveTickBoundary) {
      throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
    }
  }
  static extensionTickBoundary(tickSpacing) {
    const positiveTickBoundary = TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    const negativeTickBoundary = -positiveTickBoundary;
    if (MAX_TICK <= positiveTickBoundary)
      throw Error(`extensionTickBoundary check error: ${MAX_TICK}, ${positiveTickBoundary}`);
    if (negativeTickBoundary <= MIN_TICK)
      throw Error(`extensionTickBoundary check error: ${negativeTickBoundary}, ${MIN_TICK}`);
    return { positiveTickBoundary, negativeTickBoundary };
  }
  static checkTickArrayIsInit(tickArrayStartIndex, tickSpacing, tickArrayBitmapExtension) {
    const { tickarrayBitmap } = this.getBitmap(tickArrayStartIndex, tickSpacing, tickArrayBitmapExtension);
    const tickArrayOffsetInBitmap = this.tickArrayOffsetInBitmap(tickArrayStartIndex, tickSpacing);
    return {
      isInitialized: TickUtils.mergeTickArrayBitmap(tickarrayBitmap).testn(tickArrayOffsetInBitmap),
      startIndex: tickArrayStartIndex
    };
  }
  static nextInitializedTickArrayFromOneBitmap(lastTickArrayStartIndex, tickSpacing, zeroForOne, tickArrayBitmapExtension) {
    const multiplier = TickQuery.tickCount(tickSpacing);
    const nextTickArrayStartIndex = zeroForOne ? lastTickArrayStartIndex - multiplier : lastTickArrayStartIndex + multiplier;
    const minTickArrayStartIndex = TickQuery.getArrayStartIndex(MIN_TICK, tickSpacing);
    const maxTickArrayStartIndex = TickQuery.getArrayStartIndex(MAX_TICK, tickSpacing);
    if (nextTickArrayStartIndex < minTickArrayStartIndex || nextTickArrayStartIndex > maxTickArrayStartIndex) {
      return {
        isInit: false,
        tickIndex: nextTickArrayStartIndex
      };
    }
    const { tickarrayBitmap } = this.getBitmap(nextTickArrayStartIndex, tickSpacing, tickArrayBitmapExtension);
    return this.nextInitializedTickArrayInBitmap(tickarrayBitmap, nextTickArrayStartIndex, tickSpacing, zeroForOne);
  }
  static nextInitializedTickArrayInBitmap(tickarrayBitmap, nextTickArrayStartIndex, tickSpacing, zeroForOne) {
    const { minValue: bitmapMinTickBoundary, maxValue: bitmapMaxTickBoundary } = TickArrayBitmap.getBitmapTickBoundary(
      nextTickArrayStartIndex,
      tickSpacing
    );
    const tickArrayOffsetInBitmap = this.tickArrayOffsetInBitmap(nextTickArrayStartIndex, tickSpacing);
    if (zeroForOne) {
      const offsetBitMap = TickUtils.mergeTickArrayBitmap(tickarrayBitmap).shln(
        TICK_ARRAY_BITMAP_SIZE - 1 - tickArrayOffsetInBitmap
      );
      const nextBit = isZero(512, offsetBitMap) ? null : leadingZeros(512, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = nextTickArrayStartIndex - nextBit * TickQuery.tickCount(tickSpacing);
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: bitmapMinTickBoundary };
      }
    } else {
      const offsetBitMap = TickUtils.mergeTickArrayBitmap(tickarrayBitmap).shrn(tickArrayOffsetInBitmap);
      const nextBit = isZero(512, offsetBitMap) ? null : trailingZeros(512, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = nextTickArrayStartIndex + nextBit * TickQuery.tickCount(tickSpacing);
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: bitmapMaxTickBoundary - TickQuery.tickCount(tickSpacing) };
      }
    }
  }
  static tickArrayOffsetInBitmap(tickArrayStartIndex, tickSpacing) {
    const m = Math.abs(tickArrayStartIndex) % TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    let tickArrayOffsetInBitmap = Math.floor(m / TickQuery.tickCount(tickSpacing));
    if (tickArrayStartIndex < 0 && m != 0) {
      tickArrayOffsetInBitmap = TICK_ARRAY_BITMAP_SIZE - tickArrayOffsetInBitmap;
    }
    return tickArrayOffsetInBitmap;
  }
};

// src/clmm/layout.ts
var AmmConfigLayout = struct([
  blob(8),
  u82("bump"),
  u16("index"),
  publicKey(""),
  u322("protocolFeeRate"),
  u322("tradeFeeRate"),
  u16("tickSpacing"),
  u322("fundFeeRate"),
  seq2(u322(), 1, "padding"),
  publicKey("fundOwner"),
  seq2(u64(), 3, "padding")
]);
var ObservationLayout = struct([
  u322("blockTimestamp"),
  u128("sqrtPriceX64"),
  u128("cumulativeTimePriceX64"),
  seq2(u128(), 1, "")
]);
var ObservationInfoLayout = struct([
  blob(8),
  bool2("initialized"),
  publicKey("poolId"),
  seq2(ObservationLayout, 1e3, "observations"),
  seq2(u128(), 5, "")
]);
var RewardInfo = struct([
  u82("rewardState"),
  u64("openTime"),
  u64("endTime"),
  u64("lastUpdateTime"),
  u128("emissionsPerSecondX64"),
  u64("rewardTotalEmissioned"),
  u64("rewardClaimed"),
  publicKey("tokenMint"),
  publicKey("tokenVault"),
  publicKey("creator"),
  u128("rewardGrowthGlobalX64")
]);
var PoolInfoLayout = struct([
  blob(8),
  u82("bump"),
  publicKey("ammConfig"),
  publicKey("creator"),
  publicKey("mintA"),
  publicKey("mintB"),
  publicKey("vaultA"),
  publicKey("vaultB"),
  publicKey("observationId"),
  u82("mintDecimalsA"),
  u82("mintDecimalsB"),
  u16("tickSpacing"),
  u128("liquidity"),
  u128("sqrtPriceX64"),
  s32("tickCurrent"),
  u16("observationIndex"),
  u16("observationUpdateDuration"),
  u128("feeGrowthGlobalX64A"),
  u128("feeGrowthGlobalX64B"),
  u64("protocolFeesTokenA"),
  u64("protocolFeesTokenB"),
  u128("swapInAmountTokenA"),
  u128("swapOutAmountTokenB"),
  u128("swapInAmountTokenB"),
  u128("swapOutAmountTokenA"),
  u82("status"),
  seq2(u82(), 7, ""),
  seq2(RewardInfo, 3, "rewardInfos"),
  seq2(u64(), 16, "tickArrayBitmap"),
  u64("totalFeesTokenA"),
  u64("totalFeesClaimedTokenA"),
  u64("totalFeesTokenB"),
  u64("totalFeesClaimedTokenB"),
  u64("fundFeesTokenA"),
  u64("fundFeesTokenB"),
  u64("startTime"),
  seq2(u64(), 15 * 4 - 3, "padding")
]);
var PositionRewardInfoLayout = struct([u128("growthInsideLastX64"), u64("rewardAmountOwed")]);
var PositionInfoLayout = struct([
  blob(8),
  u82("bump"),
  publicKey("nftMint"),
  publicKey("poolId"),
  s32("tickLower"),
  s32("tickUpper"),
  u128("liquidity"),
  u128("feeGrowthInsideLastX64A"),
  u128("feeGrowthInsideLastX64B"),
  u64("tokenFeesOwedA"),
  u64("tokenFeesOwedB"),
  seq2(PositionRewardInfoLayout, 3, "rewardInfos"),
  seq2(u64(), 8, "")
]);
var ProtocolPositionLayout = struct([
  blob(8),
  u82("bump"),
  publicKey("poolId"),
  s32("tickLowerIndex"),
  s32("tickUpperIndex"),
  u128("liquidity"),
  u128("feeGrowthInsideLastX64A"),
  u128("feeGrowthInsideLastX64B"),
  u64("tokenFeesOwedA"),
  u64("tokenFeesOwedB"),
  seq2(u128(), 3, "rewardGrowthInside"),
  seq2(u64(), 8, "")
]);
var TickLayout = struct([
  s32("tick"),
  i128("liquidityNet"),
  u128("liquidityGross"),
  u128("feeGrowthOutsideX64A"),
  u128("feeGrowthOutsideX64B"),
  seq2(u128(), 3, "rewardGrowthsOutsideX64"),
  seq2(u322(), 13, "")
]);
var TickArrayLayout = struct([
  blob(8),
  publicKey("poolId"),
  s32("startTickIndex"),
  seq2(TickLayout, TICK_ARRAY_SIZE, "ticks"),
  u82("initializedTickCount"),
  seq2(u82(), 115, "")
]);
var OperationLayout = struct([blob(329), seq2(publicKey(), 100, "whitelistMints")]);
var TickArrayBitmapExtensionLayout = struct([
  blob(8),
  publicKey("poolId"),
  seq2(seq2(u64(), 8), EXTENSION_TICKARRAY_BITMAP_SIZE, "positiveTickArrayBitmap"),
  seq2(seq2(u64(), 8), EXTENSION_TICKARRAY_BITMAP_SIZE, "negativeTickArrayBitmap")
]);

// src/clmm/utils/math.ts
import BN13 from "bn.js";
import Decimal2 from "decimal.js";

// src/clmm/utils/pool.ts
import { PublicKey as PublicKey15 } from "@solana/web3.js";
import BN12 from "bn.js";
var PoolUtils = class _PoolUtils {
  static getOutputAmountAndRemainAccounts(poolInfo, tickArrayCache, inputTokenMint, inputAmount, sqrtPriceLimitX64, catchLiquidityInsufficient = false) {
    const zeroForOne = inputTokenMint.equals(poolInfo.mintA.mint);
    const allNeededAccounts = [];
    const {
      isExist,
      startIndex: firstTickArrayStartIndex,
      nextAccountMeta
    } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
    if (!isExist || firstTickArrayStartIndex === void 0 || !nextAccountMeta) throw new Error("Invalid tick array");
    try {
      const preTick = this.preInitializedTickArrayStartIndex(poolInfo, zeroForOne);
      if (preTick.isExist) {
        const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
        allNeededAccounts.push(address);
      }
    } catch (e) {
    }
    allNeededAccounts.push(nextAccountMeta);
    const {
      allTrade,
      amountSpecifiedRemaining,
      amountCalculated: outputAmount,
      accounts: reaminAccounts,
      sqrtPriceX64: executionPrice,
      feeAmount
    } = SwapMath.swapCompute(
      poolInfo.programId,
      poolInfo.id,
      tickArrayCache,
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      zeroForOne,
      poolInfo.ammConfig.tradeFeeRate,
      poolInfo.liquidity,
      poolInfo.tickCurrent,
      poolInfo.tickSpacing,
      poolInfo.sqrtPriceX64,
      inputAmount,
      firstTickArrayStartIndex,
      sqrtPriceLimitX64,
      catchLiquidityInsufficient
    );
    allNeededAccounts.push(...reaminAccounts);
    return {
      allTrade,
      realTradeAmountIn: inputAmount.sub(amountSpecifiedRemaining),
      expectedAmountOut: outputAmount.mul(NEGATIVE_ONE),
      remainingAccounts: allNeededAccounts,
      executionPrice,
      feeAmount
    };
  }
  static getInputAmountAndRemainAccounts(poolInfo, tickArrayCache, outputTokenMint, outputAmount, sqrtPriceLimitX64) {
    const zeroForOne = outputTokenMint.equals(poolInfo.mintB.mint);
    const allNeededAccounts = [];
    const {
      isExist,
      startIndex: firstTickArrayStartIndex,
      nextAccountMeta
    } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
    if (!isExist || firstTickArrayStartIndex === void 0 || !nextAccountMeta) throw new Error("Invalid tick array");
    try {
      const preTick = this.preInitializedTickArrayStartIndex(poolInfo, zeroForOne);
      if (preTick.isExist) {
        const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
        allNeededAccounts.push(address);
      }
    } catch (e) {
    }
    allNeededAccounts.push(nextAccountMeta);
    const {
      amountCalculated: inputAmount,
      accounts: reaminAccounts,
      sqrtPriceX64: executionPrice,
      feeAmount
    } = SwapMath.swapCompute(
      poolInfo.programId,
      poolInfo.id,
      tickArrayCache,
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      zeroForOne,
      poolInfo.ammConfig.tradeFeeRate,
      poolInfo.liquidity,
      poolInfo.tickCurrent,
      poolInfo.tickSpacing,
      poolInfo.sqrtPriceX64,
      outputAmount.mul(NEGATIVE_ONE),
      firstTickArrayStartIndex,
      sqrtPriceLimitX64
    );
    allNeededAccounts.push(...reaminAccounts);
    return { expectedAmountIn: inputAmount, remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
  }
  static getFirstInitializedTickArray(poolInfo, zeroForOne) {
    const { isInitialized, startIndex } = _PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
      poolInfo.tickCurrent
    ]) ? TickArrayBitmapExtension.checkTickArrayIsInit(
      TickQuery.getArrayStartIndex(poolInfo.tickCurrent, poolInfo.tickSpacing),
      poolInfo.tickSpacing,
      poolInfo.exBitmapInfo
    ) : TickUtils.checkTickArrayIsInitialized(
      TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap),
      poolInfo.tickCurrent,
      poolInfo.tickSpacing
    );
    if (isInitialized) {
      const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, startIndex);
      return {
        isExist: true,
        startIndex,
        nextAccountMeta: address
      };
    }
    const { isExist, nextStartIndex } = this.nextInitializedTickArrayStartIndex(
      poolInfo,
      TickQuery.getArrayStartIndex(poolInfo.tickCurrent, poolInfo.tickSpacing),
      zeroForOne
    );
    if (isExist) {
      const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, nextStartIndex);
      return {
        isExist: true,
        startIndex: nextStartIndex,
        nextAccountMeta: address
      };
    }
    return { isExist: false, nextAccountMeta: void 0, startIndex: void 0 };
  }
  static preInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
    const currentOffset = Math.floor(poolInfo.tickCurrent / TickQuery.tickCount(poolInfo.tickSpacing));
    const result = !zeroForOne ? TickUtils.searchLowBitFromStart(
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      currentOffset - 1,
      1,
      poolInfo.tickSpacing
    ) : TickUtils.searchHightBitFromStart(
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      currentOffset + 1,
      1,
      poolInfo.tickSpacing
    );
    return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
  }
  static nextInitializedTickArrayStartIndex(poolInfo, lastTickArrayStartIndex, zeroForOne) {
    lastTickArrayStartIndex = TickQuery.getArrayStartIndex(lastTickArrayStartIndex, poolInfo.tickSpacing);
    while (true) {
      const { isInit: startIsInit, tickIndex: startIndex } = TickArrayBitmap.nextInitializedTickArrayStartIndex(
        TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap),
        lastTickArrayStartIndex,
        poolInfo.tickSpacing,
        zeroForOne
      );
      if (startIsInit) {
        return { isExist: true, nextStartIndex: startIndex };
      }
      lastTickArrayStartIndex = startIndex;
      const { isInit, tickIndex } = TickArrayBitmapExtension.nextInitializedTickArrayFromOneBitmap(
        lastTickArrayStartIndex,
        poolInfo.tickSpacing,
        zeroForOne,
        poolInfo.exBitmapInfo
      );
      if (isInit) return { isExist: true, nextStartIndex: tickIndex };
      lastTickArrayStartIndex = tickIndex;
      if (lastTickArrayStartIndex < MIN_TICK || lastTickArrayStartIndex > MAX_TICK)
        return { isExist: false, nextStartIndex: 0 };
    }
  }
  static updatePoolRewardInfos(_0) {
    return __async(this, arguments, function* ({
      connection,
      apiPoolInfo,
      chainTime,
      poolLiquidity,
      rewardInfos
    }) {
      var _a, _b, _c;
      const nRewardInfo = [];
      for (let i = 0; i < rewardInfos.length; i++) {
        const _itemReward = rewardInfos[i];
        const apiRewardProgram = (_c = (_a = apiPoolInfo.rewardInfos[i]) == null ? void 0 : _a.programId) != null ? _c : (_b = yield connection.getAccountInfo(_itemReward.tokenMint)) == null ? void 0 : _b.owner;
        if (apiRewardProgram === void 0) throw Error("get new reward mint info error");
        const itemReward = __spreadProps(__spreadValues({}, _itemReward), {
          perSecond: MathUtil.x64ToDecimal(_itemReward.emissionsPerSecondX64),
          remainingRewards: void 0,
          tokenProgramId: new PublicKey15(apiRewardProgram)
        });
        if (itemReward.tokenMint.equals(PublicKey15.default)) continue;
        if (chainTime <= itemReward.openTime.toNumber() || poolLiquidity.eq(ZERO)) {
          nRewardInfo.push(itemReward);
          continue;
        }
        const latestUpdateTime = new BN12(Math.min(itemReward.endTime.toNumber(), chainTime));
        const timeDelta = latestUpdateTime.sub(itemReward.lastUpdateTime);
        const rewardGrowthDeltaX64 = MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, poolLiquidity);
        const rewardGrowthGlobalX64 = itemReward.rewardGrowthGlobalX64.add(rewardGrowthDeltaX64);
        const rewardEmissionedDelta = MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, Q64);
        const rewardTotalEmissioned = itemReward.rewardTotalEmissioned.add(rewardEmissionedDelta);
        nRewardInfo.push(__spreadProps(__spreadValues({}, itemReward), {
          rewardGrowthGlobalX64,
          rewardTotalEmissioned,
          lastUpdateTime: latestUpdateTime
        }));
      }
      return nRewardInfo;
    });
  }
  static isOverflowDefaultTickarrayBitmap(tickSpacing, tickarrayStartIndexs) {
    const { maxTickBoundary, minTickBoundary } = this.tickRange(tickSpacing);
    for (const tickIndex of tickarrayStartIndexs) {
      const tickarrayStartIndex = TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
      if (tickarrayStartIndex >= maxTickBoundary || tickarrayStartIndex < minTickBoundary) {
        return true;
      }
    }
    return false;
  }
  static tickRange(tickSpacing) {
    let maxTickBoundary = TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    let minTickBoundary = -maxTickBoundary;
    if (maxTickBoundary > MAX_TICK) {
      maxTickBoundary = TickQuery.getArrayStartIndex(MAX_TICK, tickSpacing) + TickQuery.tickCount(tickSpacing);
    }
    if (minTickBoundary < MIN_TICK) {
      minTickBoundary = TickQuery.getArrayStartIndex(MIN_TICK, tickSpacing);
    }
    return { maxTickBoundary, minTickBoundary };
  }
  static get_tick_array_offset(tickarrayStartIndex, tickSpacing) {
    if (!TickQuery.checkIsValidStartIndex(tickarrayStartIndex, tickSpacing)) {
      throw new Error("No enough initialized tickArray");
    }
    return tickarrayStartIndex / TickQuery.tickCount(tickSpacing) * TICK_ARRAY_BITMAP_SIZE;
  }
};

// src/clmm/utils/math.ts
var MathUtil = class {
  static mulDivRoundingUp(a, b, denominator) {
    const numerator = a.mul(b);
    let result = numerator.div(denominator);
    if (!numerator.mod(denominator).eq(ZERO)) {
      result = result.add(ONE);
    }
    return result;
  }
  static mulDivFloor(a, b, denominator) {
    if (denominator.eq(ZERO)) {
      throw new Error("division by 0");
    }
    return a.mul(b).div(denominator);
  }
  static mulDivCeil(a, b, denominator) {
    if (denominator.eq(ZERO)) {
      throw new Error("division by 0");
    }
    const numerator = a.mul(b).add(denominator.sub(ONE));
    return numerator.div(denominator);
  }
  static x64ToDecimal(num, decimalPlaces) {
    return new Decimal2(num.toString()).div(Decimal2.pow(2, 64)).toDecimalPlaces(decimalPlaces);
  }
  static decimalToX64(num) {
    return new BN13(num.mul(Decimal2.pow(2, 64)).floor().toFixed());
  }
  static wrappingSubU128(n0, n1) {
    return n0.add(Q128).sub(n1).mod(Q128);
  }
};
function mulRightShift(val, mulBy) {
  return signedRightShift(val.mul(mulBy), 64, 256);
}
function signedLeftShift(n0, shiftBy, bitWidth) {
  const twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
  twosN0.imaskn(bitWidth + 1);
  return twosN0.fromTwos(bitWidth);
}
function signedRightShift(n0, shiftBy, bitWidth) {
  const twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
  twoN0.imaskn(bitWidth - shiftBy + 1);
  return twoN0.fromTwos(bitWidth - shiftBy);
}
var SqrtPriceMath = class _SqrtPriceMath {
  static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
    return MathUtil.x64ToDecimal(sqrtPriceX64).pow(2).mul(Decimal2.pow(10, decimalsA - decimalsB));
  }
  static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
    return MathUtil.decimalToX64(price.mul(Decimal2.pow(10, decimalsB - decimalsA)).sqrt());
  }
  static getNextSqrtPriceX64FromInput(sqrtPriceX64, liquidity, amountIn, zeroForOne) {
    if (!sqrtPriceX64.gt(ZERO)) {
      throw new Error("sqrtPriceX64 must greater than 0");
    }
    if (!liquidity.gt(ZERO)) {
      throw new Error("liquidity must greater than 0");
    }
    return zeroForOne ? this.getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amountIn, true) : this.getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amountIn, true);
  }
  static getNextSqrtPriceX64FromOutput(sqrtPriceX64, liquidity, amountOut, zeroForOne) {
    if (!sqrtPriceX64.gt(ZERO)) {
      throw new Error("sqrtPriceX64 must greater than 0");
    }
    if (!liquidity.gt(ZERO)) {
      throw new Error("liquidity must greater than 0");
    }
    return zeroForOne ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amountOut, false) : this.getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amountOut, false);
  }
  static getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amount, add) {
    if (amount.eq(ZERO)) return sqrtPriceX64;
    const liquidityLeftShift = liquidity.shln(U64Resolution);
    if (add) {
      const numerator1 = liquidityLeftShift;
      const denominator = liquidityLeftShift.add(amount.mul(sqrtPriceX64));
      if (denominator.gte(numerator1)) {
        return MathUtil.mulDivCeil(numerator1, sqrtPriceX64, denominator);
      }
      return MathUtil.mulDivRoundingUp(numerator1, ONE, numerator1.div(sqrtPriceX64).add(amount));
    } else {
      const amountMulSqrtPrice = amount.mul(sqrtPriceX64);
      if (!liquidityLeftShift.gt(amountMulSqrtPrice)) {
        throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");
      }
      const denominator = liquidityLeftShift.sub(amountMulSqrtPrice);
      return MathUtil.mulDivCeil(liquidityLeftShift, sqrtPriceX64, denominator);
    }
  }
  static getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amount, add) {
    const deltaY = amount.shln(U64Resolution);
    if (add) {
      return sqrtPriceX64.add(deltaY.div(liquidity));
    } else {
      const amountDivLiquidity = MathUtil.mulDivRoundingUp(deltaY, ONE, liquidity);
      if (!sqrtPriceX64.gt(amountDivLiquidity)) {
        throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");
      }
      return sqrtPriceX64.sub(amountDivLiquidity);
    }
  }
  static getSqrtPriceX64FromTick(tick) {
    if (!Number.isInteger(tick)) {
      throw new Error("tick must be integer");
    }
    if (tick < MIN_TICK || tick > MAX_TICK) {
      throw new Error("tick must be in MIN_TICK and MAX_TICK");
    }
    const tickAbs = tick < 0 ? tick * -1 : tick;
    let ratio = (tickAbs & 1) != 0 ? new BN13("18445821805675395072") : new BN13("18446744073709551616");
    if ((tickAbs & 2) != 0) ratio = mulRightShift(ratio, new BN13("18444899583751176192"));
    if ((tickAbs & 4) != 0) ratio = mulRightShift(ratio, new BN13("18443055278223355904"));
    if ((tickAbs & 8) != 0) ratio = mulRightShift(ratio, new BN13("18439367220385607680"));
    if ((tickAbs & 16) != 0) ratio = mulRightShift(ratio, new BN13("18431993317065453568"));
    if ((tickAbs & 32) != 0) ratio = mulRightShift(ratio, new BN13("18417254355718170624"));
    if ((tickAbs & 64) != 0) ratio = mulRightShift(ratio, new BN13("18387811781193609216"));
    if ((tickAbs & 128) != 0) ratio = mulRightShift(ratio, new BN13("18329067761203558400"));
    if ((tickAbs & 256) != 0) ratio = mulRightShift(ratio, new BN13("18212142134806163456"));
    if ((tickAbs & 512) != 0) ratio = mulRightShift(ratio, new BN13("17980523815641700352"));
    if ((tickAbs & 1024) != 0) ratio = mulRightShift(ratio, new BN13("17526086738831433728"));
    if ((tickAbs & 2048) != 0) ratio = mulRightShift(ratio, new BN13("16651378430235570176"));
    if ((tickAbs & 4096) != 0) ratio = mulRightShift(ratio, new BN13("15030750278694412288"));
    if ((tickAbs & 8192) != 0) ratio = mulRightShift(ratio, new BN13("12247334978884435968"));
    if ((tickAbs & 16384) != 0) ratio = mulRightShift(ratio, new BN13("8131365268886854656"));
    if ((tickAbs & 32768) != 0) ratio = mulRightShift(ratio, new BN13("3584323654725218816"));
    if ((tickAbs & 65536) != 0) ratio = mulRightShift(ratio, new BN13("696457651848324352"));
    if ((tickAbs & 131072) != 0) ratio = mulRightShift(ratio, new BN13("26294789957507116"));
    if ((tickAbs & 262144) != 0) ratio = mulRightShift(ratio, new BN13("37481735321082"));
    if (tick > 0) ratio = MaxUint128.div(ratio);
    return ratio;
  }
  static getTickFromPrice(price, decimalsA, decimalsB) {
    return _SqrtPriceMath.getTickFromSqrtPriceX64(_SqrtPriceMath.priceToSqrtPriceX64(price, decimalsA, decimalsB));
  }
  static getTickFromSqrtPriceX64(sqrtPriceX64) {
    if (sqrtPriceX64.gt(MAX_SQRT_PRICE_X64) || sqrtPriceX64.lt(MIN_SQRT_PRICE_X64)) {
      throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
    }
    const msb = sqrtPriceX64.bitLength() - 1;
    const adjustedMsb = new BN13(msb - 64);
    const log2pIntegerX32 = signedLeftShift(adjustedMsb, 32, 128);
    let bit = new BN13("8000000000000000", "hex");
    let precision = 0;
    let log2pFractionX64 = new BN13(0);
    let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
    while (bit.gt(new BN13(0)) && precision < BIT_PRECISION) {
      r = r.mul(r);
      const rMoreThanTwo = r.shrn(127);
      r = r.shrn(63 + rMoreThanTwo.toNumber());
      log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
      bit = bit.shrn(1);
      precision += 1;
    }
    const log2pFractionX32 = log2pFractionX64.shrn(32);
    const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
    const logbpX64 = log2pX32.mul(new BN13(LOG_B_2_X32));
    const tickLow = signedRightShift(logbpX64.sub(new BN13(LOG_B_P_ERR_MARGIN_LOWER_X64)), 64, 128).toNumber();
    const tickHigh = signedRightShift(logbpX64.add(new BN13(LOG_B_P_ERR_MARGIN_UPPER_X64)), 64, 128).toNumber();
    if (tickLow == tickHigh) {
      return tickLow;
    } else {
      const derivedTickHighSqrtPriceX64 = _SqrtPriceMath.getSqrtPriceX64FromTick(tickHigh);
      return derivedTickHighSqrtPriceX64.lte(sqrtPriceX64) ? tickHigh : tickLow;
    }
  }
};
var TickMath = class _TickMath {
  static getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
    const tick = SqrtPriceMath.getTickFromSqrtPriceX64(
      SqrtPriceMath.priceToSqrtPriceX64(price, mintDecimalsA, mintDecimalsB)
    );
    let result = tick / tickSpacing;
    if (result < 0) {
      result = Math.floor(result);
    } else {
      result = Math.ceil(result);
    }
    return result * tickSpacing;
  }
  static roundPriceWithTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
    const tick = _TickMath.getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB);
    const sqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    return SqrtPriceMath.sqrtPriceX64ToPrice(sqrtPriceX64, mintDecimalsA, mintDecimalsB);
  }
};
var LiquidityMath = class _LiquidityMath {
  static addDelta(x, y) {
    return x.add(y);
  }
  static getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (!sqrtPriceX64A.gt(ZERO)) {
      throw new Error("sqrtPriceX64A must greater than 0");
    }
    const numerator1 = liquidity.ushln(U64Resolution);
    const numerator2 = sqrtPriceX64B.sub(sqrtPriceX64A);
    return roundUp ? MathUtil.mulDivRoundingUp(MathUtil.mulDivCeil(numerator1, numerator2, sqrtPriceX64B), ONE, sqrtPriceX64A) : MathUtil.mulDivFloor(numerator1, numerator2, sqrtPriceX64B).div(sqrtPriceX64A);
  }
  static getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (!sqrtPriceX64A.gt(ZERO)) {
      throw new Error("sqrtPriceX64A must greater than 0");
    }
    return roundUp ? MathUtil.mulDivCeil(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q64) : MathUtil.mulDivFloor(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q64);
  }
  static getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    const numerator = amountA.mul(sqrtPriceX64A).mul(sqrtPriceX64B);
    const denominator = sqrtPriceX64B.sub(sqrtPriceX64A);
    const result = numerator.div(denominator);
    if (roundUp) {
      return MathUtil.mulDivRoundingUp(result, ONE, MaxU64);
    } else {
      return result.shrn(U64Resolution);
    }
  }
  static getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    return MathUtil.mulDivFloor(amountB, MaxU64, sqrtPriceX64B.sub(sqrtPriceX64A));
  }
  static getLiquidityFromTokenAmounts(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, amountA, amountB) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
      return _LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, false);
    } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
      const liquidity0 = _LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceCurrentX64, sqrtPriceX64B, amountA, false);
      const liquidity1 = _LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceCurrentX64, amountB);
      return liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
    } else {
      return _LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB);
    }
  }
  static getAmountsFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
      return {
        amountA: _LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp),
        amountB: new BN13(0)
      };
    } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
      const amountA = _LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64B, liquidity, roundUp);
      const amountB = _LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceCurrentX64, liquidity, roundUp);
      return { amountA, amountB };
    } else {
      return {
        amountA: new BN13(0),
        amountB: _LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp)
      };
    }
  }
  static getAmountsFromLiquidityWithSlippage(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, amountMax, roundUp, amountSlippage) {
    const { amountA, amountB } = _LiquidityMath.getAmountsFromLiquidity(
      sqrtPriceCurrentX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      roundUp
    );
    const coefficient = amountMax ? 1 + amountSlippage : 1 - amountSlippage;
    const amount0Slippage = new BN13(new Decimal2(amountA.toString()).mul(coefficient).toFixed(0));
    const amount1Slippage = new BN13(new Decimal2(amountB.toString()).mul(coefficient).toFixed(0));
    return {
      amountSlippageA: amount0Slippage,
      amountSlippageB: amount1Slippage
    };
  }
};
var SwapMath = class _SwapMath {
  static swapCompute(programId, poolId, tickArrayCache, tickArrayBitmap, tickarrayBitmapExtension, zeroForOne, fee, liquidity, currentTick, tickSpacing, currentSqrtPriceX64, amountSpecified, lastSavedTickArrayStartIndex, sqrtPriceLimitX64, catchLiquidityInsufficient = false) {
    if (amountSpecified.eq(ZERO)) {
      throw new Error("amountSpecified must not be 0");
    }
    if (!sqrtPriceLimitX64) sqrtPriceLimitX64 = zeroForOne ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
    if (zeroForOne) {
      if (sqrtPriceLimitX64.lt(MIN_SQRT_PRICE_X64)) {
        throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");
      }
      if (sqrtPriceLimitX64.gte(currentSqrtPriceX64)) {
        throw new Error("sqrtPriceX64 must smaller than current");
      }
    } else {
      if (sqrtPriceLimitX64.gt(MAX_SQRT_PRICE_X64)) {
        throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");
      }
      if (sqrtPriceLimitX64.lte(currentSqrtPriceX64)) {
        throw new Error("sqrtPriceX64 must greater than current");
      }
    }
    const baseInput = amountSpecified.gt(ZERO);
    const state = {
      amountSpecifiedRemaining: amountSpecified,
      amountCalculated: ZERO,
      sqrtPriceX64: currentSqrtPriceX64,
      tick: currentTick > lastSavedTickArrayStartIndex ? Math.min(lastSavedTickArrayStartIndex + TickQuery.tickCount(tickSpacing) - 1, currentTick) : lastSavedTickArrayStartIndex,
      accounts: [],
      liquidity,
      feeAmount: new BN13(0)
    };
    let tickAarrayStartIndex = lastSavedTickArrayStartIndex;
    let tickArrayCurrent = tickArrayCache[lastSavedTickArrayStartIndex];
    let loopCount = 0;
    let t = !zeroForOne && tickArrayCurrent.startTickIndex === state.tick;
    while (!state.amountSpecifiedRemaining.eq(ZERO) && !state.sqrtPriceX64.eq(sqrtPriceLimitX64)) {
      if (loopCount > 10) {
      }
      const step = {};
      step.sqrtPriceStartX64 = state.sqrtPriceX64;
      const tickState = TickUtils.nextInitTick(tickArrayCurrent, state.tick, tickSpacing, zeroForOne, t);
      let nextInitTick = tickState ? tickState : null;
      let tickArrayAddress = null;
      if (!(nextInitTick == null ? void 0 : nextInitTick.liquidityGross.gtn(0))) {
        const nextInitTickArrayIndex = PoolUtils.nextInitializedTickArrayStartIndex(
          {
            tickCurrent: state.tick,
            tickSpacing,
            tickArrayBitmap,
            exBitmapInfo: tickarrayBitmapExtension
          },
          tickAarrayStartIndex,
          zeroForOne
        );
        if (!nextInitTickArrayIndex.isExist) {
          if (catchLiquidityInsufficient) {
            return {
              allTrade: false,
              amountSpecifiedRemaining: state.amountSpecifiedRemaining,
              amountCalculated: state.amountCalculated,
              feeAmount: state.feeAmount,
              sqrtPriceX64: state.sqrtPriceX64,
              liquidity: state.liquidity,
              tickCurrent: state.tick,
              accounts: state.accounts
            };
          }
          throw Error("swapCompute LiquidityInsufficient");
        }
        tickAarrayStartIndex = nextInitTickArrayIndex.nextStartIndex;
        const { publicKey: expectedNextTickArrayAddress } = getPdaTickArrayAddress(
          programId,
          poolId,
          tickAarrayStartIndex
        );
        tickArrayAddress = expectedNextTickArrayAddress;
        tickArrayCurrent = tickArrayCache[tickAarrayStartIndex];
        try {
          nextInitTick = TickUtils.firstInitializedTick(tickArrayCurrent, zeroForOne);
        } catch (e) {
          throw Error("not found next tick info");
        }
      }
      step.tickNext = nextInitTick.tick;
      step.initialized = nextInitTick.liquidityGross.gtn(0);
      if (lastSavedTickArrayStartIndex !== tickAarrayStartIndex && tickArrayAddress) {
        state.accounts.push(tickArrayAddress);
        lastSavedTickArrayStartIndex = tickAarrayStartIndex;
      }
      if (step.tickNext < MIN_TICK) {
        step.tickNext = MIN_TICK;
      } else if (step.tickNext > MAX_TICK) {
        step.tickNext = MAX_TICK;
      }
      step.sqrtPriceNextX64 = SqrtPriceMath.getSqrtPriceX64FromTick(step.tickNext);
      let targetPrice;
      if (zeroForOne && step.sqrtPriceNextX64.lt(sqrtPriceLimitX64) || !zeroForOne && step.sqrtPriceNextX64.gt(sqrtPriceLimitX64)) {
        targetPrice = sqrtPriceLimitX64;
      } else {
        targetPrice = step.sqrtPriceNextX64;
      }
      ;
      [state.sqrtPriceX64, step.amountIn, step.amountOut, step.feeAmount] = _SwapMath.swapStepCompute(
        state.sqrtPriceX64,
        targetPrice,
        state.liquidity,
        state.amountSpecifiedRemaining,
        fee
      );
      state.feeAmount = state.feeAmount.add(step.feeAmount);
      if (baseInput) {
        state.amountSpecifiedRemaining = state.amountSpecifiedRemaining.sub(step.amountIn.add(step.feeAmount));
        state.amountCalculated = state.amountCalculated.sub(step.amountOut);
      } else {
        state.amountSpecifiedRemaining = state.amountSpecifiedRemaining.add(step.amountOut);
        state.amountCalculated = state.amountCalculated.add(step.amountIn.add(step.feeAmount));
      }
      if (state.sqrtPriceX64.eq(step.sqrtPriceNextX64)) {
        if (step.initialized) {
          let liquidityNet = nextInitTick.liquidityNet;
          if (zeroForOne) liquidityNet = liquidityNet.mul(NEGATIVE_ONE);
          state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
        }
        t = step.tickNext != state.tick && !zeroForOne && tickArrayCurrent.startTickIndex === step.tickNext;
        state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
      } else if (state.sqrtPriceX64 != step.sqrtPriceStartX64) {
        const _T = SqrtPriceMath.getTickFromSqrtPriceX64(state.sqrtPriceX64);
        t = _T != state.tick && !zeroForOne && tickArrayCurrent.startTickIndex === _T;
        state.tick = _T;
      }
      ++loopCount;
    }
    try {
      const { nextStartIndex: tickAarrayStartIndex2, isExist } = TickQuery.nextInitializedTickArray(
        state.tick,
        tickSpacing,
        zeroForOne,
        tickArrayBitmap,
        tickarrayBitmapExtension
      );
      if (isExist && lastSavedTickArrayStartIndex !== tickAarrayStartIndex2) {
        state.accounts.push(getPdaTickArrayAddress(programId, poolId, tickAarrayStartIndex2).publicKey);
        lastSavedTickArrayStartIndex = tickAarrayStartIndex2;
      }
    } catch (e) {
    }
    return {
      allTrade: true,
      amountSpecifiedRemaining: ZERO,
      amountCalculated: state.amountCalculated,
      feeAmount: state.feeAmount,
      sqrtPriceX64: state.sqrtPriceX64,
      liquidity: state.liquidity,
      tickCurrent: state.tick,
      accounts: state.accounts
    };
  }
  static swapStepCompute(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, amountRemaining, feeRate) {
    const swapStep = {
      sqrtPriceX64Next: new BN13(0),
      amountIn: new BN13(0),
      amountOut: new BN13(0),
      feeAmount: new BN13(0)
    };
    const zeroForOne = sqrtPriceX64Current.gte(sqrtPriceX64Target);
    const baseInput = amountRemaining.gte(ZERO);
    if (baseInput) {
      const amountRemainingSubtractFee = MathUtil.mulDivFloor(
        amountRemaining,
        FEE_RATE_DENOMINATOR.sub(new BN13(feeRate.toString())),
        FEE_RATE_DENOMINATOR
      );
      swapStep.amountIn = zeroForOne ? LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64Target, sqrtPriceX64Current, liquidity, true) : LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, true);
      if (amountRemainingSubtractFee.gte(swapStep.amountIn)) {
        swapStep.sqrtPriceX64Next = sqrtPriceX64Target;
      } else {
        swapStep.sqrtPriceX64Next = SqrtPriceMath.getNextSqrtPriceX64FromInput(
          sqrtPriceX64Current,
          liquidity,
          amountRemainingSubtractFee,
          zeroForOne
        );
      }
    } else {
      swapStep.amountOut = zeroForOne ? LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64Target, sqrtPriceX64Current, liquidity, false) : LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, false);
      if (amountRemaining.mul(NEGATIVE_ONE).gte(swapStep.amountOut)) {
        swapStep.sqrtPriceX64Next = sqrtPriceX64Target;
      } else {
        swapStep.sqrtPriceX64Next = SqrtPriceMath.getNextSqrtPriceX64FromOutput(
          sqrtPriceX64Current,
          liquidity,
          amountRemaining.mul(NEGATIVE_ONE),
          zeroForOne
        );
      }
    }
    const reachTargetPrice = sqrtPriceX64Target.eq(swapStep.sqrtPriceX64Next);
    if (zeroForOne) {
      if (!(reachTargetPrice && baseInput)) {
        swapStep.amountIn = LiquidityMath.getTokenAmountAFromLiquidity(
          swapStep.sqrtPriceX64Next,
          sqrtPriceX64Current,
          liquidity,
          true
        );
      }
      if (!(reachTargetPrice && !baseInput)) {
        swapStep.amountOut = LiquidityMath.getTokenAmountBFromLiquidity(
          swapStep.sqrtPriceX64Next,
          sqrtPriceX64Current,
          liquidity,
          false
        );
      }
    } else {
      swapStep.amountIn = reachTargetPrice && baseInput ? swapStep.amountIn : LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64Current, swapStep.sqrtPriceX64Next, liquidity, true);
      swapStep.amountOut = reachTargetPrice && !baseInput ? swapStep.amountOut : LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64Current, swapStep.sqrtPriceX64Next, liquidity, false);
    }
    if (!baseInput && swapStep.amountOut.gt(amountRemaining.mul(NEGATIVE_ONE))) {
      swapStep.amountOut = amountRemaining.mul(NEGATIVE_ONE);
    }
    if (baseInput && !swapStep.sqrtPriceX64Next.eq(sqrtPriceX64Target)) {
      swapStep.feeAmount = amountRemaining.sub(swapStep.amountIn);
    } else {
      swapStep.feeAmount = MathUtil.mulDivCeil(
        swapStep.amountIn,
        new BN13(feeRate),
        FEE_RATE_DENOMINATOR.sub(new BN13(feeRate))
      );
    }
    return [swapStep.sqrtPriceX64Next, swapStep.amountIn, swapStep.amountOut, swapStep.feeAmount];
  }
};

// src/clmm/utils/position.ts
import BN14 from "bn.js";
var PositionUtils = class {
  static getfeeGrowthInside(poolState, tickLowerState, tickUpperState) {
    let feeGrowthBelowX64A = new BN14(0);
    let feeGrowthBelowX64B = new BN14(0);
    if (poolState.tickCurrent >= tickLowerState.tick) {
      feeGrowthBelowX64A = tickLowerState.feeGrowthOutsideX64A;
      feeGrowthBelowX64B = tickLowerState.feeGrowthOutsideX64B;
    } else {
      feeGrowthBelowX64A = poolState.feeGrowthGlobalX64A.sub(tickLowerState.feeGrowthOutsideX64A);
      feeGrowthBelowX64B = poolState.feeGrowthGlobalX64B.sub(tickLowerState.feeGrowthOutsideX64B);
    }
    let feeGrowthAboveX64A = new BN14(0);
    let feeGrowthAboveX64B = new BN14(0);
    if (poolState.tickCurrent < tickUpperState.tick) {
      feeGrowthAboveX64A = tickUpperState.feeGrowthOutsideX64A;
      feeGrowthAboveX64B = tickUpperState.feeGrowthOutsideX64B;
    } else {
      feeGrowthAboveX64A = poolState.feeGrowthGlobalX64A.sub(tickUpperState.feeGrowthOutsideX64A);
      feeGrowthAboveX64B = poolState.feeGrowthGlobalX64B.sub(tickUpperState.feeGrowthOutsideX64B);
    }
    const feeGrowthInsideX64A = MathUtil.wrappingSubU128(
      MathUtil.wrappingSubU128(poolState.feeGrowthGlobalX64A, feeGrowthBelowX64A),
      feeGrowthAboveX64A
    );
    const feeGrowthInsideBX64 = MathUtil.wrappingSubU128(
      MathUtil.wrappingSubU128(poolState.feeGrowthGlobalX64B, feeGrowthBelowX64B),
      feeGrowthAboveX64B
    );
    return { feeGrowthInsideX64A, feeGrowthInsideBX64 };
  }
  static GetPositionFees(ammPool, positionState, tickLowerState, tickUpperState) {
    const { feeGrowthInsideX64A, feeGrowthInsideBX64 } = this.getfeeGrowthInside(
      ammPool,
      tickLowerState,
      tickUpperState
    );
    const feeGrowthdeltaA = MathUtil.mulDivFloor(
      MathUtil.wrappingSubU128(feeGrowthInsideX64A, positionState.feeGrowthInsideLastX64A),
      positionState.liquidity,
      Q64
    );
    const tokenFeeAmountA = positionState.tokenFeesOwedA.add(feeGrowthdeltaA);
    const feeGrowthdelta1 = MathUtil.mulDivFloor(
      MathUtil.wrappingSubU128(feeGrowthInsideBX64, positionState.feeGrowthInsideLastX64B),
      positionState.liquidity,
      Q64
    );
    const tokenFeeAmountB = positionState.tokenFeesOwedB.add(feeGrowthdelta1);
    return { tokenFeeAmountA, tokenFeeAmountB };
  }
  static GetPositionRewards(ammPool, positionState, tickLowerState, tickUpperState) {
    const rewards = [];
    const rewardGrowthsInside = this.getRewardGrowthInside(
      ammPool.tickCurrent,
      tickLowerState,
      tickUpperState,
      ammPool.rewardInfos
    );
    for (let i = 0; i < rewardGrowthsInside.length; i++) {
      const rewardGrowthInside = rewardGrowthsInside[i];
      const currRewardInfo = positionState.rewardInfos[i];
      const rewardGrowthDelta = MathUtil.wrappingSubU128(rewardGrowthInside, currRewardInfo.growthInsideLastX64);
      const amountOwedDelta = MathUtil.mulDivFloor(rewardGrowthDelta, positionState.liquidity, Q64);
      const rewardAmountOwed = currRewardInfo.rewardAmountOwed.add(amountOwedDelta);
      rewards.push(rewardAmountOwed);
    }
    return rewards;
  }
  static getRewardGrowthInside(tickCurrentIndex, tickLowerState, tickUpperState, rewardInfos) {
    const rewardGrowthsInside = [];
    for (let i = 0; i < rewardInfos.length; i++) {
      let rewardGrowthsBelow = new BN14(0);
      if (tickLowerState.liquidityGross.eqn(0)) {
        rewardGrowthsBelow = rewardInfos[i].rewardGrowthGlobalX64;
      } else if (tickCurrentIndex < tickLowerState.tick) {
        rewardGrowthsBelow = rewardInfos[i].rewardGrowthGlobalX64.sub(tickLowerState.rewardGrowthsOutsideX64[i]);
      } else {
        rewardGrowthsBelow = tickLowerState.rewardGrowthsOutsideX64[i];
      }
      let rewardGrowthsAbove = new BN14(0);
      if (tickUpperState.liquidityGross.eqn(0)) {
      } else if (tickCurrentIndex < tickUpperState.tick) {
        rewardGrowthsAbove = tickUpperState.rewardGrowthsOutsideX64[i];
      } else {
        rewardGrowthsAbove = rewardInfos[i].rewardGrowthGlobalX64.sub(tickUpperState.rewardGrowthsOutsideX64[i]);
      }
      rewardGrowthsInside.push(
        MathUtil.wrappingSubU128(
          MathUtil.wrappingSubU128(rewardInfos[i].rewardGrowthGlobalX64, rewardGrowthsBelow),
          rewardGrowthsAbove
        )
      );
    }
    return rewardGrowthsInside;
  }
};

// src/clmm/clmm.ts
var logger9 = Logger.from("Clmm");
var Clmm = class extends Base {
  static makeMockPoolInfo({
    programId,
    mint1,
    mint2,
    ammConfig,
    createPoolInstructionSimpleAddress,
    initialPrice,
    startTime,
    owner
  }) {
    const [mintA, mintB, initPrice] = new BN15(mint1.mint.toBuffer()).gt(new BN15(mint2.mint.toBuffer())) ? [mint2, mint1, new Decimal3(1).div(initialPrice)] : [mint1, mint2, initialPrice];
    const initialPriceX64 = SqrtPriceMath.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
    return {
      id: createPoolInstructionSimpleAddress.poolId,
      mintA: {
        programId: createPoolInstructionSimpleAddress.mintProgramIdA,
        mint: createPoolInstructionSimpleAddress.mintA,
        vault: createPoolInstructionSimpleAddress.mintAVault,
        decimals: mintA.decimals
      },
      mintB: {
        programId: createPoolInstructionSimpleAddress.mintProgramIdB,
        mint: createPoolInstructionSimpleAddress.mintB,
        vault: createPoolInstructionSimpleAddress.mintBVault,
        decimals: mintB.decimals
      },
      ammConfig,
      observationId: createPoolInstructionSimpleAddress.observationId,
      creator: owner,
      programId,
      version: 6,
      tickSpacing: ammConfig.tickSpacing,
      liquidity: ZERO,
      sqrtPriceX64: initialPriceX64,
      currentPrice: initPrice,
      tickCurrent: 0,
      observationIndex: 0,
      observationUpdateDuration: 0,
      feeGrowthGlobalX64A: ZERO,
      feeGrowthGlobalX64B: ZERO,
      protocolFeesTokenA: ZERO,
      protocolFeesTokenB: ZERO,
      swapInAmountTokenA: ZERO,
      swapOutAmountTokenB: ZERO,
      swapInAmountTokenB: ZERO,
      swapOutAmountTokenA: ZERO,
      tickArrayBitmap: [],
      rewardInfos: [],
      day: {
        volume: 0,
        volumeFee: 0,
        feeA: 0,
        feeB: 0,
        feeApr: 0,
        rewardApr: { A: 0, B: 0, C: 0 },
        apr: 0,
        priceMax: 0,
        priceMin: 0
      },
      week: {
        volume: 0,
        volumeFee: 0,
        feeA: 0,
        feeB: 0,
        feeApr: 0,
        rewardApr: { A: 0, B: 0, C: 0 },
        apr: 0,
        priceMax: 0,
        priceMin: 0
      },
      month: {
        volume: 0,
        volumeFee: 0,
        feeA: 0,
        feeB: 0,
        feeApr: 0,
        rewardApr: { A: 0, B: 0, C: 0 },
        apr: 0,
        priceMax: 0,
        priceMin: 0
      },
      tvl: 0,
      lookupTableAccount: PublicKey16.default,
      startTime: startTime.toNumber(),
      exBitmapInfo: {
        poolId: createPoolInstructionSimpleAddress.poolId,
        positiveTickArrayBitmap: Array.from(
          { length: EXTENSION_TICKARRAY_BITMAP_SIZE },
          () => Array.from({ length: 8 }, () => new BN15(0))
        ),
        negativeTickArrayBitmap: Array.from(
          { length: EXTENSION_TICKARRAY_BITMAP_SIZE },
          () => Array.from({ length: 8 }, () => new BN15(0))
        )
      }
    };
  }
  // transaction
  static makeCreatePoolInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      makeTxVersion,
      connection,
      programId,
      owner,
      payer,
      mint1,
      mint2,
      ammConfig,
      initialPrice,
      startTime,
      computeBudgetConfig,
      lookupTableCache
    }) {
      const [mintA, mintB, initPrice] = new BN15(mint1.mint.toBuffer()).gt(new BN15(mint2.mint.toBuffer())) ? [mint2, mint1, new Decimal3(1).div(initialPrice)] : [mint1, mint2, initialPrice];
      const initialPriceX64 = SqrtPriceMath.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
      const makeCreatePoolInstructions = yield this.makeCreatePoolInstructions({
        connection,
        programId,
        owner,
        mintA,
        mintB,
        ammConfigId: ammConfig.id,
        initialPriceX64,
        startTime
      });
      return {
        address: __spreadProps(__spreadValues({}, makeCreatePoolInstructions.address), {
          mintA: mintA.mint,
          mintB: mintB.mint,
          mintProgramIdA: mintA.programId,
          mintProgramIdB: mintB.programId
        }),
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [makeCreatePoolInstructions.innerTransaction],
          lookupTableCache
        })
      };
    });
  }
  static makeOpenPositionFromLiquidityInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      makeTxVersion,
      connection,
      poolInfo,
      ownerInfo,
      amountMaxA,
      amountMaxB,
      tickLower,
      tickUpper,
      liquidity,
      associatedOnly = true,
      checkCreateATAOwner = false,
      withMetadata = "create",
      getEphemeralSigners,
      computeBudgetConfig,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance || amountMaxA.eq(ZERO) ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxA,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance || amountMaxB.eq(ZERO) ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxB,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        ownerTokenAccountA !== void 0 && ownerTokenAccountB !== void 0,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeOpenPositionInstructions = yield this.makeOpenPositionFromLiquidityInstructions({
        poolInfo,
        ownerInfo: __spreadProps(__spreadValues({}, ownerInfo), {
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        }),
        tickLower,
        tickUpper,
        liquidity,
        amountMaxA,
        amountMaxB,
        withMetadata,
        getEphemeralSigners
      });
      return {
        address: makeOpenPositionInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeOpenPositionInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeOpenPositionFromBaseInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      tickLower,
      tickUpper,
      base,
      baseAmount,
      otherAmountMax,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      withMetadata = "create",
      makeTxVersion,
      lookupTableCache,
      getEphemeralSigners
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? baseAmount : otherAmountMax,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? otherAmountMax : baseAmount,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        ownerTokenAccountA !== void 0 && ownerTokenAccountB !== void 0,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeOpenPositionInstructions = yield this.makeOpenPositionFromBaseInstructions({
        poolInfo,
        ownerInfo: __spreadProps(__spreadValues({}, ownerInfo), {
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        }),
        tickLower,
        tickUpper,
        base,
        baseAmount,
        otherAmountMax,
        withMetadata,
        getEphemeralSigners
      });
      return {
        address: makeOpenPositionInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeOpenPositionInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeIncreasePositionFromLiquidityInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerPosition,
      ownerInfo,
      amountMaxA,
      amountMaxB,
      liquidity,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxA,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxB,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeIncreaseLiquidityInstructions = this.makeIncreasePositionFromLiquidityInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        liquidity,
        amountMaxA,
        amountMaxB
      });
      return {
        address: makeIncreaseLiquidityInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeIncreaseLiquidityInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeIncreasePositionFromBaseInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerPosition,
      ownerInfo,
      base,
      baseAmount,
      otherAmountMax,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? baseAmount : otherAmountMax,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? otherAmountMax : baseAmount,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeIncreaseLiquidityInstructions = this.makeIncreasePositionFromBaseInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        base,
        baseAmount,
        otherAmountMax
      });
      return {
        address: makeIncreaseLiquidityInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeIncreaseLiquidityInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeDecreaseLiquidityInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerPosition,
      ownerInfo,
      liquidity,
      amountMinA,
      amountMinB,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintAUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintBUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const rewardAccounts = [];
      for (const itemReward of poolInfo.rewardInfos) {
        const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = itemReward.tokenMint.equals(poolInfo.mintA.mint) ? ownerTokenAccountA : itemReward.tokenMint.equals(poolInfo.mintB.mint) ? ownerTokenAccountB : yield this._selectOrCreateTokenAccount({
          programId: itemReward.tokenProgramId,
          mint: itemReward.tokenMint,
          tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: rewardUseSOLBalance ? endInstructions : [],
            endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        rewardAccounts.push(ownerRewardAccount);
      }
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeDecreaseLiquidityInstructions = this.makeDecreaseLiquidityInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB,
          rewardAccounts
        },
        liquidity,
        amountMinA,
        amountMinB
      });
      const makeClosePositionInstructions = ownerInfo.closePosition ? this.makeClosePositionInstructions({
        poolInfo,
        ownerInfo,
        ownerPosition
      }) : { address: {}, innerTransaction: { instructions: [], signers: [], instructionTypes: [] } };
      return {
        address: makeDecreaseLiquidityInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeDecreaseLiquidityInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] },
            makeClosePositionInstructions.innerTransaction
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSwapBaseInInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      inputMint,
      amountIn,
      amountOutMin,
      priceLimit,
      remainingAccounts,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let sqrtPriceLimitX64;
      if (!priceLimit || priceLimit.equals(new Decimal3(0))) {
        sqrtPriceLimitX64 = inputMint.equals(poolInfo.mintA.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
      } else {
        sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
          priceLimit,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
      }
      const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance || !isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? amountIn : 0,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance || isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? 0 : amountIn,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeSwapBaseInInstructions = this.makeSwapBaseInInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        inputMint,
        amountIn,
        amountOutMin,
        sqrtPriceLimitX64,
        remainingAccounts
      });
      return {
        address: makeSwapBaseInInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeSwapBaseInInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSwapBaseOutInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      outputMint,
      amountOut,
      amountInMax,
      priceLimit,
      remainingAccounts,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let sqrtPriceLimitX64;
      if (!priceLimit || priceLimit.equals(new Decimal3(0))) {
        sqrtPriceLimitX64 = outputMint.equals(poolInfo.mintB.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
      } else {
        sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
          priceLimit,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
      }
      const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance || !isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? amountInMax : 0,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance || isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? 0 : amountInMax,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeSwapBaseOutInstructions = this.makeSwapBaseOutInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        outputMint,
        amountOut,
        amountInMax,
        sqrtPriceLimitX64,
        remainingAccounts
      });
      return {
        address: makeSwapBaseOutInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeSwapBaseOutInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCLosePositionInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      poolInfo,
      ownerPosition,
      ownerInfo,
      makeTxVersion,
      lookupTableCache,
      connection
    }) {
      const data = this.makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition });
      return {
        address: data.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [data.innerTransaction],
          lookupTableCache
        })
      };
    });
  }
  static makeInitRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfo,
      chainTime,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache
    }) {
      logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
      logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
      const _baseRewardAmount = rewardInfo.perSecond.mul(rewardInfo.endTime - rewardInfo.openTime);
      const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
        programId: rewardInfo.programId,
        mint: rewardInfo.mint,
        tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: rewardMintUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: new BN15(
            new Decimal3(_baseRewardAmount.toFixed(0)).gte(_baseRewardAmount) ? _baseRewardAmount.toFixed(0) : _baseRewardAmount.add(1).toFixed(0)
          ),
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
      const makeInitRewardInstructions = this.makeInitRewardInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccount: ownerRewardAccount
        },
        rewardInfo: {
          programId: rewardInfo.programId,
          mint: rewardInfo.mint,
          openTime: rewardInfo.openTime,
          endTime: rewardInfo.endTime,
          emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
        }
      });
      return {
        address: makeInitRewardInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeInitRewardInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeInitRewardsInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfos,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      for (const rewardInfo of rewardInfos)
        logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeInitRewardInstructions = [];
      const signers = [];
      for (const rewardInfo of rewardInfos) {
        const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
        const _baseRewardAmount = rewardInfo.perSecond.mul(rewardInfo.endTime - rewardInfo.openTime);
        const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
          programId: rewardInfo.programId,
          mint: rewardInfo.mint,
          tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: rewardMintUseSOLBalance ? {
            connection,
            payer: ownerInfo.feePayer,
            amount: new BN15(
              new Decimal3(_baseRewardAmount.toFixed(0)).gte(_baseRewardAmount) ? _baseRewardAmount.toFixed(0) : _baseRewardAmount.add(1).toFixed(0)
            ),
            frontInstructions,
            endInstructions,
            frontInstructionsType,
            endInstructionsType,
            signers
          } : void 0,
          associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
        makeInitRewardInstructions.push(
          this.makeInitRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardInfo: {
              programId: rewardInfo.programId,
              mint: rewardInfo.mint,
              openTime: rewardInfo.openTime,
              endTime: rewardInfo.endTime,
              emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
            }
          })
        );
      }
      let address = {};
      for (const item of makeInitRewardInstructions) {
        address = __spreadValues(__spreadValues({}, address), item.address);
      }
      return {
        address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeInitRewardInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSetRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfo,
      chainTime,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache
    }) {
      logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
      logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
      const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
        programId: rewardInfo.programId,
        mint: rewardInfo.mint,
        tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: rewardMintUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: new BN15(
            new Decimal3(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(
              rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)
            ) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)
          ),
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
      const makeSetRewardInstructions = this.makeSetRewardInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccount: ownerRewardAccount
        },
        rewardInfo: {
          mint: rewardInfo.mint,
          openTime: rewardInfo.openTime,
          endTime: rewardInfo.endTime,
          emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
        }
      });
      return {
        address: makeSetRewardInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeSetRewardInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSetRewardsInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfos,
      chainTime,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeSetRewardInstructions = [];
      const signers = [];
      for (const rewardInfo of rewardInfos) {
        logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
        logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
        const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
        const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
          programId: rewardInfo.programId,
          mint: rewardInfo.mint,
          tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: rewardMintUseSOLBalance ? {
            connection,
            payer: ownerInfo.feePayer,
            amount: new BN15(
              new Decimal3(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(
                rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)
              ) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)
            ),
            frontInstructions,
            endInstructions,
            frontInstructionsType,
            endInstructionsType,
            signers
          } : void 0,
          associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
        makeSetRewardInstructions.push(
          this.makeSetRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardInfo: {
              mint: rewardInfo.mint,
              openTime: rewardInfo.openTime,
              endTime: rewardInfo.endTime,
              emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
            }
          })
        );
      }
      let address = {};
      for (const item of makeSetRewardInstructions) {
        address = __spreadValues(__spreadValues({}, address), item.address);
      }
      return {
        address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeSetRewardInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCollectRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardMint,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const rewardInfo = poolInfo.rewardInfos.find((i) => i.tokenMint.equals(rewardMint));
      logger9.assertArgument(rewardInfo !== void 0, "reward mint error", "not found reward mint", rewardMint);
      if (rewardInfo === void 0) throw Error("reward mint error");
      const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(Token.WSOL.mint);
      const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
        programId: rewardInfo.tokenProgramId,
        mint: rewardMint,
        tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
          frontInstructionsType,
          endInstructionsType,
          signers
        },
        associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
      const makeCollectRewardInstructions = this.makeCollectRewardInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccount: ownerRewardAccount
        },
        rewardMint
      });
      return {
        address: makeCollectRewardInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeCollectRewardInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCollectRewardsInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardMints,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeCollectRewardInstructions = [];
      const signers = [];
      for (const rewardMint of rewardMints) {
        const rewardInfo = poolInfo.rewardInfos.find((i) => i.tokenMint.equals(rewardMint));
        logger9.assertArgument(rewardInfo !== void 0, "reward mint error", "not found reward mint", rewardMint);
        if (rewardInfo === void 0) throw Error("reward mint error");
        const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
          programId: rewardInfo.tokenProgramId,
          mint: rewardMint,
          tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
            signers,
            frontInstructionsType,
            endInstructionsType
          },
          associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
        makeCollectRewardInstructions.push(
          this.makeCollectRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardMint
          })
        );
      }
      let address = {};
      for (const item of makeCollectRewardInstructions) {
        address = __spreadValues(__spreadValues({}, address), item.address);
      }
      return {
        address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeCollectRewardInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeHarvestAllRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      fetchPoolInfos,
      ownerInfo,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache
    }) {
      var _a, _b, _c;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeDecreaseLiquidityInstructions = [];
      const signers = [];
      for (const itemInfo of Object.values(fetchPoolInfos)) {
        if (itemInfo.positionAccount === void 0) continue;
        if (!itemInfo.positionAccount.find(
          (i) => !i.tokenFeeAmountA.isZero() || !i.tokenFeeAmountB.isZero() || i.rewardInfos.find((ii) => !ii.pendingReward.isZero())
        ))
          continue;
        const poolInfo = itemInfo.state;
        const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
        const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
        const ownerTokenAccountA = (_a = ownerMintToAccount[poolInfo.mintA.mint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
          programId: poolInfo.mintA.programId,
          mint: poolInfo.mintA.mint,
          tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: mintAUseSOLBalance ? endInstructions : [],
            endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        const ownerTokenAccountB = (_b = ownerMintToAccount[poolInfo.mintB.mint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
          programId: poolInfo.mintB.programId,
          mint: poolInfo.mintB.mint,
          tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: mintBUseSOLBalance ? endInstructions : [],
            endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[poolInfo.mintA.mint.toString()] = ownerTokenAccountA;
        ownerMintToAccount[poolInfo.mintB.mint.toString()] = ownerTokenAccountB;
        const rewardAccounts = [];
        for (const itemReward of poolInfo.rewardInfos) {
          const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(Token.WSOL.mint);
          const ownerRewardAccount = (_c = ownerMintToAccount[itemReward.tokenMint.toString()]) != null ? _c : yield this._selectOrCreateTokenAccount({
            programId: itemReward.tokenProgramId,
            mint: itemReward.tokenMint,
            tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              endInstructions: rewardUseSOLBalance ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          ownerMintToAccount[itemReward.tokenMint.toString()] = ownerRewardAccount;
          rewardAccounts.push(ownerRewardAccount);
        }
        for (const itemPosition of itemInfo.positionAccount) {
          makeDecreaseLiquidityInstructions.push(
            this.makeDecreaseLiquidityInstructions({
              poolInfo,
              ownerPosition: itemPosition,
              ownerInfo: {
                wallet: ownerInfo.wallet,
                tokenAccountA: ownerTokenAccountA,
                tokenAccountB: ownerTokenAccountB,
                rewardAccounts
              },
              liquidity: ZERO,
              amountMinA: ZERO,
              amountMinB: ZERO
            })
          );
        }
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeDecreaseLiquidityInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  // instrument
  static makeCreatePoolInstructions(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      owner,
      mintA,
      mintB,
      ammConfigId,
      initialPriceX64,
      startTime
    }) {
      const observationId = generatePubKey({ fromPublicKey: owner, programId });
      const poolId = getPdaPoolId(programId, ammConfigId, mintA.mint, mintB.mint).publicKey;
      const mintAVault = getPdaPoolVaultId(programId, poolId, mintA.mint).publicKey;
      const mintBVault = getPdaPoolVaultId(programId, poolId, mintB.mint).publicKey;
      const instructions = [
        SystemProgram5.createAccountWithSeed({
          fromPubkey: owner,
          basePubkey: owner,
          seed: observationId.seed,
          newAccountPubkey: observationId.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption(ObservationInfoLayout.span),
          space: ObservationInfoLayout.span,
          programId
        }),
        createPoolInstruction(
          programId,
          poolId,
          owner,
          ammConfigId,
          observationId.publicKey,
          mintA.mint,
          mintAVault,
          mintA.programId,
          mintB.mint,
          mintBVault,
          mintB.programId,
          getPdaExBitmapAccount(programId, poolId).publicKey,
          initialPriceX64,
          startTime
        )
      ];
      return {
        address: {
          observationId: observationId.publicKey,
          poolId,
          mintAVault,
          mintBVault
        },
        innerTransaction: {
          instructions,
          signers: [],
          instructionTypes: [0 /* createAccount */, 11 /* clmmCreatePool */],
          lookupTableAddress: []
        }
      };
    });
  }
  static makeOpenPositionFromLiquidityInstructions(_0) {
    return __async(this, arguments, function* ({
      poolInfo,
      ownerInfo,
      tickLower,
      tickUpper,
      liquidity,
      amountMaxA,
      amountMaxB,
      withMetadata,
      getEphemeralSigners
    }) {
      const signers = [];
      let nftMintAccount;
      if (getEphemeralSigners) {
        nftMintAccount = new PublicKey16((yield getEphemeralSigners(1))[0]);
      } else {
        const _k = Keypair4.generate();
        signers.push(_k);
        nftMintAccount = _k.publicKey;
      }
      const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
      const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
      const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayLowerStartIndex
      );
      const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayUpperStartIndex
      );
      const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, nftMintAccount, TOKEN_PROGRAM_ID);
      const { publicKey: metadataAccount } = getPdaMetadataKey(nftMintAccount);
      const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, nftMintAccount);
      const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
        poolInfo.programId,
        poolInfo.id,
        tickLower,
        tickUpper
      );
      const ins = openPositionFromLiquidityInstruction(
        poolInfo.programId,
        ownerInfo.feePayer,
        poolInfo.id,
        ownerInfo.wallet,
        nftMintAccount,
        positionNftAccount,
        metadataAccount,
        protocolPosition,
        tickArrayLower,
        tickArrayUpper,
        personalPosition,
        ownerInfo.tokenAccountA,
        ownerInfo.tokenAccountB,
        poolInfo.mintA.vault,
        poolInfo.mintB.vault,
        poolInfo.mintA.mint,
        poolInfo.mintB.mint,
        tickLower,
        tickUpper,
        tickArrayLowerStartIndex,
        tickArrayUpperStartIndex,
        liquidity,
        amountMaxA,
        amountMaxB,
        withMetadata,
        PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
          tickArrayLowerStartIndex,
          tickArrayUpperStartIndex
        ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
      );
      return {
        address: {
          nftMint: nftMintAccount,
          tickArrayLower,
          tickArrayUpper,
          positionNftAccount,
          metadataAccount,
          personalPosition,
          protocolPosition
        },
        innerTransaction: {
          instructions: [ins],
          signers,
          instructionTypes: [12 /* clmmOpenPosition */],
          lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
        }
      };
    });
  }
  static makeOpenPositionFromBaseInstructions(_0) {
    return __async(this, arguments, function* ({
      poolInfo,
      ownerInfo,
      tickLower,
      tickUpper,
      base,
      baseAmount,
      otherAmountMax,
      withMetadata,
      getEphemeralSigners
    }) {
      const signers = [];
      let nftMintAccount;
      if (getEphemeralSigners) {
        nftMintAccount = new PublicKey16((yield getEphemeralSigners(1))[0]);
      } else {
        const _k = Keypair4.generate();
        signers.push(_k);
        nftMintAccount = _k.publicKey;
      }
      const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
      const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
      const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayLowerStartIndex
      );
      const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayUpperStartIndex
      );
      const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, nftMintAccount, TOKEN_PROGRAM_ID);
      const { publicKey: metadataAccount } = getPdaMetadataKey(nftMintAccount);
      const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, nftMintAccount);
      const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
        poolInfo.programId,
        poolInfo.id,
        tickLower,
        tickUpper
      );
      const ins = openPositionFromBaseInstruction(
        poolInfo.programId,
        ownerInfo.feePayer,
        poolInfo.id,
        ownerInfo.wallet,
        nftMintAccount,
        positionNftAccount,
        metadataAccount,
        protocolPosition,
        tickArrayLower,
        tickArrayUpper,
        personalPosition,
        ownerInfo.tokenAccountA,
        ownerInfo.tokenAccountB,
        poolInfo.mintA.vault,
        poolInfo.mintB.vault,
        poolInfo.mintA.mint,
        poolInfo.mintB.mint,
        tickLower,
        tickUpper,
        tickArrayLowerStartIndex,
        tickArrayUpperStartIndex,
        withMetadata,
        base,
        baseAmount,
        otherAmountMax,
        PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
          tickArrayLowerStartIndex,
          tickArrayUpperStartIndex
        ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
      );
      return {
        address: {
          nftMint: nftMintAccount,
          tickArrayLower,
          tickArrayUpper,
          positionNftAccount,
          metadataAccount,
          personalPosition,
          protocolPosition
        },
        innerTransaction: {
          instructions: [ins],
          signers,
          instructionTypes: [12 /* clmmOpenPosition */],
          lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
        }
      };
    });
  }
  static makeIncreasePositionFromLiquidityInstructions({
    poolInfo,
    ownerPosition,
    ownerInfo,
    liquidity,
    amountMaxA,
    amountMaxB
  }) {
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickLower,
      poolInfo.ammConfig.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickUpper,
      poolInfo.ammConfig.tickSpacing
    );
    const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayLowerStartIndex
    );
    const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayUpperStartIndex
    );
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
      poolInfo.programId,
      poolInfo.id,
      ownerPosition.tickLower,
      ownerPosition.tickUpper
    );
    return {
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPosition
      },
      innerTransaction: {
        instructions: [
          increasePositionFromLiquidityInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            positionNftAccount,
            personalPosition,
            poolInfo.id,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            liquidity,
            amountMaxA,
            amountMaxB,
            PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
          )
        ],
        signers: [],
        instructionTypes: [13 /* clmmIncreasePosition */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  static makeIncreasePositionFromBaseInstructions({
    poolInfo,
    ownerPosition,
    ownerInfo,
    base,
    baseAmount,
    otherAmountMax
  }) {
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickLower,
      poolInfo.ammConfig.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickUpper,
      poolInfo.ammConfig.tickSpacing
    );
    const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayLowerStartIndex
    );
    const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayUpperStartIndex
    );
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
      poolInfo.programId,
      poolInfo.id,
      ownerPosition.tickLower,
      ownerPosition.tickUpper
    );
    return {
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPosition
      },
      innerTransaction: {
        instructions: [
          increasePositionFromBaseInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            positionNftAccount,
            personalPosition,
            poolInfo.id,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            base,
            baseAmount,
            otherAmountMax,
            PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
          )
        ],
        signers: [],
        instructionTypes: [13 /* clmmIncreasePosition */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  static makeDecreaseLiquidityInstructions({
    poolInfo,
    ownerPosition,
    ownerInfo,
    liquidity,
    amountMinA,
    amountMinB
  }) {
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickLower,
      poolInfo.ammConfig.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickUpper,
      poolInfo.ammConfig.tickSpacing
    );
    const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayLowerStartIndex
    );
    const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayUpperStartIndex
    );
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
      poolInfo.programId,
      poolInfo.id,
      ownerPosition.tickLower,
      ownerPosition.tickUpper
    );
    const rewardAccounts = [];
    for (let i = 0; i < poolInfo.rewardInfos.length; i++) {
      rewardAccounts.push({
        poolRewardVault: poolInfo.rewardInfos[i].tokenVault,
        ownerRewardVault: ownerInfo.rewardAccounts[i],
        rewardMint: poolInfo.rewardInfos[i].tokenMint
      });
    }
    return {
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPosition
      },
      innerTransaction: {
        instructions: [
          decreaseLiquidityInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            positionNftAccount,
            personalPosition,
            poolInfo.id,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            rewardAccounts,
            liquidity,
            amountMinA,
            amountMinB,
            PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
          )
        ],
        signers: [],
        instructionTypes: [14 /* clmmDecreasePosition */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  static makeClosePositionInstructions({
    poolInfo,
    ownerInfo,
    ownerPosition
  }) {
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    return {
      address: {
        positionNftAccount,
        personalPosition
      },
      innerTransaction: {
        instructions: [
          closePositionInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            ownerPosition.nftMint,
            positionNftAccount,
            personalPosition
          )
        ],
        signers: [],
        instructionTypes: [15 /* clmmClosePosition */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  static makeSwapBaseInInstructions({
    poolInfo,
    ownerInfo,
    inputMint,
    amountIn,
    amountOutMin,
    sqrtPriceLimitX64,
    remainingAccounts
  }) {
    const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
    return {
      address: {},
      innerTransaction: {
        instructions: [
          swapInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            poolInfo.ammConfig.id,
            isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB,
            isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA,
            isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault,
            isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault,
            isInputMintA ? poolInfo.mintA.mint : poolInfo.mintB.mint,
            isInputMintA ? poolInfo.mintB.mint : poolInfo.mintA.mint,
            remainingAccounts,
            poolInfo.observationId,
            amountIn,
            amountOutMin,
            sqrtPriceLimitX64,
            true,
            getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey
          )
        ],
        signers: [],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default)),
        instructionTypes: [16 /* clmmSwapBaseIn */]
      }
    };
  }
  static makeSwapBaseOutInstructions({
    poolInfo,
    ownerInfo,
    outputMint,
    amountOut,
    amountInMax,
    sqrtPriceLimitX64,
    remainingAccounts
  }) {
    const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
    return {
      address: {},
      innerTransaction: {
        instructions: [
          swapInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            poolInfo.ammConfig.id,
            isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA,
            isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB,
            isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault,
            isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault,
            isInputMintA ? poolInfo.mintB.mint : poolInfo.mintA.mint,
            isInputMintA ? poolInfo.mintA.mint : poolInfo.mintB.mint,
            remainingAccounts,
            poolInfo.observationId,
            amountOut,
            amountInMax,
            sqrtPriceLimitX64,
            false,
            getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey
          )
        ],
        signers: [],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default)),
        instructionTypes: [17 /* clmmSwapBaseOut */]
      }
    };
  }
  static makeInitRewardInstructions({
    poolInfo,
    ownerInfo,
    rewardInfo
  }) {
    const poolRewardVault = getPdaPoolRewardVaulId(poolInfo.programId, poolInfo.id, rewardInfo.mint).publicKey;
    const operationId = getPdaOperationAccount(poolInfo.programId).publicKey;
    return {
      address: { poolRewardVault, operationId },
      innerTransaction: {
        instructions: [
          initRewardInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            operationId,
            poolInfo.ammConfig.id,
            ownerInfo.tokenAccount,
            rewardInfo.programId,
            rewardInfo.mint,
            poolRewardVault,
            rewardInfo.openTime,
            rewardInfo.endTime,
            rewardInfo.emissionsPerSecondX64
          )
        ],
        signers: [],
        instructionTypes: [18 /* clmmInitReward */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  static makeSetRewardInstructions({
    poolInfo,
    ownerInfo,
    rewardInfo
  }) {
    let rewardIndex;
    let rewardVault;
    let rewardMint;
    for (let index = 0; index < poolInfo.rewardInfos.length; index++)
      if (poolInfo.rewardInfos[index].tokenMint.equals(rewardInfo.mint)) {
        rewardIndex = index;
        rewardVault = poolInfo.rewardInfos[index].tokenVault;
        rewardMint = poolInfo.rewardInfos[index].tokenMint;
      }
    if (rewardIndex === void 0 || rewardVault === void 0 || rewardMint === void 0)
      throw Error("reward mint check error");
    const operationId = getPdaOperationAccount(poolInfo.programId).publicKey;
    return {
      address: { rewardVault, operationId },
      innerTransaction: {
        instructions: [
          setRewardInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            operationId,
            poolInfo.ammConfig.id,
            ownerInfo.tokenAccount,
            rewardVault,
            rewardMint,
            rewardIndex,
            rewardInfo.openTime,
            rewardInfo.endTime,
            rewardInfo.emissionsPerSecondX64
          )
        ],
        signers: [],
        instructionTypes: [18 /* clmmInitReward */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  static makeCollectRewardInstructions({
    poolInfo,
    ownerInfo,
    rewardMint
  }) {
    let rewardIndex;
    let rewardVault;
    for (let index = 0; index < poolInfo.rewardInfos.length; index++)
      if (poolInfo.rewardInfos[index].tokenMint.equals(rewardMint)) {
        rewardIndex = index;
        rewardVault = poolInfo.rewardInfos[index].tokenVault;
      }
    if (rewardIndex === void 0 || rewardVault === void 0) throw Error("reward mint check error");
    return {
      address: { rewardVault },
      innerTransaction: {
        instructions: [
          collectRewardInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            ownerInfo.tokenAccount,
            rewardVault,
            rewardMint,
            rewardIndex
          )
        ],
        signers: [],
        instructionTypes: [18 /* clmmInitReward */],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey16.default))
      }
    };
  }
  // calculate
  static getLiquidityAmountOutFromAmountIn({
    poolInfo,
    inputA,
    tickLower,
    tickUpper,
    amount,
    slippage,
    add,
    token2022Infos,
    epochInfo,
    amountHasFee
  }) {
    var _a, _b;
    const sqrtPriceX64 = poolInfo.sqrtPriceX64;
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(tickLower);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper);
    const coefficient = add ? 1 - slippage : 1 + slippage;
    const addFeeAmount = getTransferAmountFee(
      amount,
      (_a = token2022Infos[inputA ? poolInfo.mintA.mint.toString() : poolInfo.mintB.mint.toString()]) == null ? void 0 : _a.feeConfig,
      epochInfo,
      !amountHasFee
    );
    const _amount = new BN15(
      new Decimal3(addFeeAmount.amount.sub((_b = addFeeAmount.fee) != null ? _b : ZERO).toString()).mul(coefficient).toFixed(0)
    );
    let liquidity;
    if (sqrtPriceX64.lte(sqrtPriceX64A)) {
      liquidity = inputA ? LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, _amount, !add) : new BN15(0);
    } else if (sqrtPriceX64.lte(sqrtPriceX64B)) {
      const liquidity0 = LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64, sqrtPriceX64B, _amount, !add);
      const liquidity1 = LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64, _amount);
      liquidity = inputA ? liquidity0 : liquidity1;
    } else {
      liquidity = inputA ? new BN15(0) : LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, _amount);
    }
    return this.getAmountsFromLiquidity({
      poolInfo,
      tickLower,
      tickUpper,
      liquidity,
      slippage,
      add,
      token2022Infos,
      epochInfo,
      amountAddFee: amountHasFee
    });
  }
  static getLiquidityFromAmounts({
    poolInfo,
    tickLower,
    tickUpper,
    amountA,
    amountB,
    slippage,
    add,
    token2022Infos,
    epochInfo,
    amountHasFee
  }) {
    var _a, _b, _c, _d;
    const [_tickLower, _tickUpper, _amountA, _amountB] = tickLower < tickUpper ? [tickLower, tickUpper, amountA, amountB] : [tickUpper, tickLower, amountB, amountA];
    const sqrtPriceX64 = poolInfo.sqrtPriceX64;
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(_tickLower);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(_tickUpper);
    const [amountFeeA, amountFeeB] = [
      getTransferAmountFee(
        _amountA,
        (_a = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _a.feeConfig,
        epochInfo,
        !amountHasFee
      ),
      getTransferAmountFee(
        _amountB,
        (_b = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _b.feeConfig,
        epochInfo,
        !amountHasFee
      )
    ];
    const liquidity = LiquidityMath.getLiquidityFromTokenAmounts(
      sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      amountFeeA.amount.sub((_c = amountFeeA.fee) != null ? _c : ZERO),
      amountFeeB.amount.sub((_d = amountFeeB.fee) != null ? _d : ZERO)
    );
    return this.getAmountsFromLiquidity({
      poolInfo,
      tickLower,
      tickUpper,
      liquidity,
      slippage,
      add,
      token2022Infos,
      epochInfo,
      amountAddFee: !amountHasFee
    });
  }
  static getAmountsFromLiquidity({
    poolInfo,
    tickLower,
    tickUpper,
    liquidity,
    slippage,
    add,
    token2022Infos,
    epochInfo,
    amountAddFee
  }) {
    var _a, _b, _c, _d;
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(tickLower);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper);
    const coefficientRe = add ? 1 + slippage : 1 - slippage;
    const amounts = LiquidityMath.getAmountsFromLiquidity(
      poolInfo.sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      add
    );
    const [amountA, amountB] = [
      getTransferAmountFee(
        amounts.amountA,
        (_a = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _a.feeConfig,
        epochInfo,
        amountAddFee
      ),
      getTransferAmountFee(
        amounts.amountB,
        (_b = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _b.feeConfig,
        epochInfo,
        amountAddFee
      )
    ];
    const [amountSlippageA, amountSlippageB] = [
      getTransferAmountFee(
        new BN15(new Decimal3(amounts.amountA.toString()).mul(coefficientRe).toFixed(0)),
        (_c = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _c.feeConfig,
        epochInfo,
        amountAddFee
      ),
      getTransferAmountFee(
        new BN15(new Decimal3(amounts.amountB.toString()).mul(coefficientRe).toFixed(0)),
        (_d = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _d.feeConfig,
        epochInfo,
        amountAddFee
      )
    ];
    return {
      liquidity,
      amountA,
      amountB,
      amountSlippageA,
      amountSlippageB,
      expirationTime: minExpirationTime(amountA.expirationTime, amountB.expirationTime)
    };
  }
  static getPriceAndTick({
    poolInfo,
    price,
    baseIn
  }) {
    const _price = baseIn ? price : new Decimal3(1).div(price);
    const tick = TickMath.getTickWithPriceAndTickspacing(
      _price,
      poolInfo.ammConfig.tickSpacing,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    const tickSqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    const tickPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      tickSqrtPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    return baseIn ? { tick, price: tickPrice } : { tick, price: new Decimal3(1).div(tickPrice) };
  }
  static getTickPrice({
    poolInfo,
    tick,
    baseIn
  }) {
    const tickSqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    const tickPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      tickSqrtPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    return baseIn ? { tick, price: tickPrice, tickSqrtPriceX64 } : { tick, price: new Decimal3(1).div(tickPrice), tickSqrtPriceX64 };
  }
  static computeAmountOutFormat({
    poolInfo,
    tickArrayCache,
    token2022Infos,
    epochInfo,
    amountIn,
    currencyOut,
    slippage,
    catchLiquidityInsufficient = false
  }) {
    const amountInIsTokenAmount = amountIn instanceof TokenAmount;
    const inputMint = (amountInIsTokenAmount ? amountIn.token : Token.WSOL).mint;
    const _amountIn = amountIn.raw;
    const _slippage = slippage.numerator.toNumber() / slippage.denominator.toNumber();
    const {
      allTrade,
      realAmountIn: _realAmountIn,
      amountOut: _amountOut,
      minAmountOut: _minAmountOut,
      expirationTime,
      currentPrice,
      executionPrice,
      priceImpact,
      fee,
      remainingAccounts,
      executionPriceX64
    } = this.computeAmountOut({
      poolInfo,
      tickArrayCache,
      baseMint: inputMint,
      amountIn: _amountIn,
      slippage: _slippage,
      token2022Infos,
      epochInfo,
      catchLiquidityInsufficient
    });
    const realAmountIn = __spreadProps(__spreadValues({}, _realAmountIn), {
      amount: amountInIsTokenAmount ? new TokenAmount(amountIn.token, _realAmountIn.amount) : new CurrencyAmount(Currency.SOL, _realAmountIn.amount),
      fee: _realAmountIn.fee === void 0 ? void 0 : amountInIsTokenAmount ? new TokenAmount(amountIn.token, _realAmountIn.fee) : new CurrencyAmount(Currency.SOL, _realAmountIn.fee)
    });
    const amountOut = __spreadProps(__spreadValues({}, _amountOut), {
      amount: currencyOut instanceof Token ? new TokenAmount(currencyOut, _amountOut.amount) : new CurrencyAmount(currencyOut, _amountOut.amount),
      fee: _amountOut.fee === void 0 ? void 0 : currencyOut instanceof Token ? new TokenAmount(currencyOut, _amountOut.fee) : new CurrencyAmount(currencyOut, _amountOut.fee)
    });
    const minAmountOut = __spreadProps(__spreadValues({}, _minAmountOut), {
      amount: currencyOut instanceof Token ? new TokenAmount(currencyOut, _minAmountOut.amount) : new CurrencyAmount(currencyOut, _minAmountOut.amount),
      fee: _minAmountOut.fee === void 0 ? void 0 : currencyOut instanceof Token ? new TokenAmount(currencyOut, _minAmountOut.fee) : new CurrencyAmount(currencyOut, _minAmountOut.fee)
    });
    const _currentPrice = new Price(
      amountInIsTokenAmount ? amountIn.token : amountIn.currency,
      new BN15(10).pow(new BN15(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)),
      currencyOut instanceof Token ? currencyOut : Token.WSOL,
      currentPrice.mul(new Decimal3(__pow(10, 20 + (currencyOut instanceof Token ? currencyOut : Token.WSOL).decimals))).toFixed(0)
    );
    const _executionPrice = new Price(
      amountInIsTokenAmount ? amountIn.token : amountIn.currency,
      new BN15(10).pow(new BN15(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)),
      currencyOut instanceof Token ? currencyOut : Token.WSOL,
      executionPrice.mul(new Decimal3(__pow(10, 20 + (currencyOut instanceof Token ? currencyOut : Token.WSOL).decimals))).toFixed(0)
    );
    const _fee = amountInIsTokenAmount ? new TokenAmount(amountIn.token, fee) : new CurrencyAmount(amountIn.currency, fee);
    return {
      allTrade,
      realAmountIn,
      amountOut,
      minAmountOut,
      expirationTime,
      currentPrice: _currentPrice,
      executionPrice: _executionPrice,
      priceImpact,
      fee: _fee,
      remainingAccounts,
      executionPriceX64
    };
  }
  static computeAmountOutAndCheckToken(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      tickArrayCache,
      baseMint,
      amountIn,
      slippage,
      priceLimit = new Decimal3(0),
      catchLiquidityInsufficient = false
    }) {
      const epochInfo = yield connection.getEpochInfo();
      const token2022Infos = yield fetchMultipleMintInfos({
        connection,
        mints: [poolInfo.mintA, poolInfo.mintB].filter((i) => i.programId.equals(TOKEN_2022_PROGRAM_ID2)).map((i) => i.mint)
      });
      return this.computeAmountOut({
        poolInfo,
        tickArrayCache,
        baseMint,
        amountIn,
        slippage,
        priceLimit,
        token2022Infos,
        epochInfo,
        catchLiquidityInsufficient
      });
    });
  }
  static computeAmountOut({
    poolInfo,
    tickArrayCache,
    baseMint,
    token2022Infos,
    epochInfo,
    amountIn,
    slippage,
    priceLimit = new Decimal3(0),
    catchLiquidityInsufficient = false
  }) {
    var _a, _b, _c, _d, _e;
    let sqrtPriceLimitX64;
    if (priceLimit.equals(new Decimal3(0))) {
      sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintA.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
    } else {
      sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
        priceLimit,
        poolInfo.mintA.decimals,
        poolInfo.mintB.decimals
      );
    }
    const _inputRealAmountIn = getTransferAmountFee(
      amountIn,
      (_a = token2022Infos[baseMint.toString()]) == null ? void 0 : _a.feeConfig,
      epochInfo,
      false
    );
    const {
      allTrade,
      realTradeAmountIn,
      expectedAmountOut: _expectedAmountOut,
      remainingAccounts,
      executionPrice: _executionPriceX64,
      feeAmount
    } = PoolUtils.getOutputAmountAndRemainAccounts(
      poolInfo,
      tickArrayCache,
      baseMint,
      _inputRealAmountIn.amount.sub((_b = _inputRealAmountIn.fee) != null ? _b : ZERO),
      sqrtPriceLimitX64,
      catchLiquidityInsufficient
    );
    const realAmountIn = getTransferAmountFee(
      realTradeAmountIn,
      (_c = token2022Infos[baseMint.toString()]) == null ? void 0 : _c.feeConfig,
      epochInfo,
      true
    );
    const outMint = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.mintB.mint : poolInfo.mintA.mint;
    const amountOut = getTransferAmountFee(
      _expectedAmountOut,
      (_d = token2022Infos[outMint.toString()]) == null ? void 0 : _d.feeConfig,
      epochInfo,
      false
    );
    const _executionPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      _executionPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new Decimal3(1).div(_executionPrice);
    const _minAmountOut = _expectedAmountOut.mul(new BN15(Math.floor((1 - slippage) * 1e10))).div(new BN15(1e10));
    const minAmountOut = getTransferAmountFee(
      _minAmountOut,
      (_e = token2022Infos[outMint.toString()]) == null ? void 0 : _e.feeConfig,
      epochInfo,
      false
    );
    const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new Decimal3(1).div(poolInfo.currentPrice);
    const _numerator = new Decimal3(executionPrice).sub(poolPrice).abs();
    const _denominator = poolPrice;
    const priceImpact = new Percent(
      new Decimal3(_numerator).mul(__pow(10, 15)).toFixed(0),
      new Decimal3(_denominator).mul(__pow(10, 15)).toFixed(0)
    );
    return {
      allTrade,
      realAmountIn,
      amountOut,
      minAmountOut,
      expirationTime: minExpirationTime(realAmountIn.expirationTime, amountOut.expirationTime),
      currentPrice: poolInfo.currentPrice,
      executionPrice,
      priceImpact,
      fee: feeAmount,
      remainingAccounts,
      executionPriceX64: _executionPriceX64
    };
  }
  static computeAmountInAndCheckToken(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      tickArrayCache,
      baseMint,
      amountOut,
      slippage,
      priceLimit = new Decimal3(0)
    }) {
      const epochInfo = yield connection.getEpochInfo();
      const token2022Infos = yield fetchMultipleMintInfos({
        connection,
        mints: [poolInfo.mintA, poolInfo.mintB].filter((i) => i.programId.equals(TOKEN_2022_PROGRAM_ID2)).map((i) => i.mint)
      });
      return this.computeAmountIn({
        poolInfo,
        tickArrayCache,
        baseMint,
        amountOut,
        slippage,
        priceLimit,
        token2022Infos,
        epochInfo
      });
    });
  }
  static computeAmountIn({
    poolInfo,
    tickArrayCache,
    baseMint,
    token2022Infos,
    epochInfo,
    amountOut,
    slippage,
    priceLimit = new Decimal3(0)
  }) {
    var _a, _b, _c, _d;
    let sqrtPriceLimitX64;
    if (priceLimit.equals(new Decimal3(0))) {
      sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintB.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
    } else {
      sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
        priceLimit,
        poolInfo.mintA.decimals,
        poolInfo.mintB.decimals
      );
    }
    const realAmountOut = getTransferAmountFee(
      amountOut,
      (_a = token2022Infos[baseMint.toString()]) == null ? void 0 : _a.feeConfig,
      epochInfo,
      true
    );
    const {
      expectedAmountIn: _expectedAmountIn,
      remainingAccounts,
      executionPrice: _executionPriceX64,
      feeAmount
    } = PoolUtils.getInputAmountAndRemainAccounts(
      poolInfo,
      tickArrayCache,
      baseMint,
      realAmountOut.amount.sub((_b = realAmountOut.fee) != null ? _b : ZERO),
      sqrtPriceLimitX64
    );
    const inMint = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.mintB.mint : poolInfo.mintA.mint;
    const amountIn = getTransferAmountFee(
      _expectedAmountIn,
      (_c = token2022Infos[inMint.toString()]) == null ? void 0 : _c.feeConfig,
      epochInfo,
      true
    );
    const _executionPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      _executionPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new Decimal3(1).div(_executionPrice);
    const _maxAmountIn = _expectedAmountIn.mul(new BN15(Math.floor((1 + slippage) * 1e10))).div(new BN15(1e10));
    const maxAmountIn = getTransferAmountFee(
      _maxAmountIn,
      (_d = token2022Infos[inMint.toString()]) == null ? void 0 : _d.feeConfig,
      epochInfo,
      true
    );
    const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new Decimal3(1).div(poolInfo.currentPrice);
    const _numerator = new Decimal3(executionPrice).sub(poolPrice).abs();
    const _denominator = poolPrice;
    const priceImpact = new Percent(
      new Decimal3(_numerator).mul(__pow(10, 15)).toFixed(0),
      new Decimal3(_denominator).mul(__pow(10, 15)).toFixed(0)
    );
    return {
      amountIn,
      maxAmountIn,
      realAmountOut,
      expirationTime: minExpirationTime(amountIn.expirationTime, realAmountOut.expirationTime),
      currentPrice: poolInfo.currentPrice,
      executionPrice,
      priceImpact,
      fee: feeAmount,
      remainingAccounts
    };
  }
  static estimateAprsForPriceRangeMultiplier({
    poolInfo,
    aprType,
    positionTickLowerIndex,
    positionTickUpperIndex
  }) {
    const aprInfo = poolInfo[aprType];
    const priceLower = this.getTickPrice({ poolInfo, tick: positionTickLowerIndex, baseIn: true }).price.toNumber();
    const priceUpper = this.getTickPrice({ poolInfo, tick: positionTickUpperIndex, baseIn: true }).price.toNumber();
    const _minPrice = Math.max(priceLower, aprInfo.priceMin);
    const _maxPrice = Math.min(priceUpper, aprInfo.priceMax);
    const sub = _maxPrice - _minPrice;
    const userRange = priceUpper - priceLower;
    const tradeRange = aprInfo.priceMax - aprInfo.priceMin;
    let p;
    if (sub <= 0) p = 0;
    else if (userRange === sub) p = tradeRange / sub;
    else if (tradeRange === sub) p = sub / userRange;
    else p = sub / tradeRange * (sub / userRange);
    return {
      feeApr: aprInfo.feeApr * p,
      rewardsApr: [aprInfo.rewardApr.A * p, aprInfo.rewardApr.B * p, aprInfo.rewardApr.C * p],
      apr: aprInfo.apr * p
    };
  }
  static estimateAprsForPriceRangeDelta({
    poolInfo,
    aprType,
    mintPrice,
    rewardMintDecimals,
    liquidity,
    positionTickLowerIndex,
    positionTickUpperIndex,
    chainTime
  }) {
    const aprTypeDay = aprType === "day" ? 1 : aprType === "week" ? 7 : aprType === "month" ? 30 : 0;
    const aprInfo = poolInfo[aprType];
    const mintPriceA = mintPrice[poolInfo.mintA.mint.toString()];
    const mintPriceB = mintPrice[poolInfo.mintB.mint.toString()];
    const mintDecimalsA = poolInfo.mintA.decimals;
    const mintDecimalsB = poolInfo.mintB.decimals;
    if (!aprInfo || !mintPriceA || !mintPriceB) return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(positionTickLowerIndex);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(positionTickUpperIndex);
    const { amountSlippageA: poolLiquidityA, amountSlippageB: poolLiquidityB } = LiquidityMath.getAmountsFromLiquidityWithSlippage(
      poolInfo.sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      poolInfo.liquidity,
      false,
      false,
      0
    );
    const { amountSlippageA: userLiquidityA, amountSlippageB: userLiquidityB } = LiquidityMath.getAmountsFromLiquidityWithSlippage(
      poolInfo.sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      false,
      false,
      0
    );
    const poolTvl = new Decimal3(poolLiquidityA.toString()).div(new Decimal3(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(
      new Decimal3(poolLiquidityB.toString()).div(new Decimal3(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB))
    );
    const userTvl = new Decimal3(userLiquidityA.toString()).div(new Decimal3(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(
      new Decimal3(userLiquidityB.toString()).div(new Decimal3(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB))
    );
    const p = new Decimal3(1).div(poolTvl.add(userTvl));
    const feesPerYear = new Decimal3(aprInfo.volumeFee).mul(365).div(aprTypeDay);
    const feeApr = feesPerYear.mul(p).mul(100).toNumber();
    const SECONDS_PER_YEAR = 3600 * 24 * 365;
    const rewardsApr = poolInfo.rewardInfos.map((i) => {
      const iDecimal = rewardMintDecimals[i.tokenMint.toString()];
      const iPrice = mintPrice[i.tokenMint.toString()];
      if (chainTime < i.openTime.toNumber() || chainTime > i.endTime.toNumber() || i.perSecond.equals(0) || !iPrice || iDecimal === void 0)
        return 0;
      return new Decimal3(iPrice.toFixed(iDecimal)).mul(i.perSecond.mul(SECONDS_PER_YEAR)).div(new Decimal3(10).pow(iDecimal)).mul(p).mul(100).toNumber();
    });
    return {
      feeApr,
      rewardsApr,
      apr: feeApr + rewardsApr.reduce((a, b) => a + b, 0)
    };
  }
  // fetch data
  static fetchMultiplePoolInfos(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      ownerInfo,
      chainTime,
      batchRequest = false,
      updateOwnerRewardAndFee = true
    }) {
      var _a;
      const poolAccountInfos = yield getMultipleAccountsInfo(
        connection,
        poolKeys.map((i) => new PublicKey16(i.id)),
        { batchRequest }
      );
      const exBitmapAddress = {};
      for (let index = 0; index < poolKeys.length; index++) {
        const apiPoolInfo = poolKeys[index];
        const accountInfo = poolAccountInfos[index];
        if (accountInfo === null) continue;
        exBitmapAddress[apiPoolInfo.id] = getPdaExBitmapAccount(
          accountInfo.owner,
          new PublicKey16(apiPoolInfo.id)
        ).publicKey;
      }
      const exBitmapAccountInfos = yield this.fetchExBitmaps({
        connection,
        exBitmapAddress: Object.values(exBitmapAddress),
        batchRequest
      });
      const programIds = [];
      const poolsInfo = {};
      const updateRewardInfos = [];
      for (let index = 0; index < poolKeys.length; index++) {
        const apiPoolInfo = poolKeys[index];
        const accountInfo = poolAccountInfos[index];
        const exBitmapInfo = exBitmapAccountInfos[exBitmapAddress[apiPoolInfo.id].toString()];
        if (accountInfo === null) continue;
        const layoutAccountInfo = PoolInfoLayout.decode(accountInfo.data);
        poolsInfo[apiPoolInfo.id] = {
          state: {
            id: new PublicKey16(apiPoolInfo.id),
            mintA: {
              programId: new PublicKey16(apiPoolInfo.mintProgramIdA),
              mint: layoutAccountInfo.mintA,
              vault: layoutAccountInfo.vaultA,
              decimals: layoutAccountInfo.mintDecimalsA
            },
            mintB: {
              programId: new PublicKey16(apiPoolInfo.mintProgramIdB),
              mint: layoutAccountInfo.mintB,
              vault: layoutAccountInfo.vaultB,
              decimals: layoutAccountInfo.mintDecimalsB
            },
            observationId: layoutAccountInfo.observationId,
            ammConfig: __spreadProps(__spreadValues({}, apiPoolInfo.ammConfig), {
              id: new PublicKey16(apiPoolInfo.ammConfig.id)
            }),
            creator: layoutAccountInfo.creator,
            programId: accountInfo.owner,
            version: 6,
            tickSpacing: layoutAccountInfo.tickSpacing,
            liquidity: layoutAccountInfo.liquidity,
            sqrtPriceX64: layoutAccountInfo.sqrtPriceX64,
            currentPrice: SqrtPriceMath.sqrtPriceX64ToPrice(
              layoutAccountInfo.sqrtPriceX64,
              layoutAccountInfo.mintDecimalsA,
              layoutAccountInfo.mintDecimalsB
            ),
            tickCurrent: layoutAccountInfo.tickCurrent,
            observationIndex: layoutAccountInfo.observationIndex,
            observationUpdateDuration: layoutAccountInfo.observationUpdateDuration,
            feeGrowthGlobalX64A: layoutAccountInfo.feeGrowthGlobalX64A,
            feeGrowthGlobalX64B: layoutAccountInfo.feeGrowthGlobalX64B,
            protocolFeesTokenA: layoutAccountInfo.protocolFeesTokenA,
            protocolFeesTokenB: layoutAccountInfo.protocolFeesTokenB,
            swapInAmountTokenA: layoutAccountInfo.swapInAmountTokenA,
            swapOutAmountTokenB: layoutAccountInfo.swapOutAmountTokenB,
            swapInAmountTokenB: layoutAccountInfo.swapInAmountTokenB,
            swapOutAmountTokenA: layoutAccountInfo.swapOutAmountTokenA,
            tickArrayBitmap: layoutAccountInfo.tickArrayBitmap,
            rewardInfos: yield PoolUtils.updatePoolRewardInfos({
              connection,
              apiPoolInfo,
              chainTime,
              poolLiquidity: layoutAccountInfo.liquidity,
              rewardInfos: layoutAccountInfo.rewardInfos.filter((i) => !i.tokenMint.equals(PublicKey16.default))
            }),
            day: apiPoolInfo.day,
            week: apiPoolInfo.week,
            month: apiPoolInfo.month,
            tvl: apiPoolInfo.tvl,
            lookupTableAccount: apiPoolInfo.lookupTableAccount ? new PublicKey16(apiPoolInfo.lookupTableAccount) : PublicKey16.default,
            startTime: layoutAccountInfo.startTime.toNumber(),
            exBitmapInfo
          }
        };
        if (ownerInfo) {
          updateRewardInfos.push(
            ...poolsInfo[apiPoolInfo.id].state.rewardInfos.filter((i) => i.creator.equals(ownerInfo.wallet))
          );
        }
        if (!programIds.find((i) => i.equals(accountInfo.owner))) programIds.push(accountInfo.owner);
      }
      if (ownerInfo) {
        const allMint = ownerInfo.tokenAccounts.filter((i) => i.accountInfo.amount.eq(new BN15(1))).map((i) => i.accountInfo.mint);
        const allPositionKey = [];
        for (const itemMint of allMint) {
          for (const itemProgramId of programIds) {
            allPositionKey.push(getPdaPersonalPositionAddress(itemProgramId, itemMint).publicKey);
          }
        }
        const positionAccountInfos = yield getMultipleAccountsInfo(connection, allPositionKey, { batchRequest });
        const keyToTickArrayAddress = {};
        for (const itemAccountInfo of positionAccountInfos) {
          if (itemAccountInfo === null) continue;
          const position = PositionInfoLayout.decode(itemAccountInfo.data);
          const itemPoolId = position.poolId.toString();
          const poolInfoA = poolsInfo[itemPoolId];
          if (poolInfoA === void 0) continue;
          const poolInfo = poolInfoA.state;
          const priceLower = this.getTickPrice({
            poolInfo,
            tick: position.tickLower,
            baseIn: true
          });
          const priceUpper = this.getTickPrice({
            poolInfo,
            tick: position.tickUpper,
            baseIn: true
          });
          const { amountA, amountB } = LiquidityMath.getAmountsFromLiquidity(
            poolInfo.sqrtPriceX64,
            priceLower.tickSqrtPriceX64,
            priceUpper.tickSqrtPriceX64,
            position.liquidity,
            false
          );
          const leverage = 1 / (1 - Math.sqrt(Math.sqrt(priceLower.price.div(priceUpper.price).toNumber())));
          poolsInfo[itemPoolId].positionAccount = [
            ...(_a = poolsInfo[itemPoolId].positionAccount) != null ? _a : [],
            {
              poolId: position.poolId,
              nftMint: position.nftMint,
              priceLower: priceLower.price,
              priceUpper: priceUpper.price,
              amountA,
              amountB,
              tickLower: position.tickLower,
              tickUpper: position.tickUpper,
              liquidity: position.liquidity,
              feeGrowthInsideLastX64A: position.feeGrowthInsideLastX64A,
              feeGrowthInsideLastX64B: position.feeGrowthInsideLastX64B,
              tokenFeesOwedA: position.tokenFeesOwedA,
              tokenFeesOwedB: position.tokenFeesOwedB,
              rewardInfos: position.rewardInfos.map((i) => __spreadProps(__spreadValues({}, i), {
                pendingReward: new BN15(0)
              })),
              leverage,
              tokenFeeAmountA: new BN15(0),
              tokenFeeAmountB: new BN15(0)
            }
          ];
          const tickArrayLowerAddress = TickUtils.getTickArrayAddressByTick(
            poolsInfo[itemPoolId].state.programId,
            position.poolId,
            position.tickLower,
            poolsInfo[itemPoolId].state.tickSpacing
          );
          const tickArrayUpperAddress = TickUtils.getTickArrayAddressByTick(
            poolsInfo[itemPoolId].state.programId,
            position.poolId,
            position.tickUpper,
            poolsInfo[itemPoolId].state.tickSpacing
          );
          keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickLower}`] = tickArrayLowerAddress;
          keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickUpper}`] = tickArrayUpperAddress;
        }
        if (updateOwnerRewardAndFee) {
          const tickArrayKeys = Object.values(keyToTickArrayAddress);
          const tickArrayDatas = yield getMultipleAccountsInfo(connection, tickArrayKeys, { batchRequest });
          const tickArrayLayout = {};
          for (let index = 0; index < tickArrayKeys.length; index++) {
            const tickArrayData = tickArrayDatas[index];
            if (tickArrayData === null) continue;
            const key = tickArrayKeys[index];
            tickArrayLayout[key.toString()] = __spreadValues({
              address: key
            }, TickArrayLayout.decode(tickArrayData.data));
          }
          for (const { state, positionAccount } of Object.values(poolsInfo)) {
            if (!positionAccount) continue;
            for (const itemPA of positionAccount) {
              const keyLower = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickLower}`;
              const keyUpper = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickUpper}`;
              const tickArrayLower = tickArrayLayout[keyToTickArrayAddress[keyLower].toString()];
              const tickArrayUpper = tickArrayLayout[keyToTickArrayAddress[keyUpper].toString()];
              const tickLowerState = tickArrayLower.ticks[TickUtils.getTickOffsetInArray(itemPA.tickLower, state.tickSpacing)];
              const tickUpperState = tickArrayUpper.ticks[TickUtils.getTickOffsetInArray(itemPA.tickUpper, state.tickSpacing)];
              const { tokenFeeAmountA, tokenFeeAmountB } = PositionUtils.GetPositionFees(
                state,
                itemPA,
                tickLowerState,
                tickUpperState
              );
              const rewardInfos = PositionUtils.GetPositionRewards(state, itemPA, tickLowerState, tickUpperState);
              itemPA.tokenFeeAmountA = tokenFeeAmountA.gte(ZERO) && tokenFeeAmountA.lt(U64_IGNORE_RANGE) ? tokenFeeAmountA : ZERO;
              itemPA.tokenFeeAmountB = tokenFeeAmountB.gte(ZERO) && tokenFeeAmountA.lt(U64_IGNORE_RANGE) ? tokenFeeAmountB : ZERO;
              for (let i = 0; i < rewardInfos.length; i++) {
                itemPA.rewardInfos[i].pendingReward = rewardInfos[i].gte(ZERO) && rewardInfos[i].lt(U64_IGNORE_RANGE) ? rewardInfos[i] : ZERO;
              }
            }
          }
        }
      }
      if (updateRewardInfos.length > 0) {
        const vaults = updateRewardInfos.map((i) => i.tokenVault);
        const rewardVaultInfos = yield getMultipleAccountsInfo(connection, vaults, { batchRequest });
        const rewardVaultAmount = {};
        for (let index = 0; index < vaults.length; index++) {
          const valutKey = vaults[index].toString();
          const itemRewardVaultInfo = rewardVaultInfos[index];
          if (itemRewardVaultInfo === null) continue;
          const info = SPL_ACCOUNT_LAYOUT.decode(itemRewardVaultInfo.data);
          rewardVaultAmount[valutKey] = info.amount;
        }
        for (const item of updateRewardInfos) {
          const vaultAmount = rewardVaultAmount[item.tokenVault.toString()];
          item.remainingRewards = vaultAmount !== void 0 ? vaultAmount.sub(item.rewardTotalEmissioned.sub(item.rewardClaimed)) : ZERO;
        }
      }
      return poolsInfo;
    });
  }
  static fetchMultiplePoolTickArrays(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      batchRequest
    }) {
      const tickArraysToPoolId = {};
      const tickArrays = [];
      for (const itemPoolInfo of poolKeys) {
        const currentTickArrayStartIndex = TickUtils.getTickArrayStartIndexByTick(
          itemPoolInfo.tickCurrent,
          itemPoolInfo.tickSpacing
        );
        const startIndexArray = TickUtils.getInitializedTickArrayInRange(
          itemPoolInfo.tickArrayBitmap,
          itemPoolInfo.exBitmapInfo,
          itemPoolInfo.tickSpacing,
          currentTickArrayStartIndex,
          7
        );
        for (const itemIndex of startIndexArray) {
          const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(
            itemPoolInfo.programId,
            itemPoolInfo.id,
            itemIndex
          );
          tickArrays.push({ pubkey: tickArrayAddress });
          tickArraysToPoolId[tickArrayAddress.toString()] = itemPoolInfo.id;
        }
      }
      const fetchedTickArrays = yield getMultipleAccountsInfoWithCustomFlags(connection, tickArrays, { batchRequest });
      const tickArrayCache = {};
      for (const itemAccountInfo of fetchedTickArrays) {
        if (!itemAccountInfo.accountInfo) continue;
        const poolId = tickArraysToPoolId[itemAccountInfo.pubkey.toString()];
        if (!poolId) continue;
        if (tickArrayCache[poolId.toString()] === void 0) tickArrayCache[poolId.toString()] = {};
        const accountLayoutData = TickArrayLayout.decode(itemAccountInfo.accountInfo.data);
        tickArrayCache[poolId.toString()][accountLayoutData.startTickIndex] = __spreadProps(__spreadValues({}, accountLayoutData), {
          address: itemAccountInfo.pubkey
        });
      }
      return tickArrayCache;
    });
  }
  static fetchExBitmaps(_0) {
    return __async(this, arguments, function* ({
      connection,
      exBitmapAddress,
      batchRequest
    }) {
      const fetchedBitmapAccount = yield getMultipleAccountsInfoWithCustomFlags(
        connection,
        exBitmapAddress.map((i) => ({ pubkey: i })),
        { batchRequest }
      );
      const returnTypeFetchExBitmaps = {};
      for (const item of fetchedBitmapAccount) {
        if (item.accountInfo === null) continue;
        returnTypeFetchExBitmaps[item.pubkey.toString()] = TickArrayBitmapExtensionLayout.decode(item.accountInfo.data);
      }
      return returnTypeFetchExBitmaps;
    });
  }
  static getWhiteListMint(_0) {
    return __async(this, arguments, function* ({ connection, programId }) {
      const accountInfo = yield connection.getAccountInfo(getPdaOperationAccount(programId).publicKey);
      if (!accountInfo) return [];
      const whitelistMintsInfo = OperationLayout.decode(accountInfo.data);
      return whitelistMintsInfo.whitelistMints.filter((i) => !i.equals(PublicKey16.default));
    });
  }
};

// src/serum/id.ts
import { PublicKey as PublicKey17 } from "@solana/web3.js";
var _SERUM_PROGRAM_ID_V3 = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin";
var SERUM_PROGRAM_ID_V3 = new PublicKey17(_SERUM_PROGRAM_ID_V3);
var SERUM_PROGRAMID_TO_VERSION = {
  [_SERUM_PROGRAM_ID_V3]: 3
};
var SERUM_VERSION_TO_PROGRAMID = {
  3: SERUM_PROGRAM_ID_V3
};

// src/serum/layout.ts
var MARKET_STATE_LAYOUT_V3 = struct([
  blob(5),
  blob(8),
  // accountFlagsLayout('accountFlags'),
  publicKey("ownAddress"),
  u64("vaultSignerNonce"),
  publicKey("baseMint"),
  publicKey("quoteMint"),
  publicKey("baseVault"),
  u64("baseDepositsTotal"),
  u64("baseFeesAccrued"),
  publicKey("quoteVault"),
  u64("quoteDepositsTotal"),
  u64("quoteFeesAccrued"),
  u64("quoteDustThreshold"),
  publicKey("requestQueue"),
  publicKey("eventQueue"),
  publicKey("bids"),
  publicKey("asks"),
  u64("baseLotSize"),
  u64("quoteLotSize"),
  u64("feeRateBps"),
  u64("referrerRebatesAccrued"),
  blob(7)
]);
var MARKET_VERSION_TO_STATE_LAYOUT = {
  3: MARKET_STATE_LAYOUT_V3
};

// src/serum/serum.ts
import { PublicKey as PublicKey18 } from "@solana/web3.js";
var logger10 = Logger.from("Serum");
var Market = class {
  /* ================= get version and program id ================= */
  static getProgramId(version2) {
    const programId = SERUM_VERSION_TO_PROGRAMID[version2];
    logger10.assertArgument(!!programId, "invalid version", "version", version2);
    return programId;
  }
  static getVersion(programId) {
    const programIdString = programId.toBase58();
    const version2 = SERUM_PROGRAMID_TO_VERSION[programIdString];
    logger10.assertArgument(!!version2, "invalid program id", "programId", programIdString);
    return version2;
  }
  /* ================= get layout ================= */
  static getStateLayout(version2) {
    const STATE_LAYOUT = MARKET_VERSION_TO_STATE_LAYOUT[version2];
    logger10.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
    return STATE_LAYOUT;
  }
  static getLayouts(version2) {
    return { state: this.getStateLayout(version2) };
  }
  /* ================= get key ================= */
  static getAssociatedAuthority({ programId, marketId }) {
    const seeds = [marketId.toBuffer()];
    let nonce = 0;
    let publicKey2;
    while (nonce < 100) {
      try {
        const seedsWithNonce = seeds.concat(Buffer.from([nonce]), Buffer.alloc(7));
        publicKey2 = PublicKey18.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce++;
        continue;
      }
      return { publicKey: publicKey2, nonce };
    }
    return logger10.throwArgumentError("unable to find a viable program address nonce", "params", {
      programId,
      marketId
    });
  }
};

// src/liquidity/stable.ts
import { PublicKey as PublicKey19 } from "@solana/web3.js";
var ModelDataPubkey = new PublicKey19("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo");
var ELEMENT_SIZE = 5e4;
var DataElement = struct([u64("x"), u64("y"), u64("price")]);
var ModelDataInfo = struct([
  u64("accountType"),
  u64("status"),
  u64("multiplier"),
  u64("validDataCount"),
  seq2(DataElement, ELEMENT_SIZE, "DataElement")
]);
function estimateRangeByXyReal(_xReal, _yReal) {
  return [0, ELEMENT_SIZE - 2];
}
function estimateRangeByX(_x) {
  return [0, ELEMENT_SIZE - 2];
}
function estimateRangeByY(_y) {
  return [0, ELEMENT_SIZE - 2];
}
function getMininumRangeByXyReal(layoutData, xReal, yReal) {
  const [min, max] = estimateRangeByXyReal(xReal, yReal);
  let minRangeIdx = min;
  let maxRangeIdx = max;
  let mid = 0;
  const target = xReal * layoutData.multiplier / yReal;
  while (minRangeIdx <= maxRangeIdx) {
    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
    if (mid === 0 || mid >= ELEMENT_SIZE - 2) {
      return [mid, mid, false];
    }
    const cur = layoutData.DataElement[mid].x * layoutData.multiplier / layoutData.DataElement[mid].y;
    const left = layoutData.DataElement[mid - 1].x * layoutData.multiplier / layoutData.DataElement[mid - 1].y;
    const right = layoutData.DataElement[mid + 1].x * layoutData.multiplier / layoutData.DataElement[mid + 1].y;
    if (target === cur) {
      return [mid, mid, true];
    } else if (target === left) {
      return [mid - 1, mid - 1, true];
    } else if (target === right) {
      return [mid + 1, mid + 1, true];
    } else if (target < left) {
      maxRangeIdx = mid - 1;
    } else if (target > left && target < cur) {
      return [mid - 1, mid, true];
    } else if (target > cur && target < right) {
      return [mid, mid + 1, true];
    } else {
      minRangeIdx = mid + 1;
    }
  }
  return [mid, mid, false];
}
function getRatio(layoutData, xReal, yReal) {
  const [minRangeIdx, maxRangeIdx, find] = getMininumRangeByXyReal(layoutData, xReal, yReal);
  if (!find) {
    return 0;
  }
  if (minRangeIdx === maxRangeIdx) {
    const x = layoutData.DataElement[minRangeIdx].x;
    const ratio = xReal * layoutData.multiplier / x;
    return ratio;
  } else {
    const x1 = layoutData.DataElement[minRangeIdx].x;
    const y1 = layoutData.DataElement[minRangeIdx].y;
    const x2 = layoutData.DataElement[maxRangeIdx].x;
    const y2 = layoutData.DataElement[maxRangeIdx].y;
    const xDenominator = yReal * (x2 * y1 - x1 * y2);
    const xNumerator1 = x1 * xDenominator;
    const xNumerator2 = (x2 - x1) * (xReal * y1 - x1 * yReal) * y2;
    const xNumerator = xNumerator1 + xNumerator2;
    const ratio = xReal * layoutData.multiplier * xDenominator / xNumerator;
    return ratio;
  }
}
function realToTable(layoutData, realValue, ratio) {
  return realValue * layoutData.multiplier / ratio;
}
function tableToReal(layoutData, tableValue, ratio) {
  return tableValue * ratio / layoutData.multiplier;
}
function getMinimumRangeByX(layoutData, x) {
  const [min, max] = estimateRangeByX(x);
  let minRangeIdx = min;
  let maxRangeIdx = max;
  let mid = 0;
  const target = x;
  while (minRangeIdx < maxRangeIdx) {
    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
    if (mid <= 0 || mid > ELEMENT_SIZE - 2) {
      return [mid, mid, false];
    }
    const cur = layoutData.DataElement[mid].x;
    const left = layoutData.DataElement[mid - 1].x;
    const right = layoutData.DataElement[mid + 1].x;
    if (target === cur) return [mid, mid, true];
    else if (target === left) return [mid - 1, mid - 1, true];
    else if (target === right) return [mid + 1, mid + 1, true];
    else if (target < left) maxRangeIdx = mid - 1;
    else if (target > left && target < cur) return [mid - 1, mid, true];
    else if (target > cur && target < right) return [mid, mid + 1, true];
    else minRangeIdx = mid + 1;
  }
  return [mid, mid, false];
}
function getMinimumRangeByY(layoutData, y) {
  const [min, max] = estimateRangeByY(y);
  let minRangeIdx = min;
  let maxRangeIdx = max;
  let mid = 0;
  const target = y;
  while (minRangeIdx <= maxRangeIdx) {
    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
    if (mid <= 0 || mid >= ELEMENT_SIZE - 2) {
      return [mid, mid, false];
    }
    const cur = layoutData.DataElement[mid].y;
    const left = layoutData.DataElement[mid - 1].y;
    const right = layoutData.DataElement[mid + 1].y;
    if (target === cur) return [mid, mid, true];
    else if (target === left) return [mid - 1, mid - 1, true];
    else if (target === right) return [mid + 1, mid + 1, true];
    else if (target < right) {
      minRangeIdx = mid + 1;
    } else if (target < left && target > cur) return [mid - 1, mid, true];
    else if (target < cur && target > right) return [mid, mid + 1, true];
    else maxRangeIdx = mid - 1;
  }
  return [mid, mid, false];
}
function getDataByX(layoutData, x, dx, priceUp) {
  const xWithDx = priceUp ? x + dx : x - dx;
  const [minIdx, maxIdx, find] = getMinimumRangeByX(layoutData, xWithDx);
  if (!find) return [0, 0, false, find];
  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].y, false, find];
  else {
    const x1 = layoutData.DataElement[minIdx].x;
    const x2 = layoutData.DataElement[maxIdx].x;
    const p1 = layoutData.DataElement[minIdx].price;
    const p2 = layoutData.DataElement[maxIdx].price;
    const y1 = layoutData.DataElement[minIdx].y;
    const y2 = layoutData.DataElement[maxIdx].y;
    if (x >= x1 && x <= x2) {
      if (priceUp) return [p2, y2, true, find];
      else return [p1, y1, true, find];
    } else {
      let p, y;
      if (priceUp) {
        p = p1 + (p2 - p1) * (x - x1) / (x2 - x1);
        y = y1 - (xWithDx - x1) * layoutData.multiplier / p2;
      } else {
        p = p1 + (p2 - p1) * (x - x1) / (x2 - x1);
        y = y2 + (x2 - xWithDx) * layoutData.multiplier / p1;
      }
      return [p, y, false, find];
    }
  }
}
function getDataByY(layoutData, y, dy, priceUp) {
  const yWithDy = priceUp ? y - dy : y + dy;
  const [minIdx, maxIdx, find] = getMinimumRangeByY(layoutData, yWithDy);
  if (!find) return [0, 0, false, find];
  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].x, false, find];
  else {
    const x1 = layoutData.DataElement[minIdx].x;
    const x2 = layoutData.DataElement[maxIdx].x;
    const p1 = layoutData.DataElement[minIdx].price;
    const p2 = layoutData.DataElement[maxIdx].price;
    const y1 = layoutData.DataElement[minIdx].y;
    const y2 = layoutData.DataElement[maxIdx].y;
    if (y >= y2 && y <= y1) {
      return priceUp ? [p2, x2, true, find] : [p1, x1, true, find];
    } else {
      let p, x;
      if (priceUp) {
        p = p1 + (p2 - p1) * (y1 - y) / (y1 - y2);
        x = x1 + p2 * (y1 - yWithDy) / layoutData.multiplier;
      } else {
        p = p1 + (p2 - p1) * (y1 - y) / (y1 - y2);
        x = x2 - p1 * (yWithDy - y2) / layoutData.multiplier;
      }
      return [p, x, false, find];
    }
  }
}
function getMidPrice(layoutData, x) {
  const ret = getDataByX(layoutData, x, 0, false);
  if (ret[3]) return ret[0];
  else return 0;
}
function getDyByDxBaseIn(layoutData, xReal, yReal, dxReal) {
  const ratio = getRatio(layoutData, xReal, yReal);
  const x = realToTable(layoutData, xReal, ratio);
  const y = realToTable(layoutData, yReal, ratio);
  const dx = realToTable(layoutData, dxReal, ratio);
  const priceUp = true;
  const [p, y2, lessTrade, find] = getDataByX(layoutData, x, dx, priceUp);
  if (!find) return 0;
  if (lessTrade) {
    const dyReal = dxReal * layoutData.multiplier / p;
    return dyReal;
  } else {
    const dy = y - y2;
    const dyReal = tableToReal(layoutData, dy, ratio);
    return dyReal;
  }
}
function getDxByDyBaseIn(layoutData, xReal, yReal, dyReal) {
  const ratio = getRatio(layoutData, xReal, yReal);
  const x = realToTable(layoutData, xReal, ratio);
  const y = realToTable(layoutData, yReal, ratio);
  const dy = realToTable(layoutData, dyReal, ratio);
  const priceUp = false;
  const [p, x2, lessTrade, find] = getDataByY(layoutData, y, dy, priceUp);
  if (!find) return 0;
  if (lessTrade) {
    const dxReal = dyReal * p / layoutData.multiplier;
    return dxReal;
  } else {
    const dx = x - x2;
    const dxReal = tableToReal(layoutData, dx, ratio);
    return dxReal;
  }
}
function formatLayout(buffer) {
  const layoutInfo = ModelDataInfo.decode(buffer);
  return {
    accountType: layoutInfo.accountType.toNumber(),
    status: layoutInfo.status.toNumber(),
    multiplier: layoutInfo.multiplier.toNumber(),
    validDataCount: layoutInfo.validDataCount.toNumber(),
    DataElement: layoutInfo.DataElement.map((item) => ({
      x: item.x.toNumber(),
      y: item.y.toNumber(),
      price: item.price.toNumber()
    }))
  };
}
function getStablePrice(layoutData, coinReal, pcReal, baseCoin) {
  const price = getMidPrice(layoutData, realToTable(layoutData, coinReal, getRatio(layoutData, coinReal, pcReal))) / layoutData.multiplier;
  return baseCoin ? price : 1 / price;
}

// src/liquidity/liquidity.ts
var logger11 = Logger.from("Liquidity");
var modelData = {
  accountType: 0,
  status: 0,
  multiplier: 0,
  validDataCount: 0,
  DataElement: []
};
function initStableModelLayout(connection) {
  return __async(this, null, function* () {
    if (modelData.validDataCount === 0) {
      if (connection) {
        const acc = yield connection.getAccountInfo(ModelDataPubkey);
        if (acc) modelData = formatLayout(acc == null ? void 0 : acc.data);
      }
    }
  });
}
var LiquidityPoolStatus = /* @__PURE__ */ ((LiquidityPoolStatus2) => {
  LiquidityPoolStatus2[LiquidityPoolStatus2["Uninitialized"] = 0] = "Uninitialized";
  LiquidityPoolStatus2[LiquidityPoolStatus2["Initialized"] = 1] = "Initialized";
  LiquidityPoolStatus2[LiquidityPoolStatus2["Disabled"] = 2] = "Disabled";
  LiquidityPoolStatus2[LiquidityPoolStatus2["RemoveLiquidityOnly"] = 3] = "RemoveLiquidityOnly";
  LiquidityPoolStatus2[LiquidityPoolStatus2["LiquidityOnly"] = 4] = "LiquidityOnly";
  LiquidityPoolStatus2[LiquidityPoolStatus2["OrderBook"] = 5] = "OrderBook";
  LiquidityPoolStatus2[LiquidityPoolStatus2["Swap"] = 6] = "Swap";
  LiquidityPoolStatus2[LiquidityPoolStatus2["WaitingForStart"] = 7] = "WaitingForStart";
  return LiquidityPoolStatus2;
})(LiquidityPoolStatus || {});
var LIQUIDITY_FEES_NUMERATOR = new BN16(25);
var LIQUIDITY_FEES_DENOMINATOR = new BN16(1e4);
var _Liquidity = class _Liquidity extends Base {
  // public connection: Connection;
  // public poolKeys: LiquidityPoolKeys;
  // public poolInfo: LiquidityPoolInfo;
  // constructor({ connection, poolKeys, poolInfo }: LiquidityConstructParams) {
  //   this.connection = connection;
  //   this.poolKeys = poolKeys;
  //   this.poolInfo = poolInfo;
  // }
  // static async load({ connection, poolKeys, poolInfo }: LiquidityLoadParams) {
  //   const _poolInfo = poolInfo || (await this.fetchInfo({ connection, poolKeys }));
  //   return new Liquidity({ connection, poolKeys, poolInfo: _poolInfo });
  // }
  /* ================= get version and program id ================= */
  // static getProgramId(version: number) {
  //   const programId = LIQUIDITY_VERSION_TO_PROGRAMID[version];
  //   logger.assertArgument(!!programId, "invalid version", "version", version);
  //   return programId;
  // }
  // static getVersion(programId: PublicKey) {
  //   const programIdString = programId.toBase58();
  //   const version = LIQUIDITY_PROGRAMID_TO_VERSION[programIdString];
  //   logger.assertArgument(!!version, "invalid program id", "programId", programIdString);
  //   return version;
  // }
  // static getSerumVersion(version: number) {
  //   const serumVersion = LIQUIDITY_VERSION_TO_SERUM_VERSION[version];
  //   logger.assertArgument(!!serumVersion, "invalid version", "version", version);
  //   return serumVersion;
  // }
  /* ================= get layout ================= */
  static getStateLayout(version2) {
    const STATE_LAYOUT = LIQUIDITY_VERSION_TO_STATE_LAYOUT[version2];
    logger11.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
    return STATE_LAYOUT;
  }
  static getLayouts(version2) {
    return { state: this.getStateLayout(version2) };
  }
  /* ================= get key ================= */
  static getAssociatedId({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("amm_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedAuthority({ programId }) {
    return findProgramAddress(
      // new Uint8Array(Buffer.from('amm authority'.replace('\u00A0', ' '), 'utf-8'))
      [Buffer.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])],
      programId
    );
  }
  static getAssociatedBaseVault({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("coin_vault_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedQuoteVault({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("pc_vault_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedLpMint({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("lp_mint_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedLpVault({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("temp_lp_token_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedTargetOrders({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("target_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedWithdrawQueue({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("withdraw_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedOpenOrders({ programId, marketId }) {
    const { publicKey: publicKey2 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("open_order_associated_seed", "utf-8")],
      programId
    );
    return publicKey2;
  }
  static getAssociatedConfigId({ programId }) {
    const { publicKey: publicKey2 } = findProgramAddress([Buffer.from("amm_config_account_seed", "utf-8")], programId);
    return publicKey2;
  }
  static getAssociatedPoolKeys({
    version: version2,
    marketVersion,
    marketId,
    baseMint,
    quoteMint,
    baseDecimals,
    quoteDecimals,
    programId,
    marketProgramId
  }) {
    const id = this.getAssociatedId({ programId, marketId });
    const lpMint = this.getAssociatedLpMint({ programId, marketId });
    const { publicKey: authority, nonce } = this.getAssociatedAuthority({ programId });
    const baseVault = this.getAssociatedBaseVault({ programId, marketId });
    const quoteVault = this.getAssociatedQuoteVault({ programId, marketId });
    const lpVault = this.getAssociatedLpVault({ programId, marketId });
    const openOrders = this.getAssociatedOpenOrders({ programId, marketId });
    const targetOrders = this.getAssociatedTargetOrders({ programId, marketId });
    const withdrawQueue = this.getAssociatedWithdrawQueue({ programId, marketId });
    const { publicKey: marketAuthority } = Market.getAssociatedAuthority({
      programId: marketProgramId,
      marketId
    });
    return {
      // base
      id,
      baseMint,
      quoteMint,
      lpMint,
      baseDecimals,
      quoteDecimals,
      lpDecimals: baseDecimals,
      // version
      version: version2,
      programId,
      // keys
      authority,
      nonce,
      baseVault,
      quoteVault,
      lpVault,
      openOrders,
      targetOrders,
      withdrawQueue,
      // market version
      marketVersion,
      marketProgramId,
      // market keys
      marketId,
      marketAuthority,
      lookupTableAccount: PublicKey20.default,
      configId: this.getAssociatedConfigId({ programId })
    };
  }
  static getCreatePoolFee(_0) {
    return __async(this, arguments, function* ({ connection, programId }) {
      const configId = this.getAssociatedConfigId({ programId });
      const layout = struct([u64("fee")]);
      const account = yield connection.getAccountInfo(configId, { dataSlice: { offset: 536, length: 8 } });
      if (account === null) throw Error("get config account error");
      return layout.decode(account.data).fee;
    });
  }
  /* ================= make instruction and transaction ================= */
  static makeAddLiquidityInstruction(params) {
    const { poolKeys, userKeys, baseAmountIn, quoteAmountIn, fixedSide } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 4 || version2 === 5) {
      const LAYOUT = struct([u82("instruction"), u64("baseAmountIn"), u64("quoteAmountIn"), u64("fixedSide")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 3,
          baseAmountIn: parseBigNumberish(baseAmountIn),
          quoteAmountIn: parseBigNumberish(quoteAmountIn),
          fixedSide: parseBigNumberish(fixedSide === "base" ? 0 : 1)
        },
        data
      );
      const keys = [
        // system
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        // amm
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.authority, false),
        AccountMetaReadonly(poolKeys.openOrders, false),
        AccountMeta(poolKeys.targetOrders, false),
        AccountMeta(poolKeys.lpMint, false),
        AccountMeta(poolKeys.baseVault, false),
        AccountMeta(poolKeys.quoteVault, false)
      ];
      if (version2 === 5) {
        keys.push(AccountMeta(ModelDataPubkey, false));
      }
      keys.push(
        // serum
        AccountMetaReadonly(poolKeys.marketId, false),
        // user
        AccountMeta(userKeys.baseTokenAccount, false),
        AccountMeta(userKeys.quoteTokenAccount, false),
        AccountMeta(userKeys.lpTokenAccount, false),
        AccountMetaReadonly(userKeys.owner, true),
        AccountMetaReadonly(poolKeys.marketEventQueue, false)
      );
      return {
        address: {},
        innerTransaction: {
          instructions: [
            new TransactionInstruction10({
              programId: poolKeys.programId,
              keys,
              data
            })
          ],
          signers: [],
          lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey20.default)),
          instructionTypes: [version2 === 4 ? 22 /* ammV4AddLiquidity */ : 30 /* ammV5AddLiquidity */]
        }
      };
    }
    return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeAddLiquidityInstructionSimple(params) {
    return __async(this, null, function* () {
      const {
        connection,
        poolKeys,
        userKeys,
        amountInA,
        amountInB,
        fixedSide,
        config,
        makeTxVersion,
        lookupTableCache,
        computeBudgetConfig
      } = params;
      const { lpMint } = poolKeys;
      const { tokenAccounts, owner, payer = owner } = userKeys;
      logger11.debug("amountInA:", amountInA);
      logger11.debug("amountInB:", amountInB);
      logger11.assertArgument(
        !amountInA.isZero() && !amountInB.isZero(),
        "amounts must greater than zero",
        "amountInA & amountInB",
        {
          amountInA: amountInA.toFixed(),
          amountInB: amountInB.toFixed()
        }
      );
      const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config);
      const tokenA = amountInA instanceof TokenAmount ? amountInA.token : Token.WSOL;
      const tokenB = amountInB instanceof TokenAmount ? amountInB.token : Token.WSOL;
      const tokenAccountA = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenA.mint,
        owner,
        config: { associatedOnly: false }
      });
      const tokenAccountB = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenB.mint,
        owner,
        config: { associatedOnly: false }
      });
      logger11.assertArgument(
        !!tokenAccountA || !!tokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        tokenAccounts
      );
      const lpTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: lpMint,
        owner
      });
      const tokens = [tokenA, tokenB];
      const _tokenAccounts = [tokenAccountA, tokenAccountB];
      const rawAmounts = [amountInA.raw, amountInB.raw];
      const [sideA] = this._getAmountsSide(amountInA, amountInB, poolKeys);
      let _fixedSide = "base";
      if (sideA === "quote") {
        tokens.reverse();
        _tokenAccounts.reverse();
        rawAmounts.reverse();
        if (fixedSide === "a") _fixedSide = "quote";
        else if (fixedSide === "b") _fixedSide = "base";
        else return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
      } else if (sideA === "base") {
        if (fixedSide === "a") _fixedSide = "base";
        else if (fixedSide === "b") _fixedSide = "quote";
        else return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
      } else return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
      const [baseToken, quoteToken] = tokens;
      const [baseTokenAccount, quoteTokenAccount] = _tokenAccounts;
      const [baseAmountRaw, quoteAmountRaw] = rawAmounts;
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const _baseTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "in",
        amount: baseAmountRaw,
        mint: baseToken.mint,
        tokenAccount: baseTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      });
      const _quoteTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "in",
        amount: quoteAmountRaw,
        mint: quoteToken.mint,
        tokenAccount: quoteTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      });
      const _lpTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: lpMint,
        tokenAccount: lpTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      });
      const ins = this.makeAddLiquidityInstruction({
        poolKeys,
        userKeys: {
          baseTokenAccount: _baseTokenAccount,
          quoteTokenAccount: _quoteTokenAccount,
          lpTokenAccount: _lpTokenAccount,
          owner
        },
        baseAmountIn: baseAmountRaw,
        quoteAmountIn: quoteAmountRaw,
        fixedSide: _fixedSide
      });
      return {
        address: {
          lpTokenAccount: _lpTokenAccount
        },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeRemoveLiquidityInstruction(params) {
    const { poolKeys, userKeys, amountIn } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 4 || version2 === 5) {
      const LAYOUT = struct([u82("instruction"), u64("amountIn")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 4,
          amountIn: parseBigNumberish(amountIn)
        },
        data
      );
      const keys = [
        // system
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        // amm
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.authority, false),
        AccountMeta(poolKeys.openOrders, false),
        AccountMeta(poolKeys.targetOrders, false),
        AccountMeta(poolKeys.lpMint, false),
        AccountMeta(poolKeys.baseVault, false),
        AccountMeta(poolKeys.quoteVault, false)
      ];
      if (version2 === 5) {
        keys.push(AccountMeta(ModelDataPubkey, false));
      } else {
        keys.push(AccountMeta(poolKeys.withdrawQueue, false));
        keys.push(AccountMeta(poolKeys.lpVault, false));
      }
      keys.push(
        // serum
        AccountMetaReadonly(poolKeys.marketProgramId, false),
        AccountMeta(poolKeys.marketId, false),
        AccountMeta(poolKeys.marketBaseVault, false),
        AccountMeta(poolKeys.marketQuoteVault, false),
        AccountMetaReadonly(poolKeys.marketAuthority, false),
        // user
        AccountMeta(userKeys.lpTokenAccount, false),
        AccountMeta(userKeys.baseTokenAccount, false),
        AccountMeta(userKeys.quoteTokenAccount, false),
        AccountMetaReadonly(userKeys.owner, true),
        // serum orderbook
        AccountMeta(poolKeys.marketEventQueue, false),
        AccountMeta(poolKeys.marketBids, false),
        AccountMeta(poolKeys.marketAsks, false)
      );
      return {
        address: {},
        innerTransaction: {
          instructions: [
            new TransactionInstruction10({
              programId: poolKeys.programId,
              keys,
              data
            })
          ],
          signers: [],
          lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey20.default)),
          instructionTypes: [
            version2 === 4 ? 23 /* ammV4RemoveLiquidity */ : 31 /* ammV5RemoveLiquidity */
          ]
        }
      };
    }
    return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeRemoveLiquidityInstructionSimple(params) {
    return __async(this, null, function* () {
      const { connection, poolKeys, userKeys, amountIn, config, makeTxVersion, lookupTableCache, computeBudgetConfig } = params;
      const { baseMint, quoteMint, lpMint } = poolKeys;
      const { tokenAccounts, owner, payer = owner } = userKeys;
      logger11.debug("amountIn:", amountIn);
      logger11.assertArgument(!amountIn.isZero(), "amount must greater than zero", "amountIn", amountIn.toFixed());
      logger11.assertArgument(
        amountIn instanceof TokenAmount && amountIn.token.mint.equals(lpMint),
        "amountIn's token not match lpMint",
        "amountIn",
        amountIn
      );
      const lpTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: lpMint,
        owner,
        config: { associatedOnly: false }
      });
      if (!lpTokenAccount) return logger11.throwArgumentError("cannot found lpTokenAccount", "tokenAccounts", tokenAccounts);
      const baseTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: baseMint,
        owner
      });
      const quoteTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: quoteMint,
        owner
      });
      const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const _lpTokenAccount = lpTokenAccount;
      const _baseTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: baseMint,
        tokenAccount: baseTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const _quoteTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: quoteMint,
        tokenAccount: quoteTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const ins = this.makeRemoveLiquidityInstruction({
        poolKeys,
        userKeys: {
          lpTokenAccount: _lpTokenAccount,
          baseTokenAccount: _baseTokenAccount,
          quoteTokenAccount: _quoteTokenAccount,
          owner
        },
        amountIn: amountIn.raw
      });
      return {
        address: {
          lpTokenAccount: _lpTokenAccount
        },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSwapInstruction(params) {
    const { poolKeys, userKeys, amountIn, amountOut, fixedSide } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 4 || version2 === 5) {
      if (fixedSide === "in") {
        return this.makeSwapFixedInInstruction(
          {
            poolKeys,
            userKeys,
            amountIn,
            minAmountOut: amountOut
          },
          version2
        );
      } else if (fixedSide === "out") {
        return this.makeSwapFixedOutInstruction(
          {
            poolKeys,
            userKeys,
            maxAmountIn: amountIn,
            amountOut
          },
          version2
        );
      }
      return logger11.throwArgumentError("invalid params", "params", params);
    }
    return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeSwapFixedInInstruction({ poolKeys, userKeys, amountIn, minAmountOut }, version2) {
    const LAYOUT = struct([u82("instruction"), u64("amountIn"), u64("minAmountOut")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 9,
        amountIn: parseBigNumberish(amountIn),
        minAmountOut: parseBigNumberish(minAmountOut)
      },
      data
    );
    const keys = [
      // system
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      // amm
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.openOrders, false)
    ];
    if (version2 === 4) {
      keys.push(AccountMeta(poolKeys.targetOrders, false));
    }
    keys.push(AccountMeta(poolKeys.baseVault, false), AccountMeta(poolKeys.quoteVault, false));
    if (version2 === 5) {
      keys.push(AccountMeta(ModelDataPubkey, false));
    }
    keys.push(
      // serum
      AccountMetaReadonly(poolKeys.marketProgramId, false),
      AccountMeta(poolKeys.marketId, false),
      AccountMeta(poolKeys.marketBids, false),
      AccountMeta(poolKeys.marketAsks, false),
      AccountMeta(poolKeys.marketEventQueue, false),
      AccountMeta(poolKeys.marketBaseVault, false),
      AccountMeta(poolKeys.marketQuoteVault, false),
      AccountMetaReadonly(poolKeys.marketAuthority, false),
      // user
      AccountMeta(userKeys.tokenAccountIn, false),
      AccountMeta(userKeys.tokenAccountOut, false),
      AccountMetaReadonly(userKeys.owner, true)
    );
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction10({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey20.default)),
        instructionTypes: [version2 === 4 ? 25 /* ammV4SwapBaseIn */ : 33 /* ammV5SwapBaseIn */]
      }
    };
  }
  static makeSwapFixedOutInstruction({ poolKeys, userKeys, maxAmountIn, amountOut }, version2) {
    const LAYOUT = struct([u82("instruction"), u64("maxAmountIn"), u64("amountOut")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 11,
        maxAmountIn: parseBigNumberish(maxAmountIn),
        amountOut: parseBigNumberish(amountOut)
      },
      data
    );
    const keys = [
      // system
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      // amm
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.openOrders, false),
      AccountMeta(poolKeys.targetOrders, false),
      AccountMeta(poolKeys.baseVault, false),
      AccountMeta(poolKeys.quoteVault, false)
    ];
    if (version2 === 5) {
      keys.push(AccountMeta(ModelDataPubkey, false));
    }
    keys.push(
      // serum
      AccountMetaReadonly(poolKeys.marketProgramId, false),
      AccountMeta(poolKeys.marketId, false),
      AccountMeta(poolKeys.marketBids, false),
      AccountMeta(poolKeys.marketAsks, false),
      AccountMeta(poolKeys.marketEventQueue, false),
      AccountMeta(poolKeys.marketBaseVault, false),
      AccountMeta(poolKeys.marketQuoteVault, false),
      AccountMetaReadonly(poolKeys.marketAuthority, false),
      // user
      AccountMeta(userKeys.tokenAccountIn, false),
      AccountMeta(userKeys.tokenAccountOut, false),
      AccountMetaReadonly(userKeys.owner, true)
    );
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction10({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey20.default)),
        instructionTypes: [version2 === 4 ? 26 /* ammV4SwapBaseOut */ : 34 /* ammV5SwapBaseOut */]
      }
    };
  }
  static makeSwapInstructionSimple(params) {
    return __async(this, null, function* () {
      const {
        connection,
        poolKeys,
        userKeys,
        amountIn,
        amountOut,
        fixedSide,
        config,
        makeTxVersion,
        lookupTableCache,
        computeBudgetConfig
      } = params;
      const { tokenAccounts, owner, payer = owner } = userKeys;
      logger11.debug("amountIn:", amountIn);
      logger11.debug("amountOut:", amountOut);
      logger11.assertArgument(
        !amountIn.isZero() && !amountOut.isZero(),
        "amounts must greater than zero",
        "currencyAmounts",
        {
          amountIn: amountIn.toFixed(),
          amountOut: amountOut.toFixed()
        }
      );
      const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config);
      const tokenIn = amountIn instanceof TokenAmount ? amountIn.token : Token.WSOL;
      const tokenOut = amountOut instanceof TokenAmount ? amountOut.token : Token.WSOL;
      const tokenAccountIn = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenIn.mint,
        owner,
        config: { associatedOnly: false }
      });
      const tokenAccountOut = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenOut.mint,
        owner
      });
      const [amountInRaw, amountOutRaw] = [amountIn.raw, amountOut.raw];
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const _tokenAccountIn = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "in",
        amount: amountInRaw,
        mint: tokenIn.mint,
        tokenAccount: tokenAccountIn,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const _tokenAccountOut = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: tokenOut.mint,
        tokenAccount: tokenAccountOut,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const ins = this.makeSwapInstruction({
        poolKeys,
        userKeys: {
          tokenAccountIn: _tokenAccountIn,
          tokenAccountOut: _tokenAccountOut,
          owner
        },
        amountIn: amountInRaw,
        amountOut: amountOutRaw,
        fixedSide
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSimulatePoolInfoInstruction({ poolKeys }) {
    const LAYOUT = struct([u82("instruction"), u82("simulateType")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 12,
        simulateType: 0
      },
      data
    );
    const keys = [
      // amm
      AccountMetaReadonly(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMetaReadonly(poolKeys.openOrders, false),
      AccountMetaReadonly(poolKeys.baseVault, false),
      AccountMetaReadonly(poolKeys.quoteVault, false),
      AccountMetaReadonly(poolKeys.lpMint, false),
      // serum
      AccountMetaReadonly(poolKeys.marketId, false),
      AccountMetaReadonly(poolKeys.marketEventQueue, false)
    ];
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction10({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey20.default)),
        instructionTypes: [
          poolKeys.version === 4 ? 24 /* ammV4SimulatePoolInfo */ : 32 /* ammV5SimulatePoolInfo */
        ]
      }
    };
  }
  static isV4(lsl) {
    return lsl.withdrawQueue !== void 0;
  }
  static makeCreatePoolV4InstructionV2Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      marketInfo,
      baseMintInfo,
      quoteMintInfo,
      baseAmount,
      quoteAmount,
      startTime,
      ownerInfo,
      associatedOnly = false,
      computeBudgetConfig,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      feeDestinationId
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && baseMintInfo.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && quoteMintInfo.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountBase = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: baseMintInfo.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: baseAmount,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintAUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountQuote = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: quoteMintInfo.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: quoteAmount,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintBUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      if (ownerTokenAccountBase === void 0 || ownerTokenAccountQuote === void 0)
        throw Error("you don't has some token account");
      const poolInfo = _Liquidity.getAssociatedPoolKeys({
        version: 4,
        marketVersion: 3,
        marketId: marketInfo.marketId,
        baseMint: baseMintInfo.mint,
        quoteMint: quoteMintInfo.mint,
        baseDecimals: baseMintInfo.decimals,
        quoteDecimals: quoteMintInfo.decimals,
        programId,
        marketProgramId: marketInfo.programId
      });
      const ins = this.makeCreatePoolV4InstructionV2({
        programId,
        ammId: poolInfo.id,
        ammAuthority: poolInfo.authority,
        ammOpenOrders: poolInfo.openOrders,
        lpMint: poolInfo.lpMint,
        coinMint: poolInfo.baseMint,
        pcMint: poolInfo.quoteMint,
        coinVault: poolInfo.baseVault,
        pcVault: poolInfo.quoteVault,
        ammTargetOrders: poolInfo.targetOrders,
        marketProgramId: poolInfo.marketProgramId,
        marketId: poolInfo.marketId,
        userWallet: ownerInfo.wallet,
        userCoinVault: ownerTokenAccountBase,
        userPcVault: ownerTokenAccountQuote,
        userLpVault: getATAAddress(ownerInfo.wallet, poolInfo.lpMint, TOKEN_PROGRAM_ID).publicKey,
        ammConfigId: poolInfo.configId,
        feeDestinationId,
        nonce: poolInfo.nonce,
        openTime: startTime,
        coinAmount: baseAmount,
        pcAmount: quoteAmount
      }).innerTransaction;
      return {
        address: {
          programId,
          ammId: poolInfo.id,
          ammAuthority: poolInfo.authority,
          ammOpenOrders: poolInfo.openOrders,
          lpMint: poolInfo.lpMint,
          coinMint: poolInfo.baseMint,
          pcMint: poolInfo.quoteMint,
          coinVault: poolInfo.baseVault,
          pcVault: poolInfo.quoteVault,
          withdrawQueue: poolInfo.withdrawQueue,
          ammTargetOrders: poolInfo.targetOrders,
          poolTempLp: poolInfo.lpVault,
          marketProgramId: poolInfo.marketProgramId,
          marketId: poolInfo.marketId
        },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCreatePoolV4InstructionV2({
    programId,
    ammId,
    ammAuthority,
    ammOpenOrders,
    lpMint,
    coinMint,
    pcMint,
    coinVault,
    pcVault,
    ammTargetOrders,
    marketProgramId,
    marketId,
    userWallet,
    userCoinVault,
    userPcVault,
    userLpVault,
    nonce,
    openTime,
    coinAmount,
    pcAmount,
    lookupTableAddress,
    ammConfigId,
    feeDestinationId
  }) {
    const dataLayout = struct([u82("instruction"), u82("nonce"), u64("openTime"), u64("pcAmount"), u64("coinAmount")]);
    const keys = [
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: ammId, isSigner: false, isWritable: true },
      { pubkey: ammAuthority, isSigner: false, isWritable: false },
      { pubkey: ammOpenOrders, isSigner: false, isWritable: true },
      { pubkey: lpMint, isSigner: false, isWritable: true },
      { pubkey: coinMint, isSigner: false, isWritable: false },
      { pubkey: pcMint, isSigner: false, isWritable: false },
      { pubkey: coinVault, isSigner: false, isWritable: true },
      { pubkey: pcVault, isSigner: false, isWritable: true },
      { pubkey: ammTargetOrders, isSigner: false, isWritable: true },
      { pubkey: ammConfigId, isSigner: false, isWritable: false },
      { pubkey: feeDestinationId, isSigner: false, isWritable: true },
      { pubkey: marketProgramId, isSigner: false, isWritable: false },
      { pubkey: marketId, isSigner: false, isWritable: false },
      { pubkey: userWallet, isSigner: true, isWritable: true },
      { pubkey: userCoinVault, isSigner: false, isWritable: true },
      { pubkey: userPcVault, isSigner: false, isWritable: true },
      { pubkey: userLpVault, isSigner: false, isWritable: true }
    ];
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({ instruction: 1, nonce, openTime, coinAmount, pcAmount }, data);
    const ins = new TransactionInstruction10({
      keys,
      programId,
      data
    });
    return {
      address: {},
      innerTransaction: {
        instructions: [ins],
        signers: [],
        lookupTableAddress: lookupTableAddress ? [lookupTableAddress] : void 0,
        instructionTypes: [29 /* ammV4CreatePoolV2 */]
      }
    };
  }
  static makeRemoveAllLpAndCreateClmmPosition(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      removeLpAmount,
      userKeys,
      clmmPoolKeys,
      createPositionInfo,
      farmInfo,
      computeBudgetConfig,
      checkCreateATAOwner = false,
      getEphemeralSigners,
      makeTxVersion,
      lookupTableCache
    }) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!(poolKeys.baseMint.equals(clmmPoolKeys.mintA.mint) || poolKeys.baseMint.equals(clmmPoolKeys.mintB.mint)))
        throw Error("mint check error");
      if (!(poolKeys.quoteMint.equals(clmmPoolKeys.mintA.mint) || poolKeys.quoteMint.equals(clmmPoolKeys.mintB.mint)))
        throw Error("mint check error");
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintToAccount = {};
      for (const item of userKeys.tokenAccounts) {
        if (mintToAccount[item.accountInfo.mint.toString()] === void 0 || getATAAddress(userKeys.owner, item.accountInfo.mint, TOKEN_PROGRAM_ID).publicKey.equals(item.pubkey)) {
          mintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const lpTokenAccount = mintToAccount[poolKeys.lpMint.toString()];
      if (lpTokenAccount === void 0) throw Error("find lp account error in trade accounts");
      const amountIn = removeLpAmount.add((_a = farmInfo == null ? void 0 : farmInfo.amount) != null ? _a : new BN16(0));
      const mintBaseUseSOLBalance = poolKeys.baseMint.equals(Token.WSOL.mint);
      const mintQuoteUseSOLBalance = poolKeys.quoteMint.equals(Token.WSOL.mint);
      const baseTokenAccount = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: poolKeys.baseMint,
        tokenAccounts: userKeys.tokenAccounts,
        owner: userKeys.owner,
        createInfo: {
          connection,
          payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintBaseUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintBaseUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: true,
        checkCreateATAOwner
      });
      const quoteTokenAccount = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: poolKeys.quoteMint,
        tokenAccounts: userKeys.tokenAccounts,
        owner: userKeys.owner,
        createInfo: {
          connection,
          payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintQuoteUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintQuoteUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: true,
        checkCreateATAOwner
      });
      mintToAccount[poolKeys.baseMint.toString()] = baseTokenAccount;
      mintToAccount[poolKeys.quoteMint.toString()] = quoteTokenAccount;
      const removeIns = this.makeRemoveLiquidityInstruction({
        poolKeys,
        userKeys: {
          lpTokenAccount,
          baseTokenAccount,
          quoteTokenAccount,
          owner: userKeys.owner
        },
        amountIn
      });
      const [tokenAccountA, tokenAccountB] = poolKeys.baseMint.equals(clmmPoolKeys.mintA.mint) ? [baseTokenAccount, quoteTokenAccount] : [quoteTokenAccount, baseTokenAccount];
      const createPositionIns = yield Clmm.makeOpenPositionFromLiquidityInstructions(__spreadProps(__spreadValues({
        poolInfo: clmmPoolKeys,
        ownerInfo: {
          feePayer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          wallet: userKeys.owner,
          tokenAccountA,
          tokenAccountB
        },
        withMetadata: "create"
      }, createPositionInfo), {
        getEphemeralSigners
      }));
      let withdrawFarmIns = {
        instructions: [],
        signers: [],
        instructionTypes: []
      };
      if (farmInfo !== void 0) {
        const rewardTokenAccounts = [];
        for (const item of farmInfo.poolKeys.rewardInfos) {
          const rewardIsWsol = item.rewardMint.equals(Token.WSOL.mint);
          rewardTokenAccounts.push(
            (_f = mintToAccount[item.rewardMint.toString()]) != null ? _f : yield this._selectOrCreateTokenAccount({
              programId: TOKEN_PROGRAM_ID,
              mint: item.rewardMint,
              tokenAccounts: userKeys.tokenAccounts,
              owner: userKeys.owner,
              createInfo: {
                connection,
                payer: (_e = userKeys.payer) != null ? _e : userKeys.owner,
                frontInstructions,
                frontInstructionsType,
                endInstructions: rewardIsWsol ? endInstructions : [],
                endInstructionsType: rewardIsWsol ? endInstructionsType : [],
                signers
              },
              associatedOnly: true,
              checkCreateATAOwner
            })
          );
        }
        withdrawFarmIns = Farm.makeWithdrawInstruction({
          poolKeys: farmInfo.poolKeys,
          amount: farmInfo.amount,
          userKeys: {
            ledger: Farm.getAssociatedLedgerAccount({
              programId: farmInfo.poolKeys.programId,
              poolId: farmInfo.poolKeys.id,
              owner: userKeys.owner,
              version: farmInfo.poolKeys.version
            }),
            lpTokenAccount,
            rewardTokenAccounts,
            owner: userKeys.owner
          }
        }).innerTransaction;
      }
      return {
        address: __spreadValues(__spreadValues({}, removeIns.address), createPositionIns.address),
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_g = userKeys.payer) != null ? _g : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            withdrawFarmIns,
            removeIns.innerTransaction,
            createPositionIns.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  /* ================= fetch data ================= */
  /**
   * Fetch all pools keys from on-chain data
   */
  static fetchAllPoolKeys(connection, programId, config) {
    return __async(this, null, function* () {
      const allPools = (yield Promise.all(
        Object.entries(LIQUIDITY_VERSION_TO_STATE_LAYOUT).map(([version2, layout]) => {
          try {
            return connection.getProgramAccounts(programId[Number(version2)], {
              filters: [{ dataSize: layout.span }]
            }).then((accounts) => {
              return accounts.map((info) => {
                return __spreadValues({
                  id: info.pubkey,
                  version: Number(version2),
                  programId: programId[Number(version2)]
                }, layout.decode(info.account.data));
              });
            });
          } catch (error) {
            if (error instanceof Error) {
              return logger11.throwError("failed to fetch pool info", Logger.errors.RPC_ERROR, {
                message: error.message
              });
            }
          }
        })
      )).flat();
      const allMarketIds = allPools.map((i) => i.marketId);
      const marketsInfo = {};
      try {
        const _marketsInfo = yield getMultipleAccountsInfo(connection, allMarketIds, config);
        for (const item of _marketsInfo) {
          if (item === null) continue;
          const _i = __spreadValues({ programId: item.owner }, MARKET_STATE_LAYOUT_V3.decode(item.data));
          marketsInfo[_i.ownAddress.toString()] = _i;
        }
      } catch (error) {
        if (error instanceof Error) {
          return logger11.throwError("failed to fetch markets", Logger.errors.RPC_ERROR, {
            message: error.message
          });
        }
      }
      const authority = {};
      for (const [version2, _programId] of Object.entries(programId))
        authority[version2] = this.getAssociatedAuthority({ programId: _programId }).publicKey;
      const formatPoolInfos = [];
      for (const pool of allPools) {
        if (pool === void 0) continue;
        if (pool.baseMint.equals(PublicKey20.default)) continue;
        const market = marketsInfo[pool.marketId.toString()];
        const marketProgramId = market.programId;
        formatPoolInfos.push(__spreadProps(__spreadValues({
          id: pool.id,
          baseMint: pool.baseMint,
          quoteMint: pool.quoteMint,
          lpMint: pool.lpMint,
          baseDecimals: pool.baseDecimal.toNumber(),
          quoteDecimals: pool.quoteDecimal.toNumber(),
          lpDecimals: pool.id.toString() === "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT" ? 5 : pool.baseDecimal.toNumber(),
          version: pool.version,
          programId: pool.programId,
          authority: authority[pool.version],
          openOrders: pool.openOrders,
          targetOrders: pool.targetOrders,
          baseVault: pool.baseVault,
          quoteVault: pool.quoteVault,
          marketVersion: 3,
          marketProgramId,
          marketId: market.ownAddress,
          marketAuthority: Market.getAssociatedAuthority({
            programId: marketProgramId,
            marketId: market.ownAddress
          }).publicKey,
          marketBaseVault: market.baseVault,
          marketQuoteVault: market.quoteVault,
          marketBids: market.bids,
          marketAsks: market.asks,
          marketEventQueue: market.eventQueue
        }, pool.version === 5 ? {
          modelDataAccount: pool.modelDataAccount,
          withdrawQueue: PublicKey20.default,
          lpVault: PublicKey20.default
        } : {
          withdrawQueue: pool.withdrawQueue,
          lpVault: pool.lpVault
        }), {
          lookupTableAccount: PublicKey20.default
        }));
      }
      return formatPoolInfos;
    });
  }
  /**
   * Fetch liquidity pool's info
   */
  static fetchInfo(_0) {
    return __async(this, arguments, function* ({ connection, poolKeys }) {
      const info = yield this.fetchMultipleInfo({ connection, pools: [poolKeys] });
      logger11.assertArgument(info.length === 1, `fetchInfo failed, ${info.length} pools found`, "poolKeys.id", poolKeys.id);
      return info[0];
    });
  }
  /**
   * Fetch multiple info of liquidity pools
   */
  static fetchMultipleInfo(_0) {
    return __async(this, arguments, function* ({
      connection,
      pools,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      config
    }) {
      yield initStableModelLayout(connection);
      const instructions = pools.map((pool) => this.makeSimulatePoolInfoInstruction({ poolKeys: pool }));
      const logs = yield simulateMultipleInstruction(
        connection,
        instructions.map((i) => i.innerTransaction.instructions).flat(),
        "GetPoolData"
      );
      const poolsInfo = logs.map((log) => {
        const json = parseSimulateLogToJson(log, "GetPoolData");
        const status = new BN16(parseSimulateValue(json, "status"));
        const baseDecimals = Number(parseSimulateValue(json, "coin_decimals"));
        const quoteDecimals = Number(parseSimulateValue(json, "pc_decimals"));
        const lpDecimals = Number(parseSimulateValue(json, "lp_decimals"));
        const baseReserve = new BN16(parseSimulateValue(json, "pool_coin_amount"));
        const quoteReserve = new BN16(parseSimulateValue(json, "pool_pc_amount"));
        const lpSupply = new BN16(parseSimulateValue(json, "pool_lp_supply"));
        let startTime = "0";
        try {
          startTime = parseSimulateValue(json, "pool_open_time");
        } catch (error) {
        }
        return {
          status,
          baseDecimals,
          quoteDecimals,
          lpDecimals,
          baseReserve,
          quoteReserve,
          lpSupply,
          startTime: new BN16(startTime)
        };
      });
      return poolsInfo;
    });
  }
  /* ================= compute data ================= */
  static getEnabledFeatures(poolInfo) {
    const { status } = poolInfo;
    const _status = status.toNumber();
    if (_status === 0 /* Uninitialized */)
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: false
      };
    else if (_status === 1 /* Initialized */)
      return {
        swap: true,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 2 /* Disabled */)
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: false
      };
    else if (_status === 3 /* RemoveLiquidityOnly */)
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: true
      };
    else if (_status === 4 /* LiquidityOnly */)
      return {
        swap: false,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 5 /* OrderBook */)
      return {
        swap: false,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 6 /* Swap */)
      return {
        swap: true,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 7 /* WaitingForStart */) {
      const { startTime } = poolInfo;
      if (Date.now() / 1e3 < startTime.toNumber())
        return {
          swap: false,
          addLiquidity: true,
          removeLiquidity: true
        };
      return {
        swap: true,
        addLiquidity: true,
        removeLiquidity: true
      };
    } else
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: false
      };
  }
  static includesToken(token, poolKeys) {
    const { baseMint, quoteMint } = poolKeys;
    return token.mint.equals(baseMint) || token.mint.equals(quoteMint);
  }
  /**
   * Get token side of liquidity pool
   * @param token - the token provided
   * @param poolKeys - the pool keys
   * @returns token side is `base` or `quote`
   */
  static _getTokenSide(token, poolKeys) {
    const { baseMint, quoteMint } = poolKeys;
    if (token.mint.equals(baseMint)) return "base";
    else if (token.mint.equals(quoteMint)) return "quote";
    else
      return logger11.throwArgumentError("token not match with pool", "params", {
        token: token.mint,
        baseMint,
        quoteMint
      });
  }
  /**
   * Get tokens side of liquidity pool
   * @param tokenA - the token provided
   * @param tokenB - the token provided
   * @param poolKeys - the pool keys
   * @returns tokens side array
   */
  static _getTokensSide(tokenA, tokenB, poolKeys) {
    const { baseMint, quoteMint } = poolKeys;
    const sideA = this._getTokenSide(tokenA, poolKeys);
    const sideB = this._getTokenSide(tokenB, poolKeys);
    logger11.assertArgument(sideA !== sideB, "tokens not match with pool", "params", {
      tokenA: tokenA.mint,
      tokenB: tokenB.mint,
      baseMint,
      quoteMint
    });
    return [sideA, sideB];
  }
  /**
   * Get currency amount side of liquidity pool
   * @param amount - the currency amount provided
   * @param poolKeys - the pool keys
   * @returns currency amount side is `base` or `quote`
   */
  static _getAmountSide(amount, poolKeys) {
    const token = amount instanceof TokenAmount ? amount.token : Token.WSOL;
    return this._getTokenSide(token, poolKeys);
  }
  /**
   * Get currencies amount side of liquidity pool
   * @param amountA - the currency amount provided
   * @param amountB - the currency amount provided
   * @param poolKeys - the pool keys
   * @returns currencies amount side array
   */
  static _getAmountsSide(amountA, amountB, poolKeys) {
    const tokenA = amountA instanceof TokenAmount ? amountA.token : Token.WSOL;
    const tokenB = amountB instanceof TokenAmount ? amountB.token : Token.WSOL;
    return this._getTokensSide(tokenA, tokenB, poolKeys);
  }
  /**
   * Compute the another currency amount of add liquidity
   *
   * @param params - {@link LiquidityComputeAnotherAmountParams}
   *
   * @returns
   * anotherCurrencyAmount - currency amount without slippage
   * @returns
   * maxAnotherCurrencyAmount - currency amount with slippage
   *
   * @returns {@link CurrencyAmount}
   *
   * @example
   * ```
   * Liquidity.computeAnotherAmount({
   *   // 1%
   *   slippage: new Percent(1, 100)
   * })
   * ```
   */
  static computeAnotherAmount({
    poolKeys,
    poolInfo,
    amount,
    anotherCurrency,
    slippage
  }) {
    const { baseReserve, quoteReserve } = poolInfo;
    logger11.debug("baseReserve:", baseReserve.toString());
    logger11.debug("quoteReserve:", quoteReserve.toString());
    const currencyIn = amount instanceof TokenAmount ? amount.token : amount.currency;
    logger11.debug("currencyIn:", currencyIn);
    logger11.debug("amount:", amount.toFixed());
    logger11.debug("anotherCurrency:", anotherCurrency);
    logger11.debug("slippage:", `${slippage.toSignificant()}%`);
    const input = this._getAmountSide(amount, poolKeys);
    logger11.debug("input side:", input);
    let amountRaw = ZERO;
    if (!amount.isZero()) {
      amountRaw = input === "base" ? divCeil(amount.raw.mul(quoteReserve), baseReserve) : divCeil(amount.raw.mul(baseReserve), quoteReserve);
    }
    const liquidity = divCeil(
      amount.raw.mul(poolInfo.lpSupply),
      input === "base" ? poolInfo.baseReserve : poolInfo.quoteReserve
    );
    const _slippage = new Percent(ONE).add(slippage);
    const slippageAdjustedAmount = _slippage.mul(amountRaw).quotient;
    const _anotherAmount = anotherCurrency instanceof Token ? new TokenAmount(anotherCurrency, amountRaw) : new CurrencyAmount(anotherCurrency, amountRaw);
    const _maxAnotherAmount = anotherCurrency instanceof Token ? new TokenAmount(anotherCurrency, slippageAdjustedAmount) : new CurrencyAmount(anotherCurrency, slippageAdjustedAmount);
    logger11.debug("anotheAmount:", _anotherAmount.toFixed());
    logger11.debug("maxAnotheAmount:", _maxAnotherAmount.toFixed());
    return {
      anotherAmount: _anotherAmount,
      maxAnotherAmount: _maxAnotherAmount,
      liquidity
    };
  }
  static _computePriceImpact(currentPrice, amountIn, amountOut) {
    const exactQuote = currentPrice.raw.mul(amountIn);
    const slippage = exactQuote.sub(amountOut).div(exactQuote);
    return new Percent(slippage.numerator, slippage.denominator);
  }
  static getRate(poolInfo) {
    const { baseReserve, quoteReserve, baseDecimals, quoteDecimals } = poolInfo;
    const price = new Price(new Currency(baseDecimals), baseReserve, new Currency(quoteDecimals), quoteReserve);
    return price;
  }
  /**
   * Compute input currency amount of swap
   *
   * @param params - {@link ComputeCurrencyAmountInParams}
   *
   * @returns
   * amountIn - currency amount without slippage
   * @returns
   * maxAmountIn - currency amount with slippage
   */
  static computeAmountIn({ poolKeys, poolInfo, amountOut, currencyIn, slippage }) {
    const { baseReserve, quoteReserve } = poolInfo;
    logger11.debug("baseReserve:", baseReserve.toString());
    logger11.debug("quoteReserve:", quoteReserve.toString());
    const currencyOut = amountOut instanceof TokenAmount ? amountOut.token : amountOut.currency;
    logger11.debug("currencyOut:", currencyOut);
    logger11.debug("amountOut:", amountOut.toFixed());
    logger11.debug("currencyIn:", currencyIn);
    logger11.debug("slippage:", `${slippage.toSignificant()}%`);
    const reserves = [baseReserve, quoteReserve];
    const output2 = this._getAmountSide(amountOut, poolKeys);
    if (output2 === "base") {
      reserves.reverse();
    }
    logger11.debug("output side:", output2);
    const [reserveIn, reserveOut] = reserves;
    const currentPrice = new Price(currencyIn, reserveIn, currencyOut, reserveOut);
    logger11.debug("currentPrice:", `1 ${currencyIn.symbol} \u2248 ${currentPrice.toFixed()} ${currencyOut.symbol}`);
    logger11.debug(
      "currentPrice invert:",
      `1 ${currencyOut.symbol} \u2248 ${currentPrice.invert().toFixed()} ${currencyIn.symbol}`
    );
    let amountInRaw = ZERO;
    let amountOutRaw = amountOut.raw;
    if (!amountOutRaw.isZero()) {
      if (amountOutRaw.gt(reserveOut)) {
        amountOutRaw = reserveOut.sub(ONE);
      }
      const denominator = reserveOut.sub(amountOutRaw);
      const amountInWithoutFee = reserveIn.mul(amountOutRaw).div(denominator);
      amountInRaw = amountInWithoutFee.mul(LIQUIDITY_FEES_DENOMINATOR).div(LIQUIDITY_FEES_DENOMINATOR.sub(LIQUIDITY_FEES_NUMERATOR));
    }
    const _slippage = new Percent(ONE).add(slippage);
    const maxAmountInRaw = _slippage.mul(amountInRaw).quotient;
    const amountIn = currencyIn instanceof Token ? new TokenAmount(currencyIn, amountInRaw) : new CurrencyAmount(currencyIn, amountInRaw);
    const maxAmountIn = currencyIn instanceof Token ? new TokenAmount(currencyIn, maxAmountInRaw) : new CurrencyAmount(currencyIn, maxAmountInRaw);
    logger11.debug("amountIn:", amountIn.toFixed());
    logger11.debug("maxAmountIn:", maxAmountIn.toFixed());
    let executionPrice = null;
    if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
      executionPrice = new Price(currencyIn, amountInRaw, currencyOut, amountOutRaw);
      logger11.debug("executionPrice:", `1 ${currencyIn.symbol} \u2248 ${executionPrice.toFixed()} ${currencyOut.symbol}`);
      logger11.debug(
        "executionPrice invert:",
        `1 ${currencyOut.symbol} \u2248 ${executionPrice.invert().toFixed()} ${currencyIn.symbol}`
      );
    }
    const priceImpact = this._computePriceImpact(currentPrice, amountInRaw, amountOutRaw);
    logger11.debug("priceImpact:", `${priceImpact.toSignificant()}%`);
    return {
      amountIn,
      maxAmountIn,
      currentPrice,
      executionPrice,
      priceImpact
    };
  }
};
/**
 * Compute output currency amount of swap
 *
 * @param params - {@link LiquidityComputeAmountOutParams}
 *
 * @returns
 * amountOut - currency amount without slippage
 * @returns
 * minAmountOut - currency amount with slippage
 */
_Liquidity.computeAmountOut = ({
  poolKeys,
  poolInfo,
  amountIn,
  currencyOut,
  slippage
}) => {
  const tokenIn = amountIn instanceof TokenAmount ? amountIn.token : Token.WSOL;
  const tokenOut = currencyOut instanceof Token ? currencyOut : Token.WSOL;
  logger11.assertArgument(
    _Liquidity.includesToken(tokenIn, poolKeys) && _Liquidity.includesToken(tokenOut, poolKeys),
    "token not match with pool",
    "poolKeys",
    { poolKeys, tokenIn, tokenOut }
  );
  const { baseReserve, quoteReserve } = poolInfo;
  logger11.debug("baseReserve:", baseReserve.toString());
  logger11.debug("quoteReserve:", quoteReserve.toString());
  const currencyIn = amountIn instanceof TokenAmount ? amountIn.token : amountIn.currency;
  logger11.debug("currencyIn:", currencyIn);
  logger11.debug("amountIn:", amountIn.toFixed());
  logger11.debug("currencyOut:", currencyOut);
  logger11.debug("slippage:", `${slippage.toSignificant()}%`);
  const reserves = [baseReserve, quoteReserve];
  const input = _Liquidity._getAmountSide(amountIn, poolKeys);
  if (input === "quote") {
    reserves.reverse();
  }
  logger11.debug("input side:", input);
  const [reserveIn, reserveOut] = reserves;
  let currentPrice;
  if (poolKeys.version === 4) {
    currentPrice = new Price(currencyIn, reserveIn, currencyOut, reserveOut);
  } else {
    const p = getStablePrice(modelData, baseReserve.toNumber(), quoteReserve.toNumber(), false);
    if (input === "quote") currentPrice = new Price(currencyIn, new BN16(p * 1e6), currencyOut, new BN16(1e6));
    else currentPrice = new Price(currencyIn, new BN16(1e6), currencyOut, new BN16(p * 1e6));
  }
  logger11.debug("currentPrice:", `1 ${currencyIn.symbol} \u2248 ${currentPrice.toFixed()} ${currencyOut.symbol}`);
  logger11.debug(
    "currentPrice invert:",
    `1 ${currencyOut.symbol} \u2248 ${currentPrice.invert().toFixed()} ${currencyIn.symbol}`
  );
  const amountInRaw = amountIn.raw;
  let amountOutRaw = ZERO;
  let feeRaw = ZERO;
  if (!amountInRaw.isZero()) {
    if (poolKeys.version === 4) {
      feeRaw = BNDivCeil(amountInRaw.mul(LIQUIDITY_FEES_NUMERATOR), LIQUIDITY_FEES_DENOMINATOR);
      const amountInWithFee = amountInRaw.sub(feeRaw);
      const denominator = reserveIn.add(amountInWithFee);
      amountOutRaw = reserveOut.mul(amountInWithFee).div(denominator);
    } else {
      feeRaw = amountInRaw.mul(new BN16(2)).div(new BN16(1e4));
      const amountInWithFee = amountInRaw.sub(feeRaw);
      if (input === "quote")
        amountOutRaw = new BN16(
          getDyByDxBaseIn(modelData, quoteReserve.toNumber(), baseReserve.toNumber(), amountInWithFee.toNumber())
        );
      else {
        amountOutRaw = new BN16(
          getDxByDyBaseIn(modelData, quoteReserve.toNumber(), baseReserve.toNumber(), amountInWithFee.toNumber())
        );
      }
    }
  }
  const _slippage = new Percent(ONE).add(slippage);
  const minAmountOutRaw = _slippage.invert().mul(amountOutRaw).quotient;
  const amountOut = currencyOut instanceof Token ? new TokenAmount(currencyOut, amountOutRaw) : new CurrencyAmount(currencyOut, amountOutRaw);
  const minAmountOut = currencyOut instanceof Token ? new TokenAmount(currencyOut, minAmountOutRaw) : new CurrencyAmount(currencyOut, minAmountOutRaw);
  logger11.debug("amountOut:", amountOut.toFixed());
  logger11.debug("minAmountOut:", minAmountOut.toFixed());
  let executionPrice = new Price(currencyIn, amountInRaw.sub(feeRaw), currencyOut, amountOutRaw);
  if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
    executionPrice = new Price(currencyIn, amountInRaw.sub(feeRaw), currencyOut, amountOutRaw);
    logger11.debug("executionPrice:", `1 ${currencyIn.symbol} \u2248 ${executionPrice.toFixed()} ${currencyOut.symbol}`);
    logger11.debug(
      "executionPrice invert:",
      `1 ${currencyOut.symbol} \u2248 ${executionPrice.invert().toFixed()} ${currencyIn.symbol}`
    );
  }
  const priceImpactDenominator = executionPrice.denominator.mul(currentPrice.numerator);
  const priceImpactNumerator = executionPrice.numerator.mul(currentPrice.denominator).sub(priceImpactDenominator).abs();
  const priceImpact = new Percent(priceImpactNumerator, priceImpactDenominator);
  logger11.debug("priceImpact:", `${priceImpact.toSignificant()}%`);
  const fee = currencyIn instanceof Token ? new TokenAmount(currencyIn, feeRaw) : new CurrencyAmount(currencyIn, feeRaw);
  return {
    amountOut,
    minAmountOut,
    currentPrice,
    executionPrice,
    priceImpact,
    fee
  };
};
var Liquidity = _Liquidity;

// src/liquidity/pool.ts
var MAINNET_OFFICIAL_LIQUIDITY_POOLS = [
  /* ================= v4 ================= */
  // FIDA-RAY
  "2dRNngAm729NzLbb1pzgHtfHvPqR4XHFmFyYK78EfEeX",
  // OXY-RAY
  "B5ZguAWAGC3GXVtJZVfoMtzvEvDnDKBPCevsUKMy4DTZ",
  // MAPS-RAY
  "5VyLSjUvaRxsubirbvbfJMbrKZRx1b7JZzuCAfyqgimf",
  // KIN-RAY
  "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT",
  // RAY-USDT
  "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
  // SOL-USDC
  "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
  // YFI-USDC
  "83xxjVczDseaCzd7D61BRo7LcP7cMXut5n7thhB4rL4d",
  // SRM-USDC
  "8tzS7SkUZyHPQY7gLqsMCXZ5EDCgjESUHcB17tiR1h3Z",
  // FTT-USDC
  "4C2Mz1bVqe42QDDTyJ4HFCFFGsH5YDzo91Cen5w5NGun",
  // BTC-USDC
  "6kbC5epG18DF2DwPEW34tBy5pGFS7pEGALR3v5MGxgc5",
  // SUSHI-USDC
  "5dHEPTgvscKkAc54R77xUeGdgShdG9Mf6gJ9bwBqyb3V",
  // TOMO-USDC
  "8mBJC9qdPNDyrpAbrdwGbBpEAjPqwtvZQVmbnKFXXY2P",
  // LINK-USDC
  "Hr8i6MAm4W5Lwb2fB2CD44A2t3Ag3gGc1rmd6amrWsWC",
  // ETH-USDC
  "AoPebtuJC4f2RweZSxcVCcdeTgaEXY64Uho8b5HdPxAR",
  // xCOPE-USDC
  "3mYsmBQLB8EZSjRwtWjPbbE8LiM1oCCtNZZKiVBKsePa",
  // SOL-USDT
  "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
  // YFI-USDT
  "81PmLJ8j2P8CC5EJAAhWGYA4HgJvoKs4Y94ALZF2uKKG",
  // SRM-USDT
  "af8HJg2ffWoKJ6vKvkWJUJ9iWbRR83WgXs8HPs26WGr",
  // FTT-USDT
  "4fgubfZVL6L8tc5x1j65S14P2Tnxr1YayKtKavQV5MBo",
  // BTC-USDT
  "AMMwkf57c7ZsbbDCXvBit9zFehMr1xRn8ZzaT1iDF18o",
  // SUSHI-USDT
  "DWvhPYVogsEKEsehHApUtjhP1UFtApkAPFJqFh2HPmWz",
  // TOMO-USDT
  "GjrXcSvwzGrz1RwKYGVWdbZyXzyotgichSHB95moDmf8",
  // LINK-USDT
  "E9EvurfzdSQaqCFBUaD4MgV93htuRQ93sghm922Pik88",
  // ETH-USDT
  "He3iAEV5rYjv6Xf7PxKro19eVrC3QAcdic5CF2D2obPt",
  // YFI-SRM
  "GDVhJmDTdSExwHeMT5RvUBUNKLwwXNKhH8ndm1tpTv6B",
  // FTT-SRM
  "21r2zeCacmm5YvbGoPZh9ZoGREuodhcbQHaP5tZmzY14",
  // BTC-SRM
  "DvxLb4NnQUYq1gErk35HVt9g8kxjNbviJfiZX1wqraMv",
  // SUSHI-SRM
  "BLVjPTgzyfiKSgDujTNKKNzW2GXx7HhdMxgr2LQ2g83s",
  // TOMO-SRM
  "DkMAuUCQHC6BNgVnjtM5ZTKm1T8MsriQ6bL3Umi6NBtG",
  // LINK-SRM
  "796pvggjoDCPUtUSVFSCLqPRyes5YPvRiu4zFWX582wf",
  // ETH-SRM
  "3XwxHcbyqcd1xkdczaPv3TNCZsevELD4Zux3pu4sF2D8",
  // SRM-SOL
  "EvWJC2mnmu9C9aQrsJLXw8FhUcwBzFEUQsP1E5Y6a5N7",
  // STEP-USDC
  "4Sx1NLrQiK4b9FdLKe2DhQ9FHvRzJhzKN3LoD6BrEPnf",
  // MEDIA-USDC
  "94CQopiGxxUXf2avyMZhAFaBdNatd62ttYGoTVQBRGdi",
  // ROPE-USDC
  "BuS4ScFcZjEBixF1ceCTiXs4rqt4WDfXLoth7VcM2Eoj",
  // MER-USDC
  "BkfGDk676QFtTiGxn7TtEpHayJZRr6LgNk9uTV2MH4bR",
  // COPE-USDC
  "DiWxV1SPXPNJRCt5Ao1mJRAxjw97hJVyj8qGzZwFbAFb",
  // ALEPH-USDC
  "GDHXjn9wF2zxW35DBkCegWQdoTfFBC9LXt7D5ovJxQ5B",
  // TULIP-USDC
  "96hPvuJ3SRT82m7BAc7G1AUVPVcoj8DABAa5gT7wjgzX",
  // WOO-USDC
  "DSkXJYPZqJ3yHQECyVyh3xiE3HBrt7ARmepwNDA9rREn",
  // SNY-USDC
  "5TgJXpv6H3KJhHCuP7KoDLSCmi8sM8nABizP7CmYAKm1",
  // BOP-RAY
  "SJmR8rJgzzCi4sPjGnrNsqY4akQb3jn5nsxZBhyEifC",
  // SLRS-USDC
  "7XXKU8oGDbeGrkPyK5yHKzdsrMJtB7J2TMugjbrXEhB5",
  // SAMO-RAY
  "EyDgEU9BdG7m6ZK4bYERxbN4NCJ129WzPtv23dBkfsLg",
  // renBTC-USDC
  "61JtCkTQKSeBU8ztEScByZiBhS6KAHSXfQduVyA4s1h7",
  // renDOGE-USDC
  "34oD4akb2DeNcCw1smKHPsD3iqQQQWmNy3cY81nz7HP8",
  // RAY-USDC
  "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
  // RAY-SRM
  "GaqgfieVmnmY4ZsZHHA6L5RSVzCGL3sKx4UgHBaYNy8m",
  // RAY-ETH
  "8iQFhWyceGREsWnLM8NkG9GC8DvZunGZyMzuyUScgkMK",
  // RAY-SOL
  "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
  // DXL-USDC
  "asdEJnE7osjgnSyQkSZJ3e5YezbmXuDQPiyeyiBxoUm",
  // LIKE-USDC
  "GmaDNMWsTYWjaXVBjJTHNmCWAKU6cn5hhtWWYEZt4odo",
  // mSOL-USDC
  "ZfvDXXUhZDzDVsapffUyXHj9ByCoPjP4thL6YXcZ9ix",
  // mSOL-SOL
  "EGyhb2uLAsRUbRx9dNFBjMVYnFaASWMvD6RE1aEf2LxL",
  // MER-PAI
  "6GUF8Qb5FWmifzYpRdKomFNbSQAsLShhT45GbTGg34VJ",
  // PORT-USDC
  "6nJes56KF999Q8VtQTrgWEHJGAfGMuJktGb8x2uWff2u",
  // MNGO-USDC
  "34tFULRrRwh4bMcBLPtJaNqqe5pVgGZACi5sR8Xz95KC",
  // ATLAS-USDC
  "2bnZ1edbvK3CK3LTNZ5jH9anvXYCmzPR4W2HQ6Ngsv5K",
  // POLIS-USDC
  "9xyCzsHi1wUWva7t5Z8eAvZDRmUCVhRrbaFfm3VbU4Mf",
  // ATLAS-RAY
  "F73euqPynBwrgcZn3fNSEneSnYasDQohPM5aZazW9hp2",
  // POLIS-RAY
  "5tho4By9RsqTF1rbm9Akiepik3kZBT7ffUzGg8bL1mD",
  // ALEPH-RAY
  "8Fr3wxZXLtiSozqms5nF4XXGHNSNqcMC6K6MvRqEfk4a",
  // TULIP-RAY
  "Dm1Q15216uRARmQTbo6VfnyEGVzRvLTm4TfCWWX4MF3F",
  // SLRS-RAY
  "J3CoGcJqHquUdSgS7qAwdGbp3so4EpLX8eVDdGuauvi",
  // MER-RAY
  "BKLCqnuk4qc5iHWuJuewMxuvsNZXuTBSUyRT5ftnRb6H",
  // MEDIA-RAY
  "5ZPBHzMr19iQjBaDgFDYGAx2bxaQ3TzWmSS7zAGrHtQJ",
  // SNY-RAY
  "Am9FpX73ctZ3HzohcRdyCCv84iT7nugevqLjY5yTSUQP",
  // LIKE-RAY
  "DGSnfcE1kw4uDC6jgrsZ3s5CMfsWKN7JNjDNasHdvKfq",
  // COPE-RAY
  "8hvVAhShYLPThcxrxwMNAWmgRCSjtxygj11EGHp2WHz8",
  // ETH-SOL
  "9Hm8QX7ZhE9uB8L2arChmmagZZBtBmnzBbpfxzkQp85D",
  // stSOL-USDC
  "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
  // GRAPE-USDC
  "vVXfY15WdPsCmLvbiP4hWWECPFeAvPTuPNq3Q4BXfhy",
  // LARIX-USDC
  "A21ui9aYTSs3CbkscaY6irEMQx3Z59dLrRuZQTt2hJwQ",
  // RIN-USDC
  "7qZJTK5NatxQJRTxZvHi3gRu4cZZsKr8ZPzs7BA5JMTC",
  // APEX-USDC
  "43UHp4TuwQ7BYsaULN1qfpktmg7GWs9GpR8TDb8ovu9c",
  // mSOL-RAY
  "6gpZ9JkLoYvpA5cwdyPZFsDw6tkbPyyXM5FqRqHxMCny",
  // MNDE-mSOL
  "2kPA9XUuHUifcCYTnjSuN7ZrC3ma8EKPrtzUhC86zj3m",
  // LARIX-RAY
  "EBqQdu9rGe6j3WGJQSyTvDjUMWcRd6uLcxSS4TbFT31t",
  // LIQ-USDC
  "33dWwj33J3NUzoTmkMAUq1VdXZL89qezxkdaHdN88vK2",
  // WAG-USDC
  "FEFzBbbEK8yDigqyJPgJKMR5X1xZARC25QTCskvudjuK",
  // ETH-mSOL
  "Ghj3v2qYbSp6XqmH4NV4KRu4Rrgqoh2Ra7L9jEdsbNzF",
  // mSOL-USDT
  "BhuMVCzwFVZMSuc1kBbdcAnXwFg9p4HJp7A9ddwYjsaF",
  // BTC-mSOL
  "ynV2H2b7FcRBho2TvE25Zc4gDeuu2N45rUw9DuJYjJ9",
  // SLIM-SOL
  "8idN93ZBpdtMp4672aS4GGMDy7LdVWCCXH7FKFdMw9P4",
  // AURY-USDC
  "Ek8uoHjADzbNk2yr2HysybwFk1h2j9XXDsWAjAJN38n1",
  // PRT-SOL
  "7rVAbPFzqaBmydukTDFAuBiuyBrTVhpa5LpfDRrjX9mr",
  // LIQ-RAY
  "HuMDhYhW1BmBjXoJZBdjqaqoD3ehQeCUMbDSiZsaXSDU",
  // SYP-SOL
  "D95EzH4ZsGLikvYzp7kmz1RM1xNMo1MXXiXaedQesA2m",
  // SYP-RAY
  "3hhSfFhbk7Kd8XrRYKCcGAyUVYRaW9MLhcqAaU9kx6SA",
  // SYP-USDC
  "2Tv6eMih3iqxHrLAWn372Nba4A8FT8AxFSbowBmmTuAd",
  // FAB-USDC
  "7eM9KWYiJmNfDfeztMoEZE1KPyWD54LRxM9GmRY9ske6",
  // WOOF-RAY
  "3HYhQC6ne6SAPVT5sPTKawRUxv9ZpYyLuk1ifrw8baov",
  // WOOF-USDC
  "EZRHhpvAP4zEX1wZtTQcf6NP4FLWjs9c6tMRBqfrXgFD",
  // SLND-USDC
  "GRM4jGMtx64sEocBFz6ZgdogF2fyTWiixht8thZoHjkK",
  // FRKT-SOL
  "H3dhkXcC5MRN7VRXNbWVSvogH8mUQPzpn8PYQL7HfBVg",
  // weWETH-SOL
  "4yrHms7ekgTBgJg77zJ33TsWrraqHsCXDtuSZqUsuGHb",
  // weWETH-USDC
  "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
  // weUNI-USDC
  "8J5fa8WBGaDSv8AUpgtqdh9HM5AZuSf2ijvSkKoaCXCi",
  // weSUSHI-USDC
  "9SWy6nbSVZ44XuixEvHpona663pZPpVgzXQ3N7muG4ou",
  // CYS-USDC
  "661trVCzDWp114gy4PEK4etbjb3u3RNaP4aENa5uN8Vp",
  // SAMO-USDC
  "7oYaghDwJ6ZbZwzdzcPqQtW6r4cojSLJDKB6U7tqAK1x",
  // ABR-USDC
  "GQJjrG6f8HbxkE3ZVSRpzoyWhQ2RiivT68BybVK9DxME",
  // IN-USDC
  "5DECiJuqwmeCptoBEpyJtXKrVfiUrG9nBbBGkxGkPYyF",
  // weDYDX-USDC
  "CbGQojcizFEHn3woL7NPu3P9BLL1SWz5a8zkL9gks24q",
  // STARS-USDC
  "CWQVga1qUbpZXjrWQRj6U6tmL3HhrFiAT11VYnB8d3CF",
  // weAXS-USDC
  "HopVRTvFvRe1ED3dRCQrt1h5onkMvY3tKUHRVQMc7MMH",
  // weSHIB-USDC
  "SU7vPveBjEuR5tgQwidRqqTxn1WwraHpydHHBpM2W96",
  // SBR-USDC
  "5cmAS6Mj4pG2Vp9hhyu3kpK9yvC7P6ejh9HiobpTE6Jc",
  // OXS-USDC
  "8ekXiGjEjtWzd2us3rAsusKv7kKEhPENV7nvzS7RGRYY",
  // CWAR-USDC
  "13uCPybNakXHGVd2DDVB7o2uwXuf9GqPFkvJMVgKy6UJ",
  // UPS-USDC
  "FSSRqrGrDjDXnojhSDrDBknJeQ83pyACemnaMLaZDD1U",
  // weSAND-USDC
  "3cmPpX8kKzEra2umtLCDxMfjma82ELtAMaSYVmdaNLxi",
  // weMANA-USDC
  "7Z1c6GHutf3q2MNheyFE8KMNVEALuiPaqoEMyjbCbuku",
  // CAVE-USDC
  "2PfKnjEfoUoVDbDS1YwvZ8HuPGBCpN831mnTuqTAJZjH",
  // GENE-USDC
  "Enq8vJucRbkzKA1i1PahJNhMyUTzoVL5Cs8n5rC3NLGn",
  // GENE-RAY
  "8FrCybrh7UFznP1hVHg8kXZ8bhii37c7BGzmjkdcsGJp",
  // APT-USDC
  "4crhN3D8R5rnZd66q9b32P7K649e5XdzCfPMPiTzBceH",
  // GOFX-USDC
  "zoouer92idprkptX76yvhp4stK2keTzJpMNkeLqtxAx",
  // SONAR-USDC
  "CrWbfKwyAaUfYctXWF9iaDUP4AH5t6k6bbaWnXBL8nHm",
  // JSOL-SOL
  "D8pasgJWjP9wy39fzeD8BUjQMvYCZxABzPcnuoDSLHBB",
  // JSOL-USDC
  "7e8GrkwsRm5sS5UaKobLJUNu9esmrzg37dqX6aQyuver",
  // SHILL-USDC
  "FTyJCLwQ3YvVfanJp8mtC2eqmvZPpzSpmNLqWpaPaXbC",
  // DFL-USDC
  "8GJdzPuEBPP3BHJpcspBcfpRZV4moZMFwhTAuXebaPL8",
  // BOKU-USDC
  "FsERtRjCEQNyND3ccnMGrd61ntPmJ3tbZs4vvcCzMr1L",
  // MIMO-SOL
  "DqYSvijBXydSx9GfvVDjEzUg5StLLrkqZVPzsU2FeVZ2",
  // wbWBNB-USDC
  "Fb1WR1kYvG1tHu4pwAxXQpdKT8Grh9i7ES9rZusLg7D6",
  // wePEOPLE-USDC
  "GfvqUB36CPfqZDz5ntQ2YsoKRwg1MCewmurhc7jw3P5s",
  // XTAG-USDC
  "Hv1BFhyADPjYXTqEeMgwzoybnNwYrHXNv7U2VjcAuEDr",
  // KKO-USDC
  "FvN7dJz7GX1XB1BTk6jD5rEKRxQc3ZwNkWJKai5sBJWS",
  // VI-USDC
  "MphbxYtji1FSkm7G2FNGpUUz5AWn7iRPNFAvEqD4mzE",
  // SOLC-USDT
  "783kPvwHwDXaU32kV8NK5dB4JVeMWQwe8a3WUNZFpupr",
  // STR-USDC
  "E9Z2JeEKS2WGGyA18mGU33rnQskK9moPhM4tdzrv24fh",
  // SPWN-USDC
  "Bhw7DbVwWMcTBXoKaWgsCaofL6QqmQQ65FCSGfgCEawm",
  // ISOLA-USDT
  "69Mo81rUPDgru4UbigPQovx7cYBxpEm44qQok8wcut4M",
  // TTT-USDC
  "HcqHvH27wk42L1ND5YPhLDJu7oGsU7HGSreMiXdq5LNK",
  // RUN-USDC
  "zuivKkgkNFFkV9jfNpsU1p5tWNbDWUEx5XX16m4k2Ej",
  // CRWNY-USDC
  "4ELBQuq3ivhLamfCT36As5sXLkQDWRJw1pJ9JVFLp6gK",
  // CRWNY-RAY
  "HARRXESCwid3xMi2qThag1PXzmp6rDhAzMR9THhFRQGf",
  // BLOCK-USDC
  "CfBSfVTcYFJsD8vZ2fTiMGkUYFim2rv8weAoqHxUU2pn",
  // REAL-USDC
  "A7ZxDrK9LSkVXhfRTu2pRCinwYfdxW2kK6DaJk12jRWw",
  // PRISM-USDC
  "4ZYiiVakejxGyJ3tuBzYWoHyEV1rk7Hm7viydG6DNaUN",
  // MBS-USDC
  "6eRECBcCVP82AvAd6Di4rZApa2btLf8RDUqrTigt4hS4"
];
var TESTNET_OFFICIAL_LIQUIDITY_POOLS = [];
var DEVNET_OFFICIAL_LIQUIDITY_POOLS = [];

// src/baseInfo/apiLink.ts
var ENDPOINT = "https://api.raydium.io";
var RAYDIUM_MAINNET = {
  time: "/v2/main/chain/time",
  info: "/v2/main/info",
  pairs: "/v2/main/pairs",
  price: "/v2/main/price",
  rpcs: "/v2/main/rpcs",
  version: "/v2/main/version",
  farmApr: "/v2/main/farm/info",
  farmAprLine: "/v2/main/farm-apr-tv",
  tokenInfo: "/v2/sdk/token/raydium.mainnet.json",
  poolInfo: "/v2/sdk/liquidity/mainnet.json",
  dailyPoolInfo: "/v2/sdk/liquidity/date",
  uiPoolInfo: "/v2/sdk/liquidity/mainnet.ui.json",
  searchPool: "/v2/sdk/liquidity/mint/",
  farmInfo: "/v2/sdk/farm-v2/mainnet.json",
  idoInfo: "/v2/main/ido/pools",
  idoProjectInfo: "/v2/main/ido/project/<id>",
  // CLMM
  clmmPools: "/v2/ammV3/ammPools",
  clmmConfigs: "/v2/ammV3/ammConfigs",
  clmmPositionLine: "/v2/ammV3/positionLine/<poolId>"
};

// src/baseInfo/program.ts
import { PublicKey as PublicKey21 } from "@solana/web3.js";
var MAINNET_PROGRAM_ID = {
  SERUM_MARKET: new PublicKey21("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),
  OPENBOOK_MARKET: new PublicKey21("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),
  UTIL1216: new PublicKey21("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),
  FarmV3: new PublicKey21("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),
  FarmV5: new PublicKey21("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),
  FarmV6: new PublicKey21("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),
  AmmV4: new PublicKey21("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),
  AmmStable: new PublicKey21("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),
  CLMM: new PublicKey21("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),
  Router: new PublicKey21("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS")
};
var DEVNET_PROGRAM_ID = {
  SERUM_MARKET: PublicKey21.default,
  OPENBOOK_MARKET: new PublicKey21("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),
  UTIL1216: PublicKey21.default,
  FarmV3: new PublicKey21("85BFyr98MbCUU9MVTEgzx1nbhWACbJqLzho6zd6DZcWL"),
  FarmV5: new PublicKey21("EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2"),
  FarmV6: new PublicKey21("Farm2hJLcqPtPg8M4rR6DMrsRNc5TPm5Cs4bVQrMe2T7"),
  AmmV4: new PublicKey21("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8"),
  AmmStable: new PublicKey21("DDg4VmQaJV9ogWce7LpcjBA9bv22wRp5uaTPa5pGjijF"),
  CLMM: new PublicKey21("devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH"),
  Router: new PublicKey21("BVChZ3XFEwTMUk1o9i3HAf91H6mFxSwa5X2wFAWhYPhU")
};

// src/tradeV2/trade.ts
import { createTransferInstruction as createTransferInstruction2, TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID4, TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID4 } from "@solana/spl-token";
import { PublicKey as PublicKey23 } from "@solana/web3.js";
import BN17 from "bn.js";

// src/tradeV2/instrument.ts
import { TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID3, TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID3 } from "@solana/spl-token";
import { PublicKey as PublicKey22, TransactionInstruction as TransactionInstruction11 } from "@solana/web3.js";
function routeInstruction(programId, wallet, userSourceToken, userRouteToken, userDestinationToken, inputMint, routeMint, poolKeyA, poolKeyB, amountIn, amountOut, remainingAccounts) {
  const dataLayout = struct([u82("instruction"), u64("amountIn"), u64("amountOut")]);
  const keys = [
    { pubkey: wallet, isSigner: true, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID3, isSigner: false, isWritable: false }
  ];
  keys.push(...makeInnerInsKey(poolKeyA, inputMint, userSourceToken, userRouteToken, remainingAccounts[0]));
  keys.push(...makeInnerInsKey(poolKeyB, routeMint, userRouteToken, userDestinationToken, remainingAccounts[1]));
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      instruction: 8,
      amountIn,
      amountOut
    },
    data
  );
  return new TransactionInstruction11({
    keys,
    programId,
    data
  });
}
function makeInnerInsKey(itemPool, inMint, userInAccount, userOutAccount, remainingAccount) {
  if (itemPool.version === 4) {
    const poolKey = jsonInfo2PoolKeys(itemPool);
    return [
      { pubkey: poolKey.programId, isSigner: false, isWritable: false },
      { pubkey: userInAccount, isSigner: false, isWritable: true },
      { pubkey: userOutAccount, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: poolKey.authority, isSigner: false, isWritable: false },
      { pubkey: poolKey.marketProgramId, isSigner: false, isWritable: false },
      { pubkey: poolKey.marketAuthority, isSigner: false, isWritable: false },
      { pubkey: poolKey.openOrders, isSigner: false, isWritable: true },
      { pubkey: poolKey.baseVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.quoteVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketId, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketBids, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketAsks, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketEventQueue, isSigner: false, isWritable: true },
      ...poolKey.marketProgramId.toString() === "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX" ? [
        { pubkey: poolKey.marketBaseVault, isSigner: false, isWritable: true },
        { pubkey: poolKey.marketQuoteVault, isSigner: false, isWritable: true }
      ] : [
        { pubkey: poolKey.id, isSigner: false, isWritable: true },
        { pubkey: poolKey.id, isSigner: false, isWritable: true }
      ]
    ];
  } else if (itemPool.version === 5) {
    const poolKey = jsonInfo2PoolKeys(itemPool);
    return [
      { pubkey: poolKey.programId, isSigner: false, isWritable: false },
      { pubkey: userInAccount, isSigner: false, isWritable: true },
      { pubkey: userOutAccount, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: poolKey.authority, isSigner: false, isWritable: false },
      { pubkey: poolKey.marketProgramId, isSigner: false, isWritable: false },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: new PublicKey22("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"), isSigner: false, isWritable: false },
      { pubkey: poolKey.openOrders, isSigner: false, isWritable: true },
      { pubkey: poolKey.baseVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.quoteVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketId, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketBids, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketAsks, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketEventQueue, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true }
    ];
  } else if (itemPool.version === 6) {
    const baseIn = itemPool.mintA.mint.toString() === inMint;
    return [
      { pubkey: new PublicKey22(String(itemPool.programId)), isSigner: false, isWritable: false },
      { pubkey: userInAccount, isSigner: false, isWritable: true },
      { pubkey: userOutAccount, isSigner: false, isWritable: true },
      { pubkey: itemPool.ammConfig.id, isSigner: false, isWritable: false },
      { pubkey: itemPool.id, isSigner: false, isWritable: true },
      { pubkey: baseIn ? itemPool.mintA.vault : itemPool.mintB.vault, isSigner: false, isWritable: true },
      { pubkey: baseIn ? itemPool.mintB.vault : itemPool.mintA.vault, isSigner: false, isWritable: true },
      { pubkey: itemPool.observationId, isSigner: false, isWritable: true },
      ...itemPool.mintA.programId.equals(TOKEN_2022_PROGRAM_ID3) || itemPool.mintB.programId.equals(TOKEN_2022_PROGRAM_ID3) ? [
        { pubkey: TOKEN_2022_PROGRAM_ID3, isSigner: false, isWritable: false },
        { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: baseIn ? itemPool.mintA.mint : itemPool.mintB.mint, isSigner: false, isWritable: false },
        { pubkey: baseIn ? itemPool.mintB.mint : itemPool.mintA.mint, isSigner: false, isWritable: false }
      ] : [],
      ...(remainingAccount != null ? remainingAccount : []).map((i) => ({ pubkey: i, isSigner: false, isWritable: true })),
      {
        pubkey: getPdaExBitmapAccount(new PublicKey22(String(itemPool.programId)), itemPool.id).publicKey,
        isSigner: false,
        isWritable: true
      }
    ];
  } else {
    throw Error("make swap ins error");
  }
}

// src/tradeV2/trade.ts
var TradeV2 = class extends Base {
  static getAllRoute({
    inputMint,
    outputMint,
    apiPoolList,
    clmmList,
    allowedRouteToken2022 = false
  }) {
    var _a, _b;
    inputMint = inputMint.toString() === PublicKey23.default.toString() ? new PublicKey23(WSOL.mint) : inputMint;
    outputMint = outputMint.toString() === PublicKey23.default.toString() ? new PublicKey23(WSOL.mint) : outputMint;
    const needSimulate = {};
    const needTickArray = {};
    const needCheckToken = /* @__PURE__ */ new Set();
    const directPath = [];
    const routePathDict = {};
    for (const itemAmmPool of clmmList != null ? clmmList : []) {
      if (itemAmmPool.mintA.mint.equals(inputMint) && itemAmmPool.mintB.mint.equals(outputMint) || itemAmmPool.mintA.mint.equals(outputMint) && itemAmmPool.mintB.mint.equals(inputMint)) {
        directPath.push(itemAmmPool);
        needTickArray[itemAmmPool.id.toString()] = itemAmmPool;
      }
      if (itemAmmPool.mintA.mint.equals(inputMint) && (itemAmmPool.mintB.programId.equals(TOKEN_PROGRAM_ID4) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintB.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintB.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintB.decimals
          };
        routePathDict[t].in.push(itemAmmPool);
      }
      if (itemAmmPool.mintB.mint.equals(inputMint) && (itemAmmPool.mintA.programId.equals(TOKEN_PROGRAM_ID4) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintA.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintA.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintA.decimals
          };
        routePathDict[t].in.push(itemAmmPool);
      }
      if (itemAmmPool.mintA.mint.equals(outputMint) && (itemAmmPool.mintB.programId.equals(TOKEN_PROGRAM_ID4) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintB.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintB.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintB.decimals
          };
        routePathDict[t].out.push(itemAmmPool);
      }
      if (itemAmmPool.mintB.mint.equals(outputMint) && (itemAmmPool.mintA.programId.equals(TOKEN_PROGRAM_ID4) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintA.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintA.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintA.decimals
          };
        routePathDict[t].out.push(itemAmmPool);
      }
    }
    const addLiquidityPools = [];
    const _inputMint = inputMint.toString();
    const _outputMint = outputMint.toString();
    for (const itemAmmPool of (_a = (apiPoolList != null ? apiPoolList : {}).official) != null ? _a : []) {
      if (itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint || itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint) {
        directPath.push(itemAmmPool);
        needSimulate[itemAmmPool.id] = itemAmmPool;
        addLiquidityPools.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _inputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _inputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _outputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _outputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
      }
    }
    const _insertAddLiquidityPool = addLiquidityPools.length === 0;
    for (const itemAmmPool of (_b = (apiPoolList != null ? apiPoolList : {}).unOfficial) != null ? _b : []) {
      if (itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint || itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint) {
        directPath.push(itemAmmPool);
        needSimulate[itemAmmPool.id] = itemAmmPool;
        if (_insertAddLiquidityPool) addLiquidityPools.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _inputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _inputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _outputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _outputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID4,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
      }
    }
    for (const t of Object.keys(routePathDict)) {
      if (routePathDict[t].in.length === 1 && routePathDict[t].out.length === 1 && String(routePathDict[t].in[0].id) === String(routePathDict[t].out[0].id)) {
        delete routePathDict[t];
        continue;
      }
      if (routePathDict[t].in.length === 0 || routePathDict[t].out.length === 0) {
        delete routePathDict[t];
        continue;
      }
      const info = routePathDict[t];
      for (const infoIn of info.in) {
        for (const infoOut of info.out) {
          if (infoIn.version === 6 && needTickArray[infoIn.id.toString()] === void 0) {
            needTickArray[infoIn.id.toString()] = infoIn;
            if (infoIn.mintA.programId.equals(TOKEN_2022_PROGRAM_ID4)) needCheckToken.add(infoIn.mintA.mint.toString());
            if (infoIn.mintB.programId.equals(TOKEN_2022_PROGRAM_ID4)) needCheckToken.add(infoIn.mintB.mint.toString());
          } else if (infoIn.version !== 6 && needSimulate[infoIn.id] === void 0) {
            needSimulate[infoIn.id] = infoIn;
          }
          if (infoOut.version === 6 && needTickArray[infoOut.id.toString()] === void 0) {
            needTickArray[infoOut.id.toString()] = infoOut;
            if (infoOut.mintA.programId.equals(TOKEN_2022_PROGRAM_ID4)) needCheckToken.add(infoOut.mintA.mint.toString());
            if (infoOut.mintB.programId.equals(TOKEN_2022_PROGRAM_ID4)) needCheckToken.add(infoOut.mintB.mint.toString());
          } else if (infoOut.version !== 6 && needSimulate[infoOut.id] === void 0) {
            needSimulate[infoOut.id] = infoOut;
          }
        }
      }
    }
    for (const item of directPath) {
      if (item.version === 6) {
        if (item.mintA.programId.equals(TOKEN_2022_PROGRAM_ID4)) needCheckToken.add(item.mintA.mint.toString());
        if (item.mintB.programId.equals(TOKEN_2022_PROGRAM_ID4)) needCheckToken.add(item.mintB.mint.toString());
      }
    }
    return {
      directPath,
      addLiquidityPools,
      routePathDict,
      needSimulate: Object.values(needSimulate),
      needTickArray: Object.values(needTickArray),
      needCheckToken: [...needCheckToken]
    };
  }
  static fetchMultipleInfo(_0) {
    return __async(this, arguments, function* ({
      connection,
      pools,
      batchRequest = true
    }) {
      if (pools.find((i) => i.version === 5)) yield initStableModelLayout(connection);
      const instructions = pools.map(
        (pool) => Liquidity.makeSimulatePoolInfoInstruction({ poolKeys: jsonInfo2PoolKeys(pool) })
      );
      const logs = yield simulateMultipleInstruction(
        connection,
        instructions.map((i) => i.innerTransaction.instructions).flat(),
        "GetPoolData",
        batchRequest
      );
      const poolsInfo = {};
      for (const log of logs) {
        const json = parseSimulateLogToJson(log, "GetPoolData");
        const ammId = JSON.parse(json)["amm_id"];
        const status = new BN17(parseSimulateValue(json, "status"));
        const baseDecimals = Number(parseSimulateValue(json, "coin_decimals"));
        const quoteDecimals = Number(parseSimulateValue(json, "pc_decimals"));
        const lpDecimals = Number(parseSimulateValue(json, "lp_decimals"));
        const baseReserve = new BN17(parseSimulateValue(json, "pool_coin_amount"));
        const quoteReserve = new BN17(parseSimulateValue(json, "pool_pc_amount"));
        const lpSupply = new BN17(parseSimulateValue(json, "pool_lp_supply"));
        let startTime = "0";
        try {
          startTime = parseSimulateValue(json, "pool_open_time");
        } catch (error) {
        }
        poolsInfo[ammId] = {
          ammId,
          status,
          baseDecimals,
          quoteDecimals,
          lpDecimals,
          baseReserve,
          quoteReserve,
          lpSupply,
          startTime: new BN17(startTime)
        };
      }
      return poolsInfo;
    });
  }
  static getAddLiquidityDefaultPool({
    addLiquidityPools,
    poolInfosCache
  }) {
    if (addLiquidityPools.length === 0) return void 0;
    if (addLiquidityPools.length === 1) return addLiquidityPools[0];
    addLiquidityPools.sort((a, b) => b.version - a.version);
    if (addLiquidityPools[0].version !== addLiquidityPools[1].version) return addLiquidityPools[0];
    const _addLiquidityPools = addLiquidityPools.filter((i) => i.version === addLiquidityPools[0].version);
    _addLiquidityPools.sort((a, b) => this.ComparePoolSize(a, b, poolInfosCache));
    return _addLiquidityPools[0];
  }
  static ComparePoolSize(a, b, ammIdToPoolInfo) {
    const aInfo = ammIdToPoolInfo[a.id];
    const bInfo = ammIdToPoolInfo[b.id];
    if (aInfo === void 0) return 1;
    if (bInfo === void 0) return -1;
    if (a.baseMint === b.baseMint) {
      const sub = aInfo.baseReserve.sub(bInfo.baseReserve);
      return sub.gte(ZERO) ? -1 : 1;
    } else {
      const sub = aInfo.baseReserve.sub(bInfo.quoteReserve);
      return sub.gte(ZERO) ? -1 : 1;
    }
  }
  static getAllRouteComputeAmountOut({
    inputTokenAmount,
    outputToken,
    directPath,
    routePathDict,
    simulateCache,
    tickCache,
    mintInfos,
    slippage,
    chainTime,
    epochInfo,
    feeConfig
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const _amountInFee = feeConfig === void 0 ? new BN17(0) : inputTokenAmount.raw.mul(new BN17(feeConfig.feeBps.toNumber())).div(new BN17(1e4));
    const _amoutIn = inputTokenAmount.raw.sub(_amountInFee);
    const amountIn = inputTokenAmount instanceof TokenAmount ? new TokenAmount(inputTokenAmount.token, _amoutIn) : new CurrencyAmount(inputTokenAmount.currency, _amoutIn);
    const _inFeeConfig = feeConfig === void 0 ? void 0 : {
      feeAmount: _amountInFee,
      feeAccount: feeConfig.feeAccount
    };
    const outRoute = [];
    for (const itemPool of directPath) {
      try {
        outRoute.push(__spreadProps(__spreadValues({}, this.computeAmountOut({
          itemPool,
          tickCache,
          simulateCache,
          chainTime,
          epochInfo,
          mintInfos,
          slippage,
          outputToken,
          amountIn
        })), {
          feeConfig: _inFeeConfig
        }));
      } catch (e) {
      }
    }
    for (const [routeMint, info] of Object.entries(routePathDict)) {
      const routeToken = new Token(info.mintProgram, routeMint, info.mDecimals);
      const maxFirstIn = info.in.map((i) => {
        try {
          return {
            pool: i,
            data: this.computeAmountOut({
              itemPool: i,
              tickCache,
              simulateCache,
              chainTime,
              epochInfo,
              mintInfos,
              slippage,
              outputToken: routeToken,
              amountIn
            })
          };
        } catch (e) {
          return void 0;
        }
      }).sort((_a2, _b2) => {
        var _a3, _b3, _c2, _d2;
        const a = _a2 === void 0 ? ZERO : _a2.data.amountOut.amount.raw.sub((_b3 = (_a3 = _a2.data.amountOut.fee) == null ? void 0 : _a3.raw) != null ? _b3 : ZERO);
        const b = _b2 === void 0 ? ZERO : _b2.data.amountOut.amount.raw.sub((_d2 = (_c2 = _b2.data.amountOut.fee) == null ? void 0 : _c2.raw) != null ? _d2 : ZERO);
        return a.lt(b) ? 1 : -1;
      })[0];
      if (maxFirstIn === void 0) continue;
      const routeAmountIn = new TokenAmount(
        routeToken,
        maxFirstIn.data.amountOut.amount.raw.sub((_b = (_a = maxFirstIn.data.amountOut.fee) == null ? void 0 : _a.raw) != null ? _b : ZERO)
      );
      for (const iOutPool of info.out) {
        try {
          const outC = this.computeAmountOut({
            itemPool: iOutPool,
            tickCache,
            simulateCache,
            chainTime,
            epochInfo,
            mintInfos,
            slippage,
            outputToken,
            amountIn: routeAmountIn
          });
          outRoute.push({
            allTrade: maxFirstIn.data.allTrade && outC.allTrade ? true : false,
            amountIn: maxFirstIn.data.amountIn,
            amountOut: outC.amountOut,
            minAmountOut: outC.minAmountOut,
            currentPrice: void 0,
            executionPrice: new Price(
              (_c = maxFirstIn.data.amountIn.amount.token) != null ? _c : maxFirstIn.data.amountIn.amount.currency,
              maxFirstIn.data.amountIn.amount.raw,
              (_d = outC.amountOut.amount.token) != null ? _d : outC.amountOut.amount.currency,
              outC.amountOut.amount.raw.sub((_f = (_e = outC.amountOut.fee) == null ? void 0 : _e.raw) != null ? _f : ZERO)
            ),
            priceImpact: maxFirstIn.data.priceImpact.add(outC.priceImpact),
            fee: [maxFirstIn.data.fee[0], outC.fee[0]],
            routeType: "route",
            poolKey: [maxFirstIn.pool, iOutPool],
            remainingAccounts: [maxFirstIn.data.remainingAccounts[0], outC.remainingAccounts[0]],
            minMiddleAmountFee: ((_g = outC.amountOut.fee) == null ? void 0 : _g.raw) ? new TokenAmount(
              (_h = maxFirstIn.data.amountOut.amount.token) != null ? _h : maxFirstIn.data.amountOut.amount.currency,
              ((_j = (_i = maxFirstIn.data.amountOut.fee) == null ? void 0 : _i.raw) != null ? _j : ZERO).add((_l = (_k = outC.amountOut.fee) == null ? void 0 : _k.raw) != null ? _l : ZERO)
            ) : void 0,
            middleToken: maxFirstIn.data.amountOut.amount.token,
            poolReady: maxFirstIn.data.poolReady && outC.poolReady,
            poolType: [maxFirstIn.data.poolType, outC.poolType],
            feeConfig: _inFeeConfig,
            expirationTime: minExpirationTime(maxFirstIn.data.expirationTime, outC.expirationTime),
            slippage: outC.slippage,
            clmmExPriceX64: [maxFirstIn.data.clmmExPriceX64[0], outC.clmmExPriceX64[0]]
          });
        } catch (e) {
        }
      }
    }
    return outRoute.filter((i) => i.allTrade).sort((a, b) => a.amountOut.amount.raw.sub(b.amountOut.amount.raw).gt(ZERO) ? -1 : 1);
  }
  static computeAmountOut({
    itemPool,
    tickCache,
    simulateCache,
    chainTime,
    epochInfo,
    mintInfos,
    slippage,
    outputToken,
    amountIn
  }) {
    if (itemPool.version === 6) {
      const {
        allTrade,
        realAmountIn,
        amountOut,
        minAmountOut,
        expirationTime,
        currentPrice,
        executionPrice,
        priceImpact,
        fee,
        remainingAccounts,
        executionPriceX64
      } = Clmm.computeAmountOutFormat({
        poolInfo: itemPool,
        tickArrayCache: tickCache[itemPool.id.toString()],
        amountIn,
        currencyOut: outputToken,
        slippage,
        token2022Infos: mintInfos,
        epochInfo,
        catchLiquidityInsufficient: true
      });
      return {
        allTrade,
        amountIn: realAmountIn,
        amountOut,
        minAmountOut,
        currentPrice,
        executionPrice,
        priceImpact,
        fee: [fee],
        remainingAccounts: [remainingAccounts],
        routeType: "amm",
        poolKey: [itemPool],
        poolReady: itemPool.startTime < chainTime,
        poolType: "CLMM",
        expirationTime: minExpirationTime(realAmountIn.expirationTime, expirationTime),
        slippage,
        clmmExPriceX64: [executionPriceX64]
      };
    } else {
      if (![1, 6, 7].includes(simulateCache[itemPool.id].status.toNumber())) throw Error("swap error");
      const { amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee } = Liquidity.computeAmountOut({
        poolKeys: jsonInfo2PoolKeys(itemPool),
        poolInfo: simulateCache[itemPool.id],
        amountIn,
        currencyOut: outputToken,
        slippage
      });
      return {
        amountIn: { amount: amountIn, fee: void 0, expirationTime: void 0 },
        amountOut: { amount: amountOut, fee: void 0, expirationTime: void 0 },
        minAmountOut: { amount: minAmountOut, fee: void 0, expirationTime: void 0 },
        currentPrice,
        executionPrice,
        priceImpact,
        fee: [fee],
        routeType: "amm",
        poolKey: [itemPool],
        remainingAccounts: [],
        poolReady: simulateCache[itemPool.id].startTime.toNumber() < chainTime,
        poolType: itemPool.version === 5 ? "STABLE" : void 0,
        expirationTime: void 0,
        allTrade: true,
        slippage,
        clmmExPriceX64: [void 0]
      };
    }
  }
  static makeSwapInstruction({ routeProgram, ownerInfo, inputMint, swapInfo }) {
    var _a, _b, _c, _d, _e, _f;
    const slippage = swapInfo.slippage.numerator.toNumber() / swapInfo.slippage.denominator.toNumber();
    if (swapInfo.routeType === "amm") {
      if (swapInfo.poolKey[0].version === 6) {
        const _poolKey = swapInfo.poolKey[0];
        const sqrtPriceLimitX64 = inputMint.equals(_poolKey.mintA.mint) ? slippage > 0.5 || MIN_SQRT_PRICE_X64.add(ONE).gt(swapInfo.clmmExPriceX64[0].div(new BN17(10))) ? MIN_SQRT_PRICE_X64.add(ONE) : swapInfo.clmmExPriceX64[0].div(new BN17(10)) : slippage > 0.5 || MAX_SQRT_PRICE_X64.sub(ONE).lt(swapInfo.clmmExPriceX64[0].mul(new BN17(10))) ? MAX_SQRT_PRICE_X64.sub(ONE) : swapInfo.clmmExPriceX64[0].mul(new BN17(10));
        return Clmm.makeSwapBaseInInstructions({
          poolInfo: _poolKey,
          ownerInfo: {
            wallet: ownerInfo.wallet,
            tokenAccountA: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.sourceToken : ownerInfo.destinationToken,
            tokenAccountB: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.destinationToken : ownerInfo.sourceToken
          },
          inputMint,
          amountIn: swapInfo.amountIn.amount.raw,
          amountOutMin: swapInfo.minAmountOut.amount.raw.sub((_b = (_a = swapInfo.minAmountOut.fee) == null ? void 0 : _a.raw) != null ? _b : ZERO),
          sqrtPriceLimitX64,
          remainingAccounts: swapInfo.remainingAccounts[0]
        });
      } else {
        const _poolKey = swapInfo.poolKey[0];
        return Liquidity.makeSwapInstruction({
          poolKeys: jsonInfo2PoolKeys(_poolKey),
          userKeys: {
            tokenAccountIn: ownerInfo.sourceToken,
            tokenAccountOut: ownerInfo.destinationToken,
            owner: ownerInfo.wallet
          },
          amountIn: swapInfo.amountIn.amount.raw,
          amountOut: swapInfo.minAmountOut.amount.raw.sub((_d = (_c = swapInfo.minAmountOut.fee) == null ? void 0 : _c.raw) != null ? _d : ZERO),
          fixedSide: "in"
        });
      }
    } else if (swapInfo.routeType === "route") {
      const poolKey1 = swapInfo.poolKey[0];
      const poolKey2 = swapInfo.poolKey[1];
      if (ownerInfo.routeToken === void 0) throw Error("owner route token account check error");
      return {
        address: {},
        innerTransaction: {
          instructions: [
            routeInstruction(
              routeProgram,
              ownerInfo.wallet,
              ownerInfo.sourceToken,
              ownerInfo.routeToken,
              ownerInfo.destinationToken,
              inputMint.toString(),
              swapInfo.middleToken.mint.toString(),
              poolKey1,
              poolKey2,
              swapInfo.amountIn.amount.raw,
              swapInfo.minAmountOut.amount.raw.sub((_f = (_e = swapInfo.minAmountOut.fee) == null ? void 0 : _e.raw) != null ? _f : ZERO),
              swapInfo.remainingAccounts
            )
          ],
          signers: [],
          lookupTableAddress: [
            poolKey1.lookupTableAccount ? new PublicKey23(poolKey1.lookupTableAccount) : PublicKey23.default,
            poolKey2.lookupTableAccount ? new PublicKey23(poolKey2.lookupTableAccount) : PublicKey23.default
          ].filter((i) => i && !i.equals(PublicKey23.default)),
          instructionTypes: [35 /* routeSwap */]
        }
      };
    } else {
      throw Error("route type error");
    }
  }
  static makeSwapInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      swapInfo,
      ownerInfo,
      computeBudgetConfig,
      routeProgram,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const amountIn = swapInfo.amountIn;
      const amountOut = swapInfo.amountOut;
      const useSolBalance = !(amountIn.amount instanceof TokenAmount);
      const outSolBalance = !(amountOut.amount instanceof TokenAmount);
      const inputMint = amountIn.amount instanceof TokenAmount ? amountIn.amount.token.mint : Token.WSOL.mint;
      const inputProgramId = amountIn.amount instanceof TokenAmount ? amountIn.amount.token.programId : Token.WSOL.programId;
      const outputMint = amountOut.amount instanceof TokenAmount ? amountOut.amount.token.mint : Token.WSOL.mint;
      const outputProgramId = amountOut.amount instanceof TokenAmount ? amountOut.amount.token.programId : Token.WSOL.programId;
      const sourceToken = yield this._selectOrCreateTokenAccount({
        programId: inputProgramId,
        mint: inputMint,
        tokenAccounts: useSolBalance ? [] : ownerInfo.tokenAccounts,
        createInfo: useSolBalance ? {
          connection,
          payer: ownerInfo.wallet,
          amount: amountIn.amount.raw,
          frontInstructions,
          endInstructions,
          signers,
          frontInstructionsType,
          endInstructionsType
        } : void 0,
        owner: ownerInfo.wallet,
        associatedOnly: useSolBalance ? false : ownerInfo.associatedOnly,
        checkCreateATAOwner: ownerInfo.checkCreateATAOwner
      });
      if (sourceToken === void 0) {
        throw Error("input account check error");
      }
      const destinationToken = yield this._selectOrCreateTokenAccount({
        programId: outputProgramId,
        mint: outputMint,
        tokenAccounts: ownerInfo.tokenAccounts,
        createInfo: {
          connection,
          payer: ownerInfo.wallet,
          amount: 0,
          frontInstructions,
          endInstructions: outSolBalance ? endInstructions : void 0,
          signers,
          frontInstructionsType,
          endInstructionsType
        },
        owner: ownerInfo.wallet,
        associatedOnly: ownerInfo.associatedOnly,
        checkCreateATAOwner: ownerInfo.checkCreateATAOwner
      });
      let routeToken = void 0;
      if (swapInfo.routeType === "route") {
        const middleMint = swapInfo.middleToken;
        routeToken = yield this._selectOrCreateTokenAccount({
          programId: middleMint.programId,
          mint: middleMint.mint,
          tokenAccounts: ownerInfo.tokenAccounts,
          createInfo: {
            connection,
            payer: ownerInfo.wallet,
            amount: 0,
            frontInstructions,
            endInstructions,
            signers,
            frontInstructionsType,
            endInstructionsType
          },
          owner: ownerInfo.wallet,
          associatedOnly: false,
          checkCreateATAOwner: ownerInfo.checkCreateATAOwner
        });
      }
      const ins = this.makeSwapInstruction({
        routeProgram,
        inputMint,
        swapInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          sourceToken,
          routeToken,
          destinationToken
        }
      });
      const transferIns = [];
      const transferInsType = [];
      if (swapInfo.feeConfig !== void 0) {
        transferIns.push(
          createTransferInstruction2(
            sourceToken,
            swapInfo.feeConfig.feeAccount,
            ownerInfo.wallet,
            swapInfo.feeConfig.feeAmount.toNumber()
          )
        );
        transferInsType.push(4 /* transferAmount */);
      }
      const transferAddCheck = yield splitTxAndSigners({
        connection,
        makeTxVersion,
        computeBudgetConfig,
        payer: ownerInfo.wallet,
        innerTransaction: [
          { instructionTypes: transferInsType, instructions: transferIns, signers: [] },
          ins.innerTransaction
        ],
        lookupTableCache
      });
      return {
        address: ins.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.wallet,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...transferAddCheck.length > 1 ? [] : [{ instructionTypes: transferInsType, instructions: transferIns, signers: [] }],
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
};

// src/utils/createMarket.ts
import { createInitializeAccountInstruction as createInitializeAccountInstruction2 } from "@solana/spl-token";
import { PublicKey as PublicKey24, SystemProgram as SystemProgram6, TransactionInstruction as TransactionInstruction13 } from "@solana/web3.js";
import BN18 from "bn.js";
function accountFlagsLayout(property = "accountFlags") {
  const ACCOUNT_FLAGS_LAYOUT = new WideBits(property);
  ACCOUNT_FLAGS_LAYOUT.addBoolean("initialized");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("market");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("openOrders");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("requestQueue");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("eventQueue");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("bids");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("asks");
  return ACCOUNT_FLAGS_LAYOUT;
}
var MARKET_STATE_LAYOUT_V2 = struct([
  blob(5),
  accountFlagsLayout("accountFlags"),
  publicKey("ownAddress"),
  u64("vaultSignerNonce"),
  publicKey("baseMint"),
  publicKey("quoteMint"),
  publicKey("baseVault"),
  u64("baseDepositsTotal"),
  u64("baseFeesAccrued"),
  publicKey("quoteVault"),
  u64("quoteDepositsTotal"),
  u64("quoteFeesAccrued"),
  u64("quoteDustThreshold"),
  publicKey("requestQueue"),
  publicKey("eventQueue"),
  publicKey("bids"),
  publicKey("asks"),
  u64("baseLotSize"),
  u64("quoteLotSize"),
  u64("feeRateBps"),
  u64("referrerRebatesAccrued"),
  blob(7)
]);
var MarketV2 = class extends Base {
  static makeCreateMarketInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      wallet,
      baseInfo,
      quoteInfo,
      lotSize,
      // 1
      tickSize,
      // 0.01
      dexProgramId,
      makeTxVersion,
      lookupTableCache,
      requestQueueSpacce,
      eventQueueSpacce,
      orderbookQueueSpacce
    }) {
      const market = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const requestQueue = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const eventQueue = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const bids = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const asks = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const baseVault = generatePubKey({ fromPublicKey: wallet, programId: TOKEN_PROGRAM_ID });
      const quoteVault = generatePubKey({ fromPublicKey: wallet, programId: TOKEN_PROGRAM_ID });
      const feeRateBps = 0;
      const quoteDustThreshold = new BN18(100);
      function getVaultOwnerAndNonce() {
        const vaultSignerNonce2 = new BN18(0);
        while (true) {
          try {
            const vaultOwner2 = PublicKey24.createProgramAddressSync(
              [market.publicKey.toBuffer(), vaultSignerNonce2.toArrayLike(Buffer, "le", 8)],
              dexProgramId
            );
            return { vaultOwner: vaultOwner2, vaultSignerNonce: vaultSignerNonce2 };
          } catch (e) {
            vaultSignerNonce2.iaddn(1);
            if (vaultSignerNonce2.gt(new BN18(25555))) throw Error("find vault owner error");
          }
        }
      }
      const { vaultOwner, vaultSignerNonce } = getVaultOwnerAndNonce();
      const baseLotSize = new BN18(Math.round(__pow(10, baseInfo.decimals) * lotSize));
      const quoteLotSize = new BN18(Math.round(lotSize * __pow(10, quoteInfo.decimals) * tickSize));
      if (baseLotSize.eq(ZERO)) throw Error("lot size is too small");
      if (quoteLotSize.eq(ZERO)) throw Error("tick size or lot size is too small");
      const ins = yield this.makeCreateMarketInstruction({
        connection,
        wallet,
        marketInfo: {
          programId: dexProgramId,
          id: market,
          baseMint: baseInfo.mint,
          quoteMint: quoteInfo.mint,
          baseVault,
          quoteVault,
          vaultOwner,
          requestQueue,
          eventQueue,
          bids,
          asks,
          feeRateBps,
          quoteDustThreshold,
          vaultSignerNonce,
          baseLotSize,
          quoteLotSize,
          requestQueueSpacce,
          eventQueueSpacce,
          orderbookQueueSpacce
        }
      });
      return {
        address: ins.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: wallet,
          innerTransaction: ins.innerTransactions,
          lookupTableCache
        })
      };
    });
  }
  static makeCreateMarketInstruction(_0) {
    return __async(this, arguments, function* ({
      connection,
      wallet,
      marketInfo
    }) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const ins1 = [];
      const accountLamports = yield connection.getMinimumBalanceForRentExemption(165);
      ins1.push(
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.baseVault.seed,
          newAccountPubkey: marketInfo.baseVault.publicKey,
          lamports: accountLamports,
          space: 165,
          programId: TOKEN_PROGRAM_ID
        }),
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.quoteVault.seed,
          newAccountPubkey: marketInfo.quoteVault.publicKey,
          lamports: accountLamports,
          space: 165,
          programId: TOKEN_PROGRAM_ID
        }),
        createInitializeAccountInstruction2(marketInfo.baseVault.publicKey, marketInfo.baseMint, marketInfo.vaultOwner),
        createInitializeAccountInstruction2(marketInfo.quoteVault.publicKey, marketInfo.quoteMint, marketInfo.vaultOwner)
      );
      const ins2 = [];
      ins2.push(
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.id.seed,
          newAccountPubkey: marketInfo.id.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption(MARKET_STATE_LAYOUT_V2.span),
          space: MARKET_STATE_LAYOUT_V2.span,
          programId: marketInfo.programId
        }),
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.requestQueue.seed,
          newAccountPubkey: marketInfo.requestQueue.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_a = marketInfo.requestQueueSpacce) != null ? _a : 5120 + 12),
          space: (_b = marketInfo.requestQueueSpacce) != null ? _b : 5120 + 12,
          programId: marketInfo.programId
        }),
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.eventQueue.seed,
          newAccountPubkey: marketInfo.eventQueue.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_c = marketInfo.eventQueueSpacce) != null ? _c : 262144 + 12),
          space: (_d = marketInfo.eventQueueSpacce) != null ? _d : 262144 + 12,
          programId: marketInfo.programId
        }),
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.bids.seed,
          newAccountPubkey: marketInfo.bids.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_e = marketInfo.orderbookQueueSpacce) != null ? _e : 65536 + 12),
          space: (_f = marketInfo.orderbookQueueSpacce) != null ? _f : 65536 + 12,
          programId: marketInfo.programId
        }),
        SystemProgram6.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.asks.seed,
          newAccountPubkey: marketInfo.asks.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_g = marketInfo.orderbookQueueSpacce) != null ? _g : 65536 + 12),
          space: (_h = marketInfo.orderbookQueueSpacce) != null ? _h : 65536 + 12,
          programId: marketInfo.programId
        }),
        this.initializeMarketInstruction({
          programId: marketInfo.programId,
          marketInfo: {
            id: marketInfo.id.publicKey,
            requestQueue: marketInfo.requestQueue.publicKey,
            eventQueue: marketInfo.eventQueue.publicKey,
            bids: marketInfo.bids.publicKey,
            asks: marketInfo.asks.publicKey,
            baseVault: marketInfo.baseVault.publicKey,
            quoteVault: marketInfo.quoteVault.publicKey,
            baseMint: marketInfo.baseMint,
            quoteMint: marketInfo.quoteMint,
            baseLotSize: marketInfo.baseLotSize,
            quoteLotSize: marketInfo.quoteLotSize,
            feeRateBps: marketInfo.feeRateBps,
            vaultSignerNonce: marketInfo.vaultSignerNonce,
            quoteDustThreshold: marketInfo.quoteDustThreshold
          }
        })
      );
      return {
        address: {
          marketId: marketInfo.id.publicKey,
          requestQueue: marketInfo.requestQueue.publicKey,
          eventQueue: marketInfo.eventQueue.publicKey,
          bids: marketInfo.bids.publicKey,
          asks: marketInfo.asks.publicKey,
          baseVault: marketInfo.baseVault.publicKey,
          quoteVault: marketInfo.quoteVault.publicKey,
          baseMint: marketInfo.baseMint,
          quoteMint: marketInfo.quoteMint
        },
        innerTransactions: [
          {
            instructions: ins1,
            signers: [],
            instructionTypes: [
              0 /* createAccount */,
              0 /* createAccount */,
              1 /* initAccount */,
              1 /* initAccount */
            ]
          },
          {
            instructions: ins2,
            signers: [],
            instructionTypes: [
              0 /* createAccount */,
              0 /* createAccount */,
              0 /* createAccount */,
              0 /* createAccount */,
              0 /* createAccount */,
              7 /* initMarket */
            ]
          }
        ]
      };
    });
  }
  static initializeMarketInstruction({
    programId,
    marketInfo
  }) {
    const dataLayout = struct([
      u82("version"),
      u322("instruction"),
      u64("baseLotSize"),
      u64("quoteLotSize"),
      u16("feeRateBps"),
      u64("vaultSignerNonce"),
      u64("quoteDustThreshold")
    ]);
    const keys = [
      { pubkey: marketInfo.id, isSigner: false, isWritable: true },
      { pubkey: marketInfo.requestQueue, isSigner: false, isWritable: true },
      { pubkey: marketInfo.eventQueue, isSigner: false, isWritable: true },
      { pubkey: marketInfo.bids, isSigner: false, isWritable: true },
      { pubkey: marketInfo.asks, isSigner: false, isWritable: true },
      { pubkey: marketInfo.baseVault, isSigner: false, isWritable: true },
      { pubkey: marketInfo.quoteVault, isSigner: false, isWritable: true },
      { pubkey: marketInfo.baseMint, isSigner: false, isWritable: false },
      { pubkey: marketInfo.quoteMint, isSigner: false, isWritable: false },
      // Use a dummy address if using the new dex upgrade to save tx space.
      {
        pubkey: marketInfo.authority ? marketInfo.quoteMint : SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }
    ].concat(marketInfo.authority ? { pubkey: marketInfo.authority, isSigner: false, isWritable: false } : []).concat(
      marketInfo.authority && marketInfo.pruneAuthority ? { pubkey: marketInfo.pruneAuthority, isSigner: false, isWritable: false } : []
    );
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode(
      {
        version: 0,
        instruction: 0,
        baseLotSize: marketInfo.baseLotSize,
        quoteLotSize: marketInfo.quoteLotSize,
        feeRateBps: marketInfo.feeRateBps,
        vaultSignerNonce: marketInfo.vaultSignerNonce,
        quoteDustThreshold: marketInfo.quoteDustThreshold
      },
      data
    );
    return new TransactionInstruction13({
      keys,
      programId,
      data
    });
  }
};

// src/utils/utils1216.ts
import { PublicKey as PublicKey25, TransactionInstruction as TransactionInstruction14 } from "@solana/web3.js";
import BN19 from "bn.js";
var _Utils1216 = class _Utils1216 extends Base {
  // pda
  static getPdaPoolId(programId, ammId) {
    return findProgramAddress([this.SEED_CONFIG.pool.id, ammId.toBuffer()], programId);
  }
  static getPdaOwnerId(programId, poolId, owner, version2) {
    return findProgramAddress(
      [
        this.SEED_CONFIG.owner.id,
        poolId.toBuffer(),
        owner.toBuffer(),
        // new BN(version).toBuffer()
        Buffer.from(new BN19(version2).toArray())
      ],
      programId
    );
  }
  static getAllInfo(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      poolIds,
      wallet,
      chainTime
    }) {
      if (poolIds.length === 0) return [];
      const allPoolPda = poolIds.map((id) => this.getPdaPoolId(programId, id).publicKey);
      const allOwnerPda = [];
      for (let itemVersion = 0; itemVersion < this.VERSION_PROJECT.length; itemVersion++) {
        allOwnerPda.push(...allPoolPda.map((id) => this.getPdaOwnerId(programId, id, wallet, itemVersion).publicKey));
      }
      const pdaInfo = yield getMultipleAccountsInfo(connection, [...allPoolPda, ...allOwnerPda]);
      const info = [];
      for (let index = 0; index < pdaInfo.length; index++) {
        const version2 = Math.floor(index / poolIds.length);
        const i = index % poolIds.length;
        const itemPoolId = allPoolPda[i];
        const itemOwnerId = allOwnerPda[index];
        const itemPoolInfoS = pdaInfo[i];
        const itemOwnerInfoS = pdaInfo[poolIds.length + index];
        if (!(itemPoolInfoS && itemOwnerInfoS)) continue;
        if (itemPoolInfoS.data.length !== this.POOL_LAYOUT.span || itemOwnerInfoS.data.length !== this.OWNER_LAYOUT.span)
          continue;
        const itemPoolInfo = this.POOL_LAYOUT.decode(itemPoolInfoS.data);
        const itemOwnerInfo = this.OWNER_LAYOUT.decode(itemOwnerInfoS.data);
        const openTime = itemPoolInfo.openTime.toNumber();
        const endTime = itemPoolInfo.endTime.toNumber();
        const hasCanClaimToken = itemOwnerInfo.tokenInfo.map((i2) => i2.debtAmount.gt(new BN19(0))).filter((i2) => !i2).length !== 3;
        const inCanClaimTime = chainTime > openTime && chainTime < endTime && itemPoolInfo.status === 1;
        const canClaim = hasCanClaimToken && inCanClaimTime;
        info.push({
          programId,
          poolId: itemPoolId,
          ammId: itemPoolInfo.ammId,
          ownerAccountId: itemOwnerId,
          snapshotLpAmount: itemOwnerInfo.lpAmount,
          project: this.VERSION_PROJECT[version2],
          openTime,
          endTime,
          canClaim,
          canClaimErrorType: !hasCanClaimToken ? "alreadyClaimIt" : !inCanClaimTime ? "outOfOperationalTime" : void 0,
          tokenInfo: itemPoolInfo.tokenInfo.map((itemPoolToken, i2) => ({
            programId: TOKEN_PROGRAM_ID,
            mintAddress: itemPoolToken.mintAddress,
            mintVault: itemPoolToken.mintVault,
            mintDecimals: itemPoolToken.mintDecimals,
            perLpLoss: itemPoolToken.perLpLoss,
            debtAmount: itemOwnerInfo.tokenInfo[i2].debtAmount.add(itemOwnerInfo.tokenInfo[i2].claimedAmount)
          }))
        });
      }
      return info;
    });
  }
  static makeClaimInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const frontInstructionsType = [];
      const endInstructions = [];
      const endInstructionsType = [];
      const instructions = [];
      const instructionsType = [];
      const signers = [];
      const ownerVaultList = [];
      for (const itemToken of poolInfo.tokenInfo) {
        ownerVaultList.push(
          yield this._selectOrCreateTokenAccount({
            programId: itemToken.programId,
            mint: itemToken.mintAddress,
            tokenAccounts: itemToken.mintAddress.equals(Token.WSOL.mint) ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.wallet,
              amount: 0,
              frontInstructions,
              endInstructions: itemToken.mintAddress.equals(Token.WSOL.mint) ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: itemToken.mintAddress.equals(Token.WSOL.mint) ? false : ownerInfo.associatedOnly,
            checkCreateATAOwner: ownerInfo.checkCreateATAOwner
          })
        );
      }
      instructions.push(
        this.makeClaimInstruction({
          programId: poolInfo.programId,
          poolInfo,
          ownerInfo: {
            wallet: ownerInfo.wallet,
            ownerPda: poolInfo.ownerAccountId,
            claimAddress: ownerVaultList
          }
        })
      );
      instructionsType.push(8 /* util1216OwnerClaim */);
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.wallet,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: instructionsType, instructions, signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeClaimAllInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfos,
      ownerInfo,
      makeTxVersion,
      lookupTableCache
    }) {
      var _a;
      const frontInstructions = [];
      const frontInstructionsType = [];
      const endInstructions = [];
      const endInstructionsType = [];
      const instructions = [];
      const instructionsType = [];
      const signers = [];
      const tempNewVault = {};
      for (const poolInfo of poolInfos) {
        const ownerVaultList = [];
        for (const itemToken of poolInfo.tokenInfo) {
          const tempVault = (_a = tempNewVault[itemToken.mintAddress.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
            programId: itemToken.programId,
            mint: itemToken.mintAddress,
            tokenAccounts: itemToken.mintAddress.equals(Token.WSOL.mint) ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.wallet,
              amount: 0,
              frontInstructions,
              endInstructions: itemToken.mintAddress.equals(Token.WSOL.mint) ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: itemToken.mintAddress.equals(Token.WSOL.mint) ? false : ownerInfo.associatedOnly,
            checkCreateATAOwner: ownerInfo.checkCreateATAOwner
          });
          tempNewVault[itemToken.mintAddress.toString()] = tempVault;
          ownerVaultList.push(tempVault);
        }
        instructions.push(
          this.makeClaimInstruction({
            programId: poolInfo.programId,
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              ownerPda: poolInfo.ownerAccountId,
              claimAddress: ownerVaultList
            }
          })
        );
        instructionsType.push(8 /* util1216OwnerClaim */);
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.wallet,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: instructionsType, instructions, signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeClaimInstruction({
    programId,
    poolInfo,
    ownerInfo
  }) {
    const dataLayout = struct([]);
    const keys = [
      { pubkey: ownerInfo.wallet, isSigner: true, isWritable: true },
      { pubkey: poolInfo.poolId, isSigner: false, isWritable: true },
      { pubkey: ownerInfo.ownerPda, isSigner: false, isWritable: true },
      ...ownerInfo.claimAddress.map((i) => ({ pubkey: i, isSigner: false, isWritable: true })),
      ...poolInfo.tokenInfo.map(({ mintVault }) => ({ pubkey: mintVault, isSigner: false, isWritable: true })),
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
    ];
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({}, data);
    const aData = Buffer.from([...[10, 66, 208, 184, 161, 6, 191, 98], ...data]);
    return new TransactionInstruction14({
      keys,
      programId,
      data: aData
    });
  }
};
_Utils1216.CLAIMED_NUM = 3;
_Utils1216.POOL_LAYOUT = struct([
  blob(8),
  u82("bump"),
  u82("status"),
  u64("openTime"),
  u64("endTime"),
  publicKey("ammId"),
  seq2(
    struct([
      u82("mintDecimals"),
      publicKey("mintAddress"),
      publicKey("mintVault"),
      u64("perLpLoss"),
      u64("totalClaimedAmount")
    ]),
    _Utils1216.CLAIMED_NUM,
    "tokenInfo"
  ),
  seq2(u64(), 10, "padding")
]);
_Utils1216.OWNER_LAYOUT = struct([
  blob(8),
  u82("bump"),
  u82("version"),
  publicKey("poolId"),
  publicKey("owner"),
  u64("lpAmount"),
  seq2(struct([publicKey("mintAddress"), u64("debtAmount"), u64("claimedAmount")]), _Utils1216.CLAIMED_NUM, "tokenInfo"),
  seq2(u64(), 4, "padding")
]);
_Utils1216.DEFAULT_POOL_ID = [
  "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
  "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
  "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
  "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
  "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
  "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
  "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
  "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P",
  "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"
].map((i) => new PublicKey25(i));
_Utils1216.SEED_CONFIG = {
  pool: {
    id: Buffer.from("pool_seed", "utf8")
  },
  owner: {
    id: Buffer.from("user_claim_seed", "utf8")
  }
};
_Utils1216.VERSION_PROJECT = [void 0, "Francium", "Tulip", "Larix"];
var Utils1216 = _Utils1216;
export {
  AMM_CONFIG_SEED,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  AccountMeta,
  AccountMetaReadonly,
  AmmConfigLayout,
  BIT_PRECISION,
  BNDivCeil,
  BNLayout,
  Base,
  BitStructure,
  Blob,
  Clmm,
  Currency,
  CurrencyAmount,
  DEVNET_FARM_POOLS,
  DEVNET_LP_TOKENS,
  DEVNET_OFFICIAL_LIQUIDITY_POOLS,
  DEVNET_PROGRAM_ID,
  DEVNET_SPL_TOKENS,
  DataElement,
  ENDPOINT,
  EXTENSION_TICKARRAY_BITMAP_SIZE,
  ErrorCode,
  FARM_LEDGER_LAYOUT_V3_1,
  FARM_LEDGER_LAYOUT_V3_2,
  FARM_LEDGER_LAYOUT_V5_1,
  FARM_LEDGER_LAYOUT_V5_2,
  FARM_LEDGER_LAYOUT_V6_1,
  FARM_STATE_LAYOUT_V3,
  FARM_STATE_LAYOUT_V5,
  FARM_STATE_LAYOUT_V6,
  FARM_VERSION_TO_LEDGER_LAYOUT,
  FARM_VERSION_TO_STATE_LAYOUT,
  FEE_RATE_DENOMINATOR,
  FETCH_TICKARRAY_COUNT,
  FIVE,
  Farm,
  Fee,
  Fraction,
  INSTRUCTION_PROGRAM_ID,
  InstructionType,
  LIQUIDITY_FEES_DENOMINATOR,
  LIQUIDITY_FEES_NUMERATOR,
  LIQUIDITY_STATE_LAYOUT_V4,
  LIQUIDITY_STATE_LAYOUT_V5,
  LIQUIDITY_VERSION_TO_STATE_LAYOUT,
  LOG_B_2_X32,
  LOG_B_P_ERR_MARGIN_LOWER_X64,
  LOG_B_P_ERR_MARGIN_UPPER_X64,
  LOOKUP_TABLE_CACHE,
  Layout,
  Liquidity,
  LiquidityMath,
  LiquidityPoolStatus,
  LogLevel,
  Logger,
  MAINNET_FARM_POOLS,
  MAINNET_LP_TOKENS,
  MAINNET_OFFICIAL_LIQUIDITY_POOLS,
  MAINNET_PROGRAM_ID,
  MAINNET_SPL_TOKENS,
  MARKET_STATE_LAYOUT_V2,
  MARKET_STATE_LAYOUT_V3,
  MARKET_VERSION_TO_STATE_LAYOUT,
  MAX_BASE64_SIZE,
  MAX_SQRT_PRICE_X64,
  MAX_TICK,
  MEMO_PROGRAM_ID,
  METADATA_PROGRAM_ID,
  MIN_SQRT_PRICE_X64,
  MIN_TICK,
  Market,
  MarketV2,
  MathUtil,
  MaxU64,
  MaxUint128,
  ModelDataInfo,
  ModelDataPubkey,
  NEGATIVE_ONE,
  ONE,
  OPERATION_SEED,
  ObservationInfoLayout,
  ObservationLayout,
  OperationLayout,
  OptionLayout,
  POOL_REWARD_VAULT_SEED,
  POOL_SEED,
  POOL_TICK_ARRAY_BITMAP_SEED,
  POOL_VAULT_SEED,
  POSITION_SEED,
  Percent,
  PoolInfoLayout,
  PoolUtils,
  PositionInfoLayout,
  PositionRewardInfoLayout,
  PositionUtils,
  Price,
  ProtocolPositionLayout,
  Q128,
  Q64,
  RAYDIUM_MAINNET,
  REAL_FARM_STATE_LAYOUT_V3,
  REAL_FARM_STATE_LAYOUT_V5,
  REAL_FARM_STATE_LAYOUT_V6,
  RENT_PROGRAM_ID,
  RewardInfo,
  Rounding,
  SERUM_PROGRAMID_TO_VERSION,
  SERUM_PROGRAM_ID_V3,
  SERUM_VERSION_TO_PROGRAMID,
  SOL,
  SPL_ACCOUNT_LAYOUT,
  SPL_MINT_LAYOUT,
  SYSTEM_PROGRAM_ID,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_RENT_PUBKEY,
  Spl,
  SqrtPriceMath,
  Structure2 as Structure,
  SwapMath,
  TEN,
  TESTNET_FARM_POOLS,
  TESTNET_LP_TOKENS,
  TESTNET_OFFICIAL_LIQUIDITY_POOLS,
  TESTNET_SPL_TOKENS,
  THREE,
  TICK_ARRAY_BITMAP_SIZE,
  TICK_ARRAY_SEED,
  TICK_ARRAY_SIZE,
  TICK_SPACINGS,
  TOKEN_PROGRAM_ID,
  TWO,
  TickArrayBitmap,
  TickArrayBitmapExtension,
  TickArrayBitmapExtensionLayout,
  TickArrayLayout,
  TickLayout,
  TickMath,
  TickQuery,
  TickUtils,
  Token,
  TokenAmount,
  TokenList,
  TradeV2,
  TxVersion,
  U64Resolution,
  U64_IGNORE_RANGE,
  UInt,
  Union2 as Union,
  Utils1216,
  Voter,
  VoterDepositEntry,
  VoterLockup,
  VoterRegistrar,
  VoterVotingMintConfig,
  WSOL,
  WideBits,
  WrappedLayout,
  ZERO,
  _100,
  _1000,
  _10000,
  _100_PERCENT,
  _SERUM_PROGRAM_ID_V3,
  array,
  bits,
  blob,
  bool2 as bool,
  buildSimpleTransaction,
  buildTransaction,
  chunkArray,
  closePositionInstruction,
  collectRewardInstruction,
  createPoolInstruction,
  cstr,
  currencyEquals,
  decodeBool,
  decreaseLiquidityInstruction,
  divCeil,
  encodeBool,
  f32,
  f32be,
  f64,
  f64be,
  fetchMultipleMintInfos,
  findProgramAddress,
  forecastTransactionSize,
  formatLayout,
  generatePubKey,
  getDxByDyBaseIn,
  getDyByDxBaseIn,
  getMultipleAccountsInfo,
  getMultipleAccountsInfoWithCustomFlags,
  getMultipleLookupTableInfo,
  getPdaAmmConfigId,
  getPdaExBitmapAccount,
  getPdaMetadataKey,
  getPdaOperationAccount,
  getPdaPersonalPositionAddress,
  getPdaPoolId,
  getPdaPoolRewardVaulId,
  getPdaPoolVaultId,
  getPdaProtocolPositionAddress,
  getPdaTickArrayAddress,
  getStablePrice,
  getTransferAmountFee,
  getWSOLAmount,
  greedy,
  i128,
  i16ToBytes,
  i32ToBytes,
  i64,
  i8,
  increasePositionFromBaseInstruction,
  increasePositionFromLiquidityInstruction,
  initRewardInstruction,
  initStableModelLayout,
  inspectAll,
  inspectBN,
  inspectCurrency,
  inspectPublicKey,
  inspectToken,
  intersection,
  isZero,
  jsonInfo2PoolKeys,
  leadingZeros,
  leastSignificantBit,
  minExpirationTime,
  mostSignificantBit,
  ns64,
  ns64be,
  nu64,
  nu64be,
  offset,
  openPositionFromBaseInstruction,
  openPositionFromLiquidityInstruction,
  option,
  parseBigNumberish,
  parseSimulateLogToJson,
  parseSimulateValue,
  poolKeys2JsonInfo,
  poolTypeV6,
  publicKey,
  rustEnum,
  s16,
  s16be,
  s24,
  s24be,
  s32,
  s32be,
  s40,
  s40be,
  s48,
  s48be,
  s8,
  seq2 as seq,
  setRewardInstruction,
  simulateMultipleInstruction,
  simulateTransaction,
  splitNumber,
  splitTxAndSigners,
  str,
  struct,
  swapInstruction,
  tagged,
  tenExponentiate,
  trailingZeros,
  u128,
  u16,
  u16ToBytes,
  u16be,
  u24,
  u24be,
  u322 as u32,
  u32ToBytes,
  u32be,
  u40,
  u40be,
  u48,
  u48be,
  u64,
  u82 as u8,
  union2 as union,
  unionLayoutDiscriminator,
  uniq,
  unwarpSol,
  utf8,
  validateAndParsePublicKey,
  vec,
  vecU8,
  xor,
  zeros
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
